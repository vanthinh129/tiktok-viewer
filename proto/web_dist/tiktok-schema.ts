// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v5.27.1
// source: tiktok-schema.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "TikTok";

export enum AuditStatus {
  AUDITSTATUSUNKNOWN = 0,
  AUDITSTATUSPASS = 1,
  AUDITSTATUSFAILED = 2,
  AUDITSTATUSREVIEWING = 3,
  AUDITSTATUSFORBIDDEN = 4,
  UNRECOGNIZED = -1,
}

export enum EmoteType {
  EMOTETYPENORMAL = 0,
  EMOTETYPEWITHSTICKER = 1,
  UNRECOGNIZED = -1,
}

export enum ContentSource {
  CONTENTSOURCEUNKNOWN = 0,
  CONTENTSOURCENORMAL = 1,
  CONTENTSOURCECAMERA = 2,
  UNRECOGNIZED = -1,
}

export enum EmotePrivateType {
  EMOTE_PRIVATE_TYPE_NORMAL = 0,
  EMOTE_PRIVATE_TYPE_SUB_WAVE = 1,
  UNRECOGNIZED = -1,
}

export enum TextType {
  DISPLAY_TEXT = 0,
  CONTENT = 1,
  UNRECOGNIZED = -1,
}

export enum LinkmicApplierSortSetting {
  LINKMIC_APPLIER_SORT_SETTING_NONE = 0,
  LINKMIC_APPLIER_SORT_SETTING_BY_GIFT_SCORE = 1,
  UNRECOGNIZED = -1,
}

export enum HashtagNamespace {
  GLOBAL = 0,
  GAMING = 1,
  UNRECOGNIZED = -1,
}

export enum AgreeStatus {
  AGREE_UNKNOWN = 0,
  AGREE = 1,
  REJECT = 2,
  UNRECOGNIZED = -1,
}

export enum KickoutReason {
  KICKOUT_REASON_UNKNOWN = 0,
  KICKOUT_REASON_FIRST_FRAME_TIMEOUT = 1,
  KICKOUT_REASON_BY_HOST = 2,
  KICKOUT_REASON_RTC_LOST_CONNECTION = 3,
  KICKOUT_REASON_BY_PUNISH = 4,
  KICKOUT_REASON_BY_ADMIN = 5,
  KICKOUT_REASON_HOST_REMOVE_ALL_GUESTS = 6,
  UNRECOGNIZED = -1,
}

export enum GroupStatus {
  GROUP_STATUS_UNKNOWN = 0,
  GROUP_STATUS_WAITING = 1,
  GROUP_STATUS_LINKED = 3,
  UNRECOGNIZED = -1,
}

export enum BusinessCase {
  BUSINESS_NOT_SET = 0,
  APPLY_BIZ_CONTENT = 1,
  INVITE_BIZ_CONTENT = 2,
  REPLY_BIZ_CONTENT = 3,
  PERMIT_BIZ_CONTENT = 4,
  JOIN_DIRECT_BIZ_CONTENT = 5,
  KICK_OUT_BIZ_CONTENT = 6,
  LIST_CHANGE_BIZ_CONTENT = 11,
  MULTI_LIVE_CONTENT = 100,
  COHOST_CONTENT = 200,
  UNRECOGNIZED = -1,
}

export enum ReplyStatus {
  REPLY_STATUS_UNKNOWN = 0,
  REPLY_STATUS_AGREE = 1,
  REPLY_STATUS_REFUSE_PERSONALLY = 2,
  REPLY_STATUS_REFUSE_TYPE_NOT_SUPPORT = 3,
  REPLY_STATUS_REFUSE_PROCESSING_INVITATION = 4,
  REPLY_STATUS_REFUSE_BY_TIMEOUT = 5,
  REPLY_STATUS_REFUSE_EXCEPTION = 6,
  REPLY_STATUS_REFUSE_SYSTEM_NOT_SUPPORTED = 7,
  REPLY_STATUS_REFUSE_SUBTYPE_DIFFERENCE = 8,
  REPLY_STATUS_REFUSE_IN_MICROOM = 9,
  REPLY_STATUS_REFUSE_NOT_LOAD_PLUGIN = 10,
  REPLY_STATUS_REFUSE_IN_MULTI_GUEST = 11,
  REPLY_STATUS_REFUSE_PAUSE_LIVE = 12,
  REPLY_STATUS_REFUSE_OPEN_CAMERA_DIALOG_SHOWING = 13,
  REPLY_STATUS_REFUSE_DRAW_GUESSING = 14,
  REPLY_STATUS_REFUSE_RANDOM_MATCHING = 15,
  REPLY_STATUS_REFUSE_IN_MATCH_PROCESSING = 16,
  REPLY_STATUS_REFUSE_IN_MICROOM_FOR_MULTI_COHOST = 17,
  REPLY_STATUS_REFUSE_COHOST_FINISHED = 18,
  REPLY_STATUS_REFUSE_NOT_CONNECTED = 19,
  REPLY_STATUS_REFUSE_LINKMIC_FULL = 20,
  REPLY_STATUS_REFUSE_ARC_INCOMPATIBLE = 21,
  REPLY_STATUS_REFUSE_PROCESSING_OTHER_INVITE = 22,
  REPLY_STATUS_REFUSE_PROCESSING_OTHER_APPLY = 23,
  REPLY_STATUS_REFUSE_IN_ANCHOR_COHOST = 24,
  REPLY_STATUS_REFUSE_TOPIC_PAIRING = 25,
  UNRECOGNIZED = -1,
}

export enum SubscribeType {
  SUBSCRIBETYPE_ONCE = 0,
  SUBSCRIBETYPE_AUTO = 1,
  SUBSCRIBETYPE_DEFAULT = 100,
  UNRECOGNIZED = -1,
}

export enum OldSubscribeStatus {
  OLD_SUBSCRIBE_STATUS_FIRST = 0,
  OLD_SUBSCRIBE_STATUS_RESUB = 1,
  OLD_SUBSCRIBE_STATUS_SUBIN_GRACE_PERIOD = 2,
  OLD_SUBSCRIBE_STATUS_SUB_NOTIN_GRACE_PERIOD = 3,
  OLD_SUBSCRIBE_STATUS_DEFAULT = 100,
  UNRECOGNIZED = -1,
}

export enum SubscribingStatus {
  SUBSCRIBING_STATUS_UNKNOWN = 0,
  SUBSCRIBING_STATUS_ONCE = 1,
  SUBSCRIBING_STATUS_CIRCLE = 2,
  SUBSCRIBING_STATUS_CIRCLE_CANCEL = 3,
  SUBSCRIBING_STATUS_REFUND = 4,
  SUBSCRIBING_STATUS_IN_GRACE_PERIOD = 5,
  SUBSCRIBING_STATUS_NOT_IN_GRACE_PERIOD = 6,
  UNRECOGNIZED = -1,
}

export enum LinkmicStatus {
  Disable = 0,
  Enable = 1,
  Just_Following = 2,
  Multi_Linking = 3,
  Multi_Linking_Only_Following = 4,
  UNRECOGNIZED = -1,
}

export enum MemberMessageAction {
  UNKNOWN = 0,
  /** JOINED - User Joined the Stream */
  JOINED = 1,
  /** SUBSCRIBED - User Subscribed to the Host */
  SUBSCRIBED = 3,
  UNRECOGNIZED = -1,
}

export enum ControlAction {
  CONTROL_ACTION_FALLBACK_UNKNOWN = 0,
  CONTROL_ACTION_STREAM_PAUSED = 1,
  CONTROL_ACTION_STREAM_UNPAUSED = 2,
  CONTROL_ACTION_STREAM_ENDED = 3,
  CONTROL_ACTION_STREAM_SUSPENDED = 4,
  UNRECOGNIZED = -1,
}

export enum LinkLayerMessageType {
  Linker_Unknown = 0,
  Linker_Create = 1,
  Linker_Invite = 2,
  Linker_Apply = 3,
  Linker_Permit = 4,
  Linker_Reply = 5,
  Linker_Kick_Out = 6,
  Linker_Cancel_Apply = 7,
  Linker_Cancel_Invite = 8,
  Linker_Leave = 9,
  Linker_Finish = 10,
  Linker_List_Change = 11,
  Linker_Join_Direct = 12,
  Linker_Join_Group = 13,
  Linker_Permit_Group = 14,
  Linker_Cancel_Group = 15,
  Linker_Leave_Group = 16,
  Linker_P2P_Group_Change = 17,
  Linker_Group_Change = 18,
  UNRECOGNIZED = -1,
}

export enum BarrageType {
  BarrageType_Unknown = 0,
  EComOrdering = 1,
  EComBuying = 2,
  Normal = 3,
  Subscribe = 4,
  EventView = 5,
  EventRegistered = 6,
  SubscribeGift = 7,
  UserUpgrade = 8,
  GradeUserEntranceNotification = 9,
  FansLevelUpgrade = 10,
  FansLevelEntrance = 11,
  GamePartnership = 12,
  UNRECOGNIZED = -1,
}

export enum EnvelopeBusinessType {
  BusinessTypeUnknown = 0,
  BusinessTypeUserDiamond = 1,
  BusinessTypePlatformDiamond = 2,
  BusinessTypePlatformShell = 3,
  BusinessTypePortal = 4,
  BusinessTypePlatformMerch = 5,
  BusinessTypeEoYDiamond = 6,
  BusinessTypeFanClubGtM = 7,
  UNRECOGNIZED = -1,
}

export enum EnvelopeFollowShowStatus {
  ENVELOPE_FOLLOW_SHOW_STATUS_ENVELOPE_FOLLOW_SHOW_UNKNOWN = 0,
  ENVELOPE_FOLLOW_SHOW_STATUS_ENVELOPE_FOLLOW_SHOW = 1,
  ENVELOPE_FOLLOW_SHOW_STATUS_ENVELOPE_FOLLOW_NOT_SHOW = 2,
  UNRECOGNIZED = -1,
}

export enum EnvelopeDisplay {
  ENVELOPE_DISPLAY_UNKNOWN = 0,
  ENVELOPE_DISPLAY_NEW = 1,
  ENVELOPE_DISPLAY_HIDE = 2,
  UNRECOGNIZED = -1,
}

export enum CommonContentCase {
  COMMON_CONTENT_NOT_SET = 0,
  CREATE_CHANNEL_CONTENT = 100,
  LIST_CHANGE_CONTENT = 102,
  INVITE_CONTENT = 103,
  APPLY_CONTENT = 104,
  PERMIT_APPLY_CONTENT = 105,
  REPLY_INVITE_CONTENT = 106,
  KICK_OUT_CONTENT = 107,
  CANCEL_APPLY_CONTENT = 108,
  CANCEL_INVITE_CONTENT = 109,
  LEAVE_CONTENT = 110,
  FINISH_CONTENT = 111,
  JOIN_DIRECT_CONTENT = 112,
  JOIN_GROUP_CONTENT = 113,
  PERMIT_GROUP_CONTENT = 114,
  CANCEL_GROUP_CONTENT = 115,
  LEAVE_GROUP_CONTENT = 116,
  P2P_GROUP_CHANGE_CONTENT = 117,
  GROUP_CHANGE_CONTENT = 118,
  UNRECOGNIZED = -1,
}

export enum LinkMessageType {
  TYPE_LINKER_UNKNOWN = 0,
  TYPE_LINKER_CREATE = 1,
  TYPE_LINKER_CLOSE = 2,
  TYPE_LINKER_INVITE = 3,
  TYPE_LINKER_APPLY = 4,
  TYPE_LINKER_REPLY = 5,
  TYPE_LINKER_ENTER = 6,
  TYPE_LINKER_LEAVE = 7,
  TYPE_LINKER_PERMIT = 8,
  TYPE_LINKER_CANCEL_INVITE = 9,
  TYPE_LINKER_WAITING_LIST_CHANGE = 10,
  TYPE_LINKER_LINKED_LIST_CHANGE = 11,
  TYPE_LINKER_UPDATE_USER = 12,
  TYPE_LINKER_KICK_OUT = 13,
  TYPE_LINKER_CANCEL_APPLY = 14,
  TYPE_LINKER_MUTE = 15,
  TYPE_LINKER_MATCH = 16,
  TYPE_LINKER_UPDATE_USER_SETTING = 17,
  TYPE_LINKER_MIC_IDX_UPDATE = 18,
  TYPE_LINKER_LEAVE_V2 = 19,
  TYPE_LINKER_WAITING_LIST_CHANGE_V2 = 20,
  TYPE_LINKER_LINKED_LIST_CHANGE_V2 = 21,
  TYPE_LINKER_COHOST_LIST_CHANGE = 22,
  TYPE_LINKER_MEDIA_CHANGE = 23,
  TYPE_LINKER_ACCEPT_NOTICE = 24,
  TYPE_LINKER_SYS_KICK_OUT = 101,
  TYPE_LINKMIC_USER_TOAST = 102,
  UNRECOGNIZED = -1,
}

export enum MessageType {
  MESSAGE_TYPE_SUB_SUCCESS = 0,
  MESSAGE_TYPE_ANCHOR_REMINDER = 1,
  MESSAGE_TYPE_ENTER_ROOM_EXPIRE_SOON = 2,
  MESSAGE_TYPE_SUB_GOAL_CREATE_TO_ANCHOR = 3,
  MESSAGE_TYPE_SUB_GOAL_COMPLETE_TO_AUDIENCE = 4,
  MESSAGE_TYPE_SUB_GOAL_COMPLETE_TO_ANCHOR = 5,
  MESSAGE_TYPE_SUB_GIFT_TIK_TOK_2_USER_NOTICE = 6,
  MESSAGE_TYPE_SUB_GIFT_TIK_TOK_2_ANCHOR_NOTICE = 7,
  MESSAGE_TYPE_SUB_GIFT_T_RECEIVES_END_NOTICE = 8,
  MESSAGE_TYPE_SUB_GIFTS_END_SUCCEED_ROOM_MESSAGE = 9,
  MESSAGE_TYPE_SUB_GIFTS_END_SUCCEED_ANCHOR_NOTICE = 10,
  MESSAGE_TYPE_SUB_GIFT_LOW_VERSION_UPGRADE_NOTICE = 11,
  MESSAGE_TYPE_SUB_GIFT_USER_BUY_AU_TH_NOTICE = 12,
  MESSAGE_TYPE_SUB_COMMON_TEXT_NOTICE = 13,
  MESSAGE_TYPE_SUB_MODERATOR_PIN_PERK = 14,
  UNRECOGNIZED = -1,
}

export enum Scene {
  SCENE_UNKNOWN = 0,
  SCENE_CO_HOST = 2,
  SCENE_MULTI_LIVE = 4,
  UNRECOGNIZED = -1,
}

export enum RewardCondition {
  REWARD_CONDITION_SUBSCRIPTION = 0,
  REWARD_CONDITION_SUB_WAVE_CUSTOM = 1,
  UNRECOGNIZED = -1,
}

export enum UserEmoteUploadSource {
  USER_EMOTE_UPLOAD_SOURCE_EMOTE_UPLOAD_SOURCE_ANCHOR = 0,
  USER_EMOTE_UPLOAD_SOURCE_EMOTE_UPLOAD_SOURCE_SUBSCRIBER = 1,
  USER_EMOTE_UPLOAD_SOURCE_EMOTE_UPLOAD_SOURCE_MODERATOR = 2,
  UNRECOGNIZED = -1,
}

export enum EmoteScene {
  EMOTE_SCENE_SUBSCRIPTION = 0,
  EMOTE_SCENE_GAME = 1,
  UNRECOGNIZED = -1,
}

export enum PunishTypeId {
  PUNISH_TYPE_IDUN_KNOWN = 0,
  PUNISH_TYPE_ID_BAN_LINK_MIC = 9,
  PUNISH_TYPE_ID_BAN_GAME_PARTNERSHIP = 25,
  PUNISH_TYPE_ID_REMOVE_GAME_PARTNERSHIP = 26,
  PUNISH_TYPE_ID_BANCO_HOST_LINK_MIC = 55,
  PUNISH_TYPE_ID_AUTHORITY_LIMIT_MATCH = 57,
  PUNISH_TYPE_ID_BAN_VOICE_CHAT = 59,
  PUNISH_TYPE_ID_BAN_LIVE_GOAL = 64,
  PUNISH_TYPE_ID_VIEWER_LIMIT = 70,
  UNRECOGNIZED = -1,
}

export enum MultiplierType {
  MULTIPLIER_TYPE_UNSPECIFIED = 0,
  MULTIPLIER_TYPE_CRITICAL_STRIKE = 1,
  MULTIPLIER_TYPE_TOP_2 = 2,
  MULTIPLIER_TYPE_TOP_3 = 3,
  UNRECOGNIZED = -1,
}

export enum LinkmicGiftExpressionStrategy {
  LINKMIC_GIFT_EXPRESSION_STRATEGY_CONTROL_V_1 = 0,
  LINKMIC_GIFT_EXPRESSION_STRATEGY_EXPERIMENT_V_1 = 1,
  LINKMIC_GIFT_EXPRESSION_STRATEGY_EXPERIMENT_V_2 = 2,
  UNRECOGNIZED = -1,
}

export enum GiftMessageVersion {
  GIFT_MESSAGE_VERSION_0 = 0,
  GIFT_MESSAGE_VERSION_1 = 1,
  UNRECOGNIZED = -1,
}

export enum TagType {
  TAG_TYPE_CREATOR_CR_M_TAG_TYPE_UNKNOWN = 0,
  TAG_TYPE_CREATOR_CR_M_TAG_TYPE_USER_GRADE = 1,
  TAG_TYPE_CREATOR_CR_M_TAG_TYPE_FANS_LEVEL = 2,
  TAG_TYPE_CREATOR_CR_M_TAG_TYPE_WATCH_ME_DAYS_AGO = 3,
  TAG_TYPE_CREATOR_CR_M_TAG_TYPE_CUSTOM = 4,
  TAG_TYPE_CREATOR_CR_M_TAG_TYPE_TITLE_GIFT = 5,
  TAG_TYPE_CREATOR_CR_M_TAG_TYPE_FIRST_JOINED_TEAM = 6,
  TAG_TYPE_CREATOR_CR_M_TAG_TYPE_PAY_ACCOMPANY_DAYS = 7,
  TAG_TYPE_CREATOR_CR_M_TAG_TYPE_SPONSOR_GIFT_LAST_ROOM = 8,
  TAG_TYPE_CREATOR_CR_M_TAG_TYPE_MATCH_MVP_LAST_ROOM = 9,
  TAG_TYPE_CREATOR_CR_M_TAG_TYPE_LARGE_AMOUNT_GIFT_LAST_ROOM = 10,
  TAG_TYPE_CREATOR_CR_M_TAG_TYPE_COMMENT_LAST_ROOM = 11,
  TAG_TYPE_CREATOR_CR_M_TAG_TYPE_RECENT_TITLED_GIFT = 12,
  TAG_TYPE_CREATOR_CR_M_TAG_TYPE_MEET_ANNIVERSARY = 13,
  TAG_TYPE_CREATOR_CR_M_TAG_TYPE_FANS_SLEEP = 14,
  TAG_TYPE_CREATOR_CR_M_TAG_TYPE_NOT_SEND_HEART_ME = 15,
  TAG_TYPE_CREATOR_CR_M_TAG_TYPE_NOT_JOIN_TEAM = 16,
  TAG_TYPE_CREATOR_CR_M_TAG_TYPE_FIRST_WATCH_LIVE = 17,
  TAG_TYPE_CREATOR_CR_M_TAG_TYPE_RECENT_COMMENT = 18,
  TAG_TYPE_CREATOR_CR_M_TAG_TYPE_RECENT_GIFT_TIMES = 19,
  TAG_TYPE_CREATOR_CR_M_TAG_TYPE_RECENT_WATCH_LIVE_DURATION = 20,
  TAG_TYPE_CREATOR_CR_M_TAG_TYPE_RECENT_GIFT = 21,
  TAG_TYPE_CREATOR_CR_M_TAG_TYPE_RECENT_LIVE_CONTRIBUTION_TOP = 22,
  TAG_TYPE_CREATOR_CR_M_TAG_TYPE_JUST_UPGRADE = 28,
  TAG_TYPE_CREATOR_CR_M_TAG_TYPE_FAN_TOTAL_WATCH_DURATION = 29,
  TAG_TYPE_CREATOR_CR_M_TAG_TYPE_FAN_TOTAL_COMMENT_NUM = 30,
  TAG_TYPE_CREATOR_CR_M_TAG_TYPE_FAN_TOTAL_GIFT_SENT_NUM = 31,
  UNRECOGNIZED = -1,
}

export enum TopicActionType {
  TOPIC_ACTION_TYPE_UNKNOWN = 0,
  TOPIC_ACTION_TYPE_FOLLOW = 1,
  UNRECOGNIZED = -1,
}

export enum UserMetricsType {
  USER_METRICS_TYPE_UNKNOWN = 0,
  USER_METRICS_TYPE_GRADE = 1,
  USER_METRICS_TYPE_SUBSCRIBE = 2,
  USER_METRICS_TYPE_FOLLOW = 3,
  USER_METRICS_TYPE_FANS_CLUB = 4,
  USER_METRICS_TYPE_TOP_VIEWER = 5,
  USER_METRICS_TYPE_GIFT = 6,
  UNRECOGNIZED = -1,
}

export enum GiftMessageIgnoreConfig {
  GIFT_MESSAGE_IGNORE_CONFIG_NOT_IGNORE = 0,
  GIFT_MESSAGE_IGNORE_CONFIG_IGNORE_TRAY = 1,
  GIFT_MESSAGE_IGNORE_CONFIG_IGNORE_PS_M = 2,
  GIFT_MESSAGE_IGNORE_CONFIG_IGNORE_TRAY_AND_PS_M = 3,
  UNRECOGNIZED = -1,
}

export enum HorizontalOnclickTriggerType {
  HORIZONTAL_ONCLICK_TRIGGER_TYPE_ONCLICK_TRIGGER_TYPE_UNKNOWN = 0,
  HORIZONTAL_ONCLICK_TRIGGER_TYPE_ONCLICK_TRIGGER_TYPE_LEFT = 1,
  HORIZONTAL_ONCLICK_TRIGGER_TYPE_ONCLICK_TRIGGER_TYPE_MIDDLE = 2,
  HORIZONTAL_ONCLICK_TRIGGER_TYPE_ONCLICK_TRIGGER_TYPE_RIGHT = 3,
  HORIZONTAL_ONCLICK_TRIGGER_TYPE_ONCLICK_TRIGGER_TYPE_ALL_AREA = 4,
  UNRECOGNIZED = -1,
}

export enum ShowType {
  SHOW_TYPE_NORMAL = 0,
  SHOW_TYPE_FADE_IN_OUT = 1,
  UNRECOGNIZED = -1,
}

export enum RenderType {
  RENDER_TYPE_NATIVE = 0,
  RENDER_TYPE_HYBRID = 1,
  RENDER_TYPE_ALPHA = 2,
  UNRECOGNIZED = -1,
}

export enum IconDisplayType {
  ICON_DISPLAY_TYPE_IMAGE = 0,
  ICON_DISPLAY_TYPE_BADGE = 1,
  UNRECOGNIZED = -1,
}

export enum CommentTag {
  COMMENT_TAG_NORMAL = 0,
  COMMENT_TAG_CANDIDATE = 1,
  COMMENT_TAG_OVERAGE = 2,
  UNRECOGNIZED = -1,
}

export enum PerceptionDialogIconType {
  PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_NONE = 0,
  PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_WARNING = 1,
  PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_LINK_MIC = 2,
  PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_GUEST_LINK_MIC = 3,
  PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_LIVE = 4,
  PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_TREASURE_BOX = 5,
  PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_MUTE = 6,
  PERCEPTION_DIALOG_ICON_TYPE_ICON_GAMEPAD_ACCESS_REVOKED = 7,
  PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_BAN_REPORT_LIVE_SINGLE_ROOM = 8,
  PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_BAN_REPORT_LIVE_ALL_ROOM = 9,
  PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_BAN_REPORT_LIVE_GREEN_SCREEN = 10,
  PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_GIFT = 11,
  PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_APPEAL_SUCCESS = 12,
  PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_MATCH = 13,
  PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_LIVE_GOAL = 14,
  PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_SUBSCRIPTION = 15,
  PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_STAR_COMMENT = 16,
  PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_RANKING = 17,
  PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_COMMON = 18,
  UNRECOGNIZED = -1,
}

export enum GoalMessageSource {
  GOAL_MESSAGE_SOURCE_UNKNOWN = 0,
  GOAL_MESSAGE_SOURCE_COMMIT = 1,
  GOAL_MESSAGE_SOURCE_PROGRESS_UPDATE = 2,
  GOAL_MESSAGE_SOURCE_PIN = 3,
  GOAL_MESSAGE_SOURCE_UNPIN = 4,
  GOAL_MESSAGE_SOURCE_REVIEW_CALLBACK = 5,
  GOAL_MESSAGE_SOURCE_SUSPEND = 6,
  GOAL_MESSAGE_SOURCE_CHALLENGE_PROMPT = 7,
  UNRECOGNIZED = -1,
}

export enum ExhibitionType {
  EXHIBITION_TYPE_DEFAULT = 0,
  EXHIBITION_TYPE_FOLD = 1,
  EXHIBITION_TYPE_PUBLIC_SCREEN = 2,
  UNRECOGNIZED = -1,
}

export enum GiftSource {
  GIFT_SOURCE_UNKNOWN = 0,
  GIFT_SOURCE_PLATFORM = 1,
  GIFT_SOURCE_USER_BUY_RANDOM = 2,
  GIFT_SOURCE_USER_BUY_SPECIFIC = 3,
  UNRECOGNIZED = -1,
}

export enum MessageDisplayStyle {
  MESSAGE_DISPLAY_STYLE_DEFAULT = 0,
  MESSAGE_DISPLAY_STYLE_POPUP = 1,
  UNRECOGNIZED = -1,
}

export enum ProfitRankType {
  PROFIT_RANK_TYPE_TYPE_HOURLY_RANK = 0,
  PROFIT_RANK_TYPE_TYPE_WEEKLY_RANK = 1,
  PROFIT_RANK_TYPE_TYPE_HOURLY_STAR_RANK = 2,
  PROFIT_RANK_TYPE_TYPE_WEEKLY_RISING_RANK_ACTIVITY = 3,
  PROFIT_RANK_TYPE_TYPE_WEEKLY_RISING_RANK = 4,
  PROFIT_RANK_TYPE_TYPE_WEEKLY_ROOKIE = 5,
  PROFIT_RANK_TYPE_TYPE_E_COMMERCE_WEEKLY = 6,
  PROFIT_RANK_TYPE_TYPE_E_COMMERCE_DAILY = 7,
  PROFIT_RANK_TYPE_TYPE_DAILY_RANK = 8,
  PROFIT_RANK_TYPE_TYPE_FIRST_GIFT_RANK = 9,
  PROFIT_RANK_TYPE_TYPE_GAME_RANK = 10,
  PROFIT_RANK_TYPE_TYPE_DAILY_GAME = 11,
  PROFIT_RANK_TYPE_TYPE_HALL_OF_FAME_RANK = 12,
  PROFIT_RANK_TYPE_TYPE_RANK_LEAGUE = 13,
  PROFIT_RANK_TYPE_DAILY_ROOKIE = 14,
  PROFIT_RANK_TYPE_TYPE_TEAM_RANK = 15,
  PROFIT_RANK_TYPE_TYPE_CLASS_RANK = 16,
  PROFIT_RANK_TYPE_TYPE_DAILY_GAME_PUB_G = 20,
  PROFIT_RANK_TYPE_TYPE_DAILY_GAME_MLB_B = 21,
  PROFIT_RANK_TYPE_TYPE_DAILY_GAME_FREE_FIRE = 22,
  PROFIT_RANK_TYPE_TYPE_WEEKLY_GAME_SUBCATEGORY_ONE = 23,
  PROFIT_RANK_TYPE_TYPE_WEEKLY_GAME_SUBCATEGORY_TWO = 24,
  PROFIT_RANK_TYPE_TYPE_WEEKLY_GAME_SUBCATEGORY_THREE = 25,
  UNRECOGNIZED = -1,
}

export enum UnionAnimationInfoType {
  UNION_ANIMATION_INFO_TYPE_NO_UNION_ANIMATION = 0,
  UNION_ANIMATION_INFO_TYPE_LOOP = 1,
  UNION_ANIMATION_INFO_TYPE_LOCK = 2,
  UNRECOGNIZED = -1,
}

export enum DisplayStyle {
  DISPLAY_STYLE_NORMAL = 0,
  DISPLAY_STYLE_STAY = 1,
  DISPLAY_STYLE_CHAT = 2,
  UNRECOGNIZED = -1,
}

export enum HitABStatus {
  HIT_A_B_STATUS_HIT_AB_STATUS_NO_HIT = 0,
  HIT_A_B_STATUS_HIT_AB_STATUS_ENTER_FROM_EXTERNAL_LINK_NEW_TEXT = 1,
  HIT_A_B_STATUS_HIT_AB_STATUS_ENTER_FROM_RE_POST_NEW_TEXT = 2,
  UNRECOGNIZED = -1,
}

export enum PollKind {
  POLL_KIND_NORMAL = 0,
  POLL_KIND_GIFT = 1,
  POLL_KIND_CUSTOMIZABLE = 2,
  POLL_KIND_CUSTOMIZABLE_GIFT = 3,
  POLL_KIND_QUICK_GIFT = 4,
  POLL_KIND_EMOTE = 5,
  UNRECOGNIZED = -1,
}

export enum PollTemplateStatus {
  POLL_TEMPLATE_STATUS_TO_BE_REVIEWED = 0,
  POLL_TEMPLATE_STATUS_UNDER_REVIEW = 1,
  POLL_TEMPLATE_STATUS_REVIEWED = 2,
  POLL_TEMPLATE_STATUS_REFUSED = 3,
  UNRECOGNIZED = -1,
}

export enum PollAppealStatus {
  POLL_APPEAL_STATUS_UNKNOWN = 0,
  POLL_APPEAL_STATUS_PASS = 1,
  POLL_APPEAL_STATUS_FAIL = 2,
  UNRECOGNIZED = -1,
}

export enum RankTestMessageScene {
  RANK_TEST_MESSAGE_SCENE_UNKNOWN = 0,
  RANK_TEST_MESSAGE_SCENE_ONLINE_AUDIENCE_TOP_N_UPDATE_PUBLIC_SCREEN = 1,
  UNRECOGNIZED = -1,
}

export enum TriggerReason {
  TRIGGER_REASON_UNKNOWN = 0,
  TRIGGER_REASON_SCORE_UPDATE = 1,
  TRIGGER_REASON_BATTLE_END = 2,
  TRIGGER_REASON_OPT_OUT_UPDATE = 3,
  TRIGGER_REASON_KEEP_ALIVE = 4,
  UNRECOGNIZED = -1,
}

export enum Reason {
  REASON_TIME_UP = 0,
  REASON_CUT_SHORT = 1,
  UNRECOGNIZED = -1,
}

export enum BattleTaskMessageType {
  BATTLE_TASK_MESSAGE_TYPE_START = 0,
  BATTLE_TASK_MESSAGE_TYPE_TASK_UPDATE = 1,
  BATTLE_TASK_MESSAGE_TYPE_TASK_SETTLE = 2,
  BATTLE_TASK_MESSAGE_TYPE_REWARD_SETTLE = 3,
  UNRECOGNIZED = -1,
}

export enum RewardStatus {
  REWARD_STATUS_SUCCEED = 0,
  REWARD_STATUS_FAILED = 1,
  UNRECOGNIZED = -1,
}

export enum BattleAction {
  BATTLE_ACTION_UNKNOWN = 0,
  BATTLE_ACTION_INVITE = 1,
  BATTLE_ACTION_REJECT = 2,
  BATTLE_ACTION_CANCEL = 3,
  BATTLE_ACTION_OPEN = 4,
  BATTLE_ACTION_FINISH = 5,
  BATTLE_ACTION_CUT_SHORT = 6,
  BATTLE_ACTION_ACCEPT = 7,
  BATTLE_ACTION_QUIT_APPLY = 8,
  BATTLE_ACTION_DECLINE_QUIT = 9,
  BATTLE_ACTION_DECLINE_OFF_QUIT = 10,
  BATTLE_ACTION_LEAVE_LINK_MIC = 11,
  UNRECOGNIZED = -1,
}

export enum Result {
  RESULT_WIN = 0,
  RESULT_LOSE = 1,
  RESULT_DRAW = 2,
  UNRECOGNIZED = -1,
}

export enum GiftPermissionType {
  GIFT_PERMISSION_TYPE_UNKNOWN_TYPE = 0,
  GIFT_PERMISSION_TYPE_NO_GIFT_PERMISSION = 1,
  GIFT_PERMISSION_TYPE_ANCHOR_CLOSE = 2,
  GIFT_PERMISSION_TYPE_HAS_GIFT_PERMISSION = 3,
  GIFT_PERMISSION_TYPE_ANCHOR_BANNED = 4,
  UNRECOGNIZED = -1,
}

export enum BattleABTestType {
  BATTLE_A_B_TEST_TYPE_UNKNOWN_AB_TEST_TYPE = 0,
  BATTLE_A_B_TEST_TYPE_MEANWHILE_INVITE = 1,
  BATTLE_A_B_TEST_TYPE_SPECIFIED_GIFT = 2,
  BATTLE_A_B_TEST_TYPE_RT_C_MESSAGE_CHANNEL = 3,
  BATTLE_A_B_TEST_TYPE_CONNECTION_TIME_OUT = 4,
  BATTLE_A_B_TEST_TYPE_REMATCH_SKIP_TEAMMATE = 5,
  BATTLE_A_B_TEST_TYPE_OPT_INVITEE_4048 = 6,
  BATTLE_A_B_TEST_TYPE_BATTLE_AB_TEST_TYPE_TIME_CALIBRATE = 7,
  UNRECOGNIZED = -1,
}

export enum PlayScene {
  PLAY_SCENE_UNKNOWN = 0,
  PLAY_SCENE_COUNTDOWN_FOR_ALL = 1,
  PLAY_SCENE_COUNTDOWN_FOR_SINGLE = 2,
  PLAY_SCENE_LIVE_SHOW = 3,
  PLAY_SCENE_AIG_C = 4,
  PLAY_SCENE_KARAOKE = 5,
  PLAY_SCENE_DRAW_GUESS = 6,
  PLAY_SCENE_ENLARGE_GRID = 7,
  PLAY_SCENE_GIFT_PRIORITY_LINK = 8,
  PLAY_SCENE_GIFT_THRESHOLD_LINK = 9,
  PLAY_SCENE_NOTICE_BOARD = 10,
  PLAY_SCENE_PLAY_BOOK = 11,
  PLAY_SCENE_GUEST_SHOWDOWN = 12,
  UNRECOGNIZED = -1,
}

export enum LinkType {
  LINK_TYPE_TYPE_UNKNOWN = 0,
  LINK_TYPE_TYPE_VIDEO = 1,
  LINK_TYPE_TYPE_AUDIO = 2,
  LINK_TYPE_TYPE_VIRTUAL = 3,
  UNRECOGNIZED = -1,
}

export enum LinkSilenceStatus {
  LINK_SILENCE_STATUS_STATUS_UN_SILENCE = 0,
  LINK_SILENCE_STATUS_STATUS_SILENCE_BY_SELF = 1,
  LINK_SILENCE_STATUS_STATUS_SILENCE_BY_OWNER = 2,
  UNRECOGNIZED = -1,
}

export enum LinkmicRoleType {
  LINKMIC_ROLE_TYPE_ROLE_TYPE_UNKOWN = 0,
  LINKMIC_ROLE_TYPE_LEADER = 1,
  LINKMIC_ROLE_TYPE_PLAYER = 2,
  LINKMIC_ROLE_TYPE_INVITEE = 3,
  UNRECOGNIZED = -1,
}

export enum LinkRoleType {
  LINK_ROLE_TYPE_TYPE_ROLE_TYPE_UNKOWN = 0,
  LINK_ROLE_TYPE_TYPE_LEADER = 1,
  LINK_ROLE_TYPE_TYPE_PLAYER = 2,
  LINK_ROLE_TYPE_TYPE_INVITEE = 3,
  LINK_ROLE_TYPE_TYPE_APPLIER = 4,
  UNRECOGNIZED = -1,
}

export enum MuteStatus {
  MUTE_STATUS_MUTE = 0,
  MUTE_STATUS_UN_MUTE = 1,
  UNRECOGNIZED = -1,
}

export enum GuestMicCameraManageOp {
  GUEST_MIC_CAMERA_MANAGE_OP_OPEN_MIC = 0,
  GUEST_MIC_CAMERA_MANAGE_OP_OPEN_CAMERA = 1,
  GUEST_MIC_CAMERA_MANAGE_OP_CLOSE_MIC = 2,
  GUEST_MIC_CAMERA_MANAGE_OP_CLOSE_CAMERA = 3,
  GUEST_MIC_CAMERA_MANAGE_OP_CLOSE_MIC_PUNISH = 4,
  UNRECOGNIZED = -1,
}

export enum GuestMicCameraChangeScene {
  GUEST_MIC_CAMERA_CHANGE_SCENE_CHANGE_SCENE_UNKNOWN = 0,
  GUEST_MIC_CAMERA_CHANGE_SCENE_LIVE_SHOW_BY_ANCHOR_AUTO = 1,
  GUEST_MIC_CAMERA_CHANGE_SCENE_LIVE_SHOW_BY_SERVER_NORMAL = 2,
  GUEST_MIC_CAMERA_CHANGE_SCENE_LIVE_SHOW_BY_SHOW_END = 3,
  UNRECOGNIZED = -1,
}

export enum LinkMicUserAdminType {
  LINK_MIC_USER_ADMIN_TYPE_UNDEFINED_TYPE = 0,
  LINK_MIC_USER_ADMIN_TYPE_MANAGER_TYPE = 1,
  LINK_MIC_USER_ADMIN_TYPE_HOST_TYPE = 2,
  UNRECOGNIZED = -1,
}

export enum LinkmicMultiLiveEnum {
  LINKMIC_MULTI_LIVE_ENUM_DEFAULT = 0,
  LINKMIC_MULTI_LIVE_ENUM_ANCHOR_USE_NEW_LAYOUT = 1,
  UNRECOGNIZED = -1,
}

export enum PollEndType {
  POLL_END_TYPE_POLL_END_BY_TIME = 0,
  POLL_END_TYPE_POLL_END_BY_OWNER = 1,
  POLL_END_TYPE_POLL_END_BY_OTHER = 2,
  POLL_END_TYPE_POLL_END_BY_ADMIN = 3,
  UNRECOGNIZED = -1,
}

export enum CohostABTestType {
  COHOST_A_B_TEST_TYPE_COHOST_AB_TEST_TYPE_UNKNOWN = 0,
  COHOST_A_B_TEST_TYPE_COHOST_AB_TEST_TYPE_LINK_TIME_OUT_STRATEGY = 1,
  COHOST_A_B_TEST_TYPE_COHOST_AB_TEST_TYPE_COHOST_RESERVATION = 2,
  COHOST_A_B_TEST_TYPE_COHOST_AB_TEST_TYPE_QUICK_PAIR_NEW_ARCH_SWITCH = 3,
  COHOST_A_B_TEST_TYPE_COHOST_AB_TEST_TYPE_COHOST_INVITATION_TEXT = 4,
  UNRECOGNIZED = -1,
}

export enum OptPairStatus {
  OPT_PAIR_STATUS_UNKNOWN = 0,
  OPT_PAIR_STATUS_OFFLINE = 1,
  OPT_PAIR_STATUS_FINISHED = 2,
  UNRECOGNIZED = -1,
}

export enum ContentPositionType {
  CONTENT_POSITION_TYPE_UNKNOWN = 0,
  CONTENT_POSITION_TYPE_STREAM = 1,
  CONTENT_POSITION_TYPE_LIVE_STUDIO_STREAM_PORTRAIT = 2,
  CONTENT_POSITION_TYPE_LIVE_STUDIO_STREAM_LANDSCAPE = 3,
  UNRECOGNIZED = -1,
}

export enum MultiGuestOutsideRoomInviteSource {
  MULTI_GUEST_OUTSIDE_ROOM_INVITE_SOURCE_OUTSIDE_ROOM_INVITE_SOURCE_UNKNOWN = 0,
  MULTI_GUEST_OUTSIDE_ROOM_INVITE_SOURCE_OUTSIDE_ROOM_INVITE_SOURCE_PANEL = 1,
  MULTI_GUEST_OUTSIDE_ROOM_INVITE_SOURCE_OUTSIDE_ROOM_INVITE_SOURCE_CAPSULE = 2,
  MULTI_GUEST_OUTSIDE_ROOM_INVITE_SOURCE_OUTSIDE_ROOM_INVITE_SOURCE_EMPTY_POSITION = 3,
  UNRECOGNIZED = -1,
}

export enum LinkUserType {
  LINK_USER_TYPE_DEFAULT = 0,
  LINK_USER_TYPE_KARAOKE = 1,
  UNRECOGNIZED = -1,
}

export enum ContentInviteSource {
  CONTENT_INVITE_SOURCE_INVITE_SOURCE_UNKNOWN = 0,
  CONTENT_INVITE_SOURCE_INVITE_SOURCE_PANEL_GO_LIVE = 1,
  CONTENT_INVITE_SOURCE_INVITE_SOURCE_MUTUAL_NOTICE = 2,
  CONTENT_INVITE_SOURCE_INVITE_SOURCE_USER_PROFILE = 3,
  CONTENT_INVITE_SOURCE_INVITE_SOURCE_RESERVE = 4,
  UNRECOGNIZED = -1,
}

export enum LinkmicShareRevenueSetting {
  LINKMIC_SHARE_REVENUE_SETTING_LINK_MIC_SHARE_REVENUE_NOT_SET = 0,
  LINKMIC_SHARE_REVENUE_SETTING_LINK_MIC_SHARE_REVENUE_OPEN = 1,
  LINKMIC_SHARE_REVENUE_SETTING_LINK_MIC_SHARE_REVENUE_CLOSE = 2,
  UNRECOGNIZED = -1,
}

export enum PosIdentityType {
  POS_IDENTITY_TYPE_IDENTITY_EMPTY_SLOT = 0,
  POS_IDENTITY_TYPE_IDENTITY_RT_C_USER_ID = 1,
  POS_IDENTITY_TYPE_IDENTITY_RT_C_STREAM_ID = 2,
  POS_IDENTITY_TYPE_IDENTITY_LIVE_USER_ID = 3,
  UNRECOGNIZED = -1,
}

export enum JoinType {
  JOIN_TYPE_UNKNOWN = 0,
  JOIN_TYPE_CHANNEL_APPLY = 1,
  JOIN_TYPE_CHANNEL_INVITE = 2,
  JOIN_TYPE_GROUP_APPLY = 100,
  JOIN_TYPE_GROUP_APPLY_FOLLOW = 101,
  JOIN_TYPE_GROUP_INVITE = 102,
  JOIN_TYPE_GROUP_INVITE_FOLLOW = 103,
  JOIN_TYPE_GROUP_OWNER_JOIN = 104,
  UNRECOGNIZED = -1,
}

export enum CohostLayoutMode {
  COHOST_LAYOUT_MODE_NORMAL = 0,
  COHOST_LAYOUT_MODE_SCREEN_SHARE = 1,
  UNRECOGNIZED = -1,
}

export enum TagClassification {
  TAG_CLASSIFICATION_UNKNOWN = 0,
  TAG_CLASSIFICATION_COHOST_HISTORY = 1,
  TAG_CLASSIFICATION_FIRST_DEGREE_RELATION = 2,
  TAG_CLASSIFICATION_SECOND_DEGREE_RELATION = 3,
  TAG_CLASSIFICATION_RANK = 4,
  TAG_CLASSIFICATION_SIMILAR_INTERESTS = 5,
  UNRECOGNIZED = -1,
}

export enum SourceType {
  SOURCE_TYPE_UNKNOWN = 0,
  SOURCE_TYPE_FRIEND_LIST = 1,
  SOURCE_TYPE_RECOMMEND_LIST = 2,
  SOURCE_TYPE_RECENT = 3,
  SOURCE_TYPE_OTHER_FOLLOW = 4,
  SOURCE_TYPE_QUICK_PAIR = 5,
  SOURCE_TYPE_ACTIVITY = 6,
  SOURCE_TYPE_QUICK_RECOMMEND = 7,
  SOURCE_TYPE_OFFICIAL_CHANNEL = 8,
  SOURCE_TYPE_BEST_TEAMMATE = 9,
  SOURCE_TYPE_RESERVATION = 10,
  SOURCE_TYPE_PAIRING = 11,
  SOURCE_TYPE_PAIRING_ON_RESERVATION = 12,
  SOURCE_TYPE_TOPIC_QUICK_PAIR = 13,
  SOURCE_TYPE_TOPIC_QUICK_RECOMMEND = 14,
  SOURCE_TYPE_ONLINE_FRIEND_CAPSULE = 15,
  SOURCE_TYPE_WEEKLY_RANK = 20,
  SOURCE_TYPE_HOURLY_RANK = 21,
  SOURCE_TYPE_WEEKLY_RISING = 23,
  SOURCE_TYPE_WEEKLY_ROOKIE = 24,
  SOURCE_TYPE_CONNECTION_LIST = 25,
  SOURCE_TYPE_DAILY_RANK = 26,
  SOURCE_TYPE_DAILY_RANK_HALL_OF_FAME = 27,
  SOURCE_TYPE_RESERVATION_BUBBLE = 28,
  SOURCE_TYPE_PAIRING_BUBBLE = 29,
  SOURCE_TYPE_LEAGUE_PHASE_ONE = 30,
  SOURCE_TYPE_LEAGUE_PHASE_TWO = 31,
  SOURCE_TYPE_LEAGUE_PHASE_THREE = 32,
  SOURCE_TYPE_DAILY_ROOKIE = 33,
  SOURCE_TYPE_MAY_KNOW_LIST = 34,
  SOURCE_TYPE_BANNER = 35,
  SOURCE_TYPE_FANS_TEAM_RANK = 36,
  SOURCE_TYPE_SEARCH = 37,
  SOURCE_TYPE_E_OY_RANK_LIST = 38,
  SOURCE_TYPE_LEAGUE_CAMPAIGN_RANK = 39,
  SOURCE_TYPE_CREATOR_CLASS_RANK = 40,
  SOURCE_TYPE_HISTORY = 41,
  SOURCE_TYPE_QUICK_RECOMMEND_DURING_COHOST = 43,
  UNRECOGNIZED = -1,
}

export enum BattleType {
  BATTLE_TYPE_UNKNOWN_BATTLE_TYPE = 0,
  BATTLE_TYPE_NORMAL_BATTLE = 1,
  BATTLE_TYPE_TEAM_BATTLE = 2,
  BATTLE_TYPE_INDIVIDUAL_BATTLE = 3,
  BATTLE_TYPE_1_V_N = 4,
  BATTLE_TYPE_TAKE_THE_STAGE = 51,
  BATTLE_TYPE_GROUP_SHOW = 52,
  UNRECOGNIZED = -1,
}

export enum BattleInviteType {
  BATTLE_INVITE_TYPE_NORMAL = 0,
  BATTLE_INVITE_TYPE_AGAIN = 1,
  UNRECOGNIZED = -1,
}

/** @Common */
export interface CommonMessageData {
  method: string;
  msgId: string;
  roomId: string;
  createTime: string;
  monitor: number;
  isShowMsg: boolean;
  describe: string;
  displayText: Text | undefined;
  foldType: string;
  anchorFoldType: string;
  priorityScore: string;
  logId: string;
  msgProcessFilterK: string;
  msgProcessFilterV: string;
  fromIdc: string;
  toIdc: string;
  filterMsgTagsList: string[];
  sei: CommonMessageData_LiveMessageSEI | undefined;
  dependRootId: CommonMessageData_LiveMessageID | undefined;
  dependId: CommonMessageData_LiveMessageID | undefined;
  anchorPriorityScore: string;
  roomMessageHeatLevel: string;
  foldTypeForWeb: string;
  anchorFoldTypeForWeb: string;
  clientSendTime: string;
  /** Enum */
  dispatchStrategy: CommonMessageData_IMDispatchStrategy;
}

export enum CommonMessageData_IMDispatchStrategy {
  IM_DISPATCH_STRATEGY_DEFAULT = 0,
  IM_DISPATCH_STRATEGY_BYPASS_DISPATCH_QUEUE = 1,
  UNRECOGNIZED = -1,
}

export interface CommonMessageData_LiveMessageSEI {
  uniqueId: CommonMessageData_LiveMessageID | undefined;
  timestamp: string;
}

export interface CommonMessageData_LiveMessageID {
  primaryId: string;
  messageScene: string;
}

/** @Text */
export interface Text {
  displayType: string;
  defaultPattern: string;
  defaultFormat: Text_TextFormat | undefined;
  piecesList: Text_TextPiece[];
}

export enum Text_ShowType {
  SHOW_TYPE_NORMAL = 0,
  SHOW_TYPE_FADE_IN_OUT = 1,
  UNRECOGNIZED = -1,
}

export interface Text_TextPiece {
  type: number;
  format: Text_TextFormat | undefined;
  stringValue: string;
  userValue?: Text_TextPieceUser | undefined;
  giftValue?: Text_TextPieceGift | undefined;
  patternRefValue: Text_TextPiecePatternRef | undefined;
}

export interface Text_TextFormat {
  color: string;
  bold: boolean;
  italic: boolean;
  weight: number;
  italicAngle: number;
  fontSize: number;
  useHeighLightColor: boolean;
  useRemoteClor: boolean;
}

export interface Text_TextPieceGift {
  giftId: number;
  nameRef:
    | Text_PatternRef
    | undefined;
  /** Enum */
  showType: Text_ShowType;
  colorId: string;
}

export interface Text_TextPiecePatternRef {
  key: string;
  defaultPattern: string;
}

export interface Text_TextPieceUser {
  user: User | undefined;
  withColon: boolean;
}

export interface Text_PatternRef {
  key: string;
  defaultPattern: string;
}

/** @Image */
export interface Image {
  url: string[];
  mUri: string;
  height: number;
  width: number;
  avgColor: string;
  imageType: number;
  schema: string;
  content: Image_Content | undefined;
  isAnimated: boolean;
}

export interface Image_Content {
  name: string;
  fontColor: string;
  level: string;
}

/** @Badge */
export interface BadgeStruct {
  /** Enum */
  badgeDisplayType: BadgeStruct_BadgeDisplayType;
  badgePriorityType: BadgeStruct_BadgePriorityType;
  badgeScene: BadgeStruct_BadgeSceneType;
  position: BadgeStruct_Position;
  displayStatus: BadgeStruct_DisplayStatus;
  greyedByClient: string;
  exhibitionType: BadgeStruct_BadgeExhibitionType;
  schemaUrl: string;
  display: boolean;
  logExtra: PrivilegeLogExtra | undefined;
  image?: BadgeStruct_ImageBadge | undefined;
  text?: BadgeStruct_TextBadge | undefined;
  str?: BadgeStruct_StringBadge | undefined;
  combine?: BadgeStruct_CombineBadge | undefined;
  isCustomized: boolean;
}

export enum BadgeStruct_BadgeDisplayType {
  BADGEDISPLAYTYPE_UNKNOWN = 0,
  BADGEDISPLAYTYPE_IMAGE = 1,
  BADGEDISPLAYTYPE_TEXT = 2,
  BADGEDISPLAYTYPE_STRING = 3,
  BADGEDISPLAYTYPE_COMBINE = 4,
  UNRECOGNIZED = -1,
}

export enum BadgeStruct_BadgePriorityType {
  BADGE_PRIORITY_TYPE_UNKNOWN = 0,
  BADGE_PRIORITY_TYPE_STRONG_RELATION = 10,
  BADGE_PRIORITY_TYPE_PLATFORM = 20,
  BADGE_PRIORITY_TYPE_RELATION = 30,
  BADGE_PRIORITY_TYPE_ACTIVITY = 40,
  BADGE_PRIORITY_TYPE_RANK_LIST = 50,
  UNRECOGNIZED = -1,
}

export enum BadgeStruct_BadgeSceneType {
  BADGE_SCENE_TYPE_UNKNOWN = 0,
  BADGE_SCENE_TYPE_ADMIN = 1,
  BADGE_SCENE_TYPE_FIRST_RECHARGE = 2,
  BADGE_SCENE_TYPE_FRIENDS = 3,
  BADGE_SCENE_TYPE_SUBSCRIBER = 4,
  BADGE_SCENE_TYPE_ACTIVITY = 5,
  BADGE_SCENE_TYPE_RANK_LIST = 6,
  BADGE_SCENE_TYPE_NEW_SUBSCRIBER = 7,
  BADGE_SCENE_TYPE_USER_GRADE = 8,
  BADGE_SCENE_TYPE_STATE_CONTROLLED_MEDIA = 9,
  BADGE_SCENE_TYPE_FANS = 10,
  BADGE_SCENE_TYPE_LIVE_PRO = 11,
  BADGE_SCENE_TYPE_ANCHOR = 12,
  UNRECOGNIZED = -1,
}

export enum BadgeStruct_DisplayStatus {
  DISPLAY_STATUS_NORMAL = 0,
  DISPLAY_STATUS_SHADOW = 1,
  UNRECOGNIZED = -1,
}

export enum BadgeStruct_BadgeExhibitionType {
  BADGE_EXHIBITION_TYPE_BADGE = 0,
  BADGE_EXHIBITION_TYPE_IDENTITY_LABEL = 1,
  UNRECOGNIZED = -1,
}

export enum BadgeStruct_Position {
  POSITIONUNKNOWN = 0,
  POSITIONLEFT = 1,
  POSITIONRIGHT = 2,
  UNRECOGNIZED = -1,
}

export enum BadgeStruct_HorizontalPaddingRule {
  HORIZONTAL_PADDING_RULE_USE_MIDDLE_AND_WIDTH = 0,
  HORIZONTAL_PADDING_RULE_USE_LEFT_AND_MIDDLE_AND_RIGHT = 1,
  UNRECOGNIZED = -1,
}

export enum BadgeStruct_VerticalPaddingRule {
  VERTICAL_PADDING_RULE_USE_DEFAULT = 0,
  VERTICAL_PADDING_RULE_USE_TOP_AND_BOTTOM = 1,
  UNRECOGNIZED = -1,
}

export interface BadgeStruct_CombineBadge {
  badgeDisplayType: number;
  icon: Image | undefined;
  text: BadgeStruct_TextBadge | undefined;
  str: string;
  padding: BadgeStruct_PaddingInfo | undefined;
  fontStyle: FontStyle | undefined;
  profileCardPanel: BadgeStruct_ProfileCardPanel | undefined;
  background: BadgeStruct_CombineBadgeBackground | undefined;
  backgroundDarkMode: BadgeStruct_CombineBadgeBackground | undefined;
  iconAutoMirrored: boolean;
  bgAutoMirrored: boolean;
  publicScreenShowStyle: number;
  personalCardShowStyle: number;
  rankListOnlineAudienceShowStyle: number;
  multiGuestShowStyle: number;
  arrowConfig: BadgeStruct_ArrowConfig | undefined;
  paddingNewFont: BadgeStruct_PaddingInfo | undefined;
}

export interface BadgeStruct_ArrowConfig {
  icon: Image | undefined;
}

export interface BadgeStruct_ProfileContent {
  useContent: boolean;
  iconList: BadgeStruct_IconConfig[];
  numberConfig: BadgeStruct_NumberConfig | undefined;
}

export interface BadgeStruct_ProjectionConfig {
  useProjection: boolean;
  icon: Image | undefined;
}

export interface BadgeStruct_NumberConfig {
  number: string;
  fontStyle: FontStyle | undefined;
  background: BadgeStruct_CombineBadgeBackground | undefined;
}

export interface BadgeStruct_ProfileCardPanel {
  useNewProfileCardStyle: boolean;
  /** BadgeTextPosition badgeTextPosition = 2; // Enum */
  projectionConfig: BadgeStruct_ProjectionConfig | undefined;
  profileContent: BadgeStruct_ProfileContent | undefined;
}

export interface BadgeStruct_CombineBadgeBackground {
  image: Image | undefined;
  backgroundColorCode: string;
  borderColorCode: string;
}

export interface BadgeStruct_ImageBadge {
  badgeDisplayType: BadgeStruct_BadgeDisplayType;
  image: Image | undefined;
}

export interface BadgeStruct_TextBadge {
  badgeDisplayType: BadgeStruct_BadgeDisplayType;
  key: string;
  defaultPattern: string;
  pieces: string[];
}

export interface BadgeStruct_IconConfig {
  icon: Image | undefined;
  background: BadgeStruct_CombineBadgeBackground | undefined;
}

export interface BadgeStruct_StringBadge {
  badgeDisplayType: BadgeStruct_BadgeDisplayType;
  str: string;
}

export interface BadgeStruct_PaddingInfo {
  useSpecific: boolean;
  middlePadding: number;
  badgeWidth: number;
  leftPadding: number;
  rightPadding: number;
  iconTopPadding: number;
  iconBottomPadding: number;
  horizontalPaddingRule: BadgeStruct_HorizontalPaddingRule;
  verticalPaddingRule: BadgeStruct_VerticalPaddingRule;
}

/** @Gift */
export interface Gift {
  giftImage: Image | undefined;
  describe: string;
  duration: number;
  id: string;
  forLinkMic: boolean;
  combo: boolean;
  giftType: number;
  diamondCount: number;
  isDisplayedOnPanel: boolean;
  primaryEffectId: string;
  giftLabelIcon: Image | undefined;
  giftName: string;
  icon: Image | undefined;
  goldEffect: string;
  previewImage: Image | undefined;
  giftPanelBanner: Gift_GiftPanelBanner | undefined;
  isBroadcastGift: boolean;
  isEffectBefview: boolean;
  isRandomGift: boolean;
  isBoxGift: boolean;
  canPutInGiftBox: boolean;
  giftBoxInfo: Gift_GiftBoxInfo | undefined;
}

export interface Gift_GiftPanelBanner {
  displayText: Text | undefined;
  leftIcon: Image | undefined;
  schemaUrl: string;
  bgColors: string[];
  bannerLynxUrl: string;
  bannerPriority: number;
  bannerLynxExtra: string;
  bgImage: Image | undefined;
}

export interface Gift_BatchGiftInfo {
  canBatchSend: boolean;
  availableCounts: string[];
}

export interface Gift_CrossScreenEffectInfo {
  singleActionEffectIds: { [key: string]: number };
  actionEffectIds: { [key: string]: number };
  reactionEffectIds: { [key: string]: number };
}

export interface Gift_CrossScreenEffectInfo_SingleActionEffectIdsEntry {
  key: string;
  value: number;
}

export interface Gift_CrossScreenEffectInfo_ActionEffectIdsEntry {
  key: string;
  value: number;
}

export interface Gift_CrossScreenEffectInfo_ReactionEffectIdsEntry {
  key: string;
  value: number;
}

export interface Gift_GiftSponsorInfo {
  sponsorId: string;
  sponsorCount: string;
  currentCount: string;
  leftCountToSponsor: string;
  canSponsor: boolean;
}

export interface Gift_UGGiftStructInfo {
  isUgGift: boolean;
  ugPointsCost: string;
}

export interface Gift_GiftSkin {
  giftSkinId: string;
  giftSkinName: string;
  staticImage: Image | undefined;
  animatedImage: Image | undefined;
}

export interface Gift_GiftText {
  giftTextId: string;
  giftTextName: string;
}

export interface Gift_GiftSkinToGiftTextsInfo {
  giftSkinId: string;
  giftTextIds: string[];
}

export interface Gift_GiftBoxInfo {
  capacity: string;
  isPrimaryBox: boolean;
  schemeUrl: string;
}

/** @User */
export interface User {
  userId: string;
  nickname: string;
  bioDescription: string;
  profilePicture: Image | undefined;
  profilePictureMedium: Image | undefined;
  profilePictureLarge: Image | undefined;
  verified: boolean;
  status: number;
  createTime: string;
  modifyTime: string;
  secret: number;
  shareQrcodeUri: string;
  badgeImageList: Image[];
  followInfo: User_FollowInfo | undefined;
  userHonor: UserHonor | undefined;
  fansClub: FansClubMember | undefined;
  border: BorderInfo | undefined;
  specialId: string;
  avatarBorder: Image | undefined;
  medal: Image | undefined;
  userBadges: Image[];
  newUserBadges: Image[];
  topVipNo: number;
  userAttr: User_UserAttr | undefined;
  ownRoom: User_OwnRoom | undefined;
  payScore: string;
  fanTicketCount: string;
  anchorInfo: User_AnchorLevel | undefined;
  linkMicStats: LinkmicStatus;
  uniqueId: string;
  enableShowCommerceSale: boolean;
  withFusionShopEntry: boolean;
  payScores: string;
  anchorLevel: User_AnchorLevel | undefined;
  verifiedContent: string;
  authorInfo: Author | undefined;
  topFans: User[];
  secUid: string;
  userRole: number;
  rewardInfo: User_ActivityInfo | undefined;
  personalCard: Image | undefined;
  authenticationInfo: User_AuthenticationInfo | undefined;
  mediaBadgeImageList: Image[];
  commerceWebcastConfigIds: string[];
  borders: BorderInfo[];
  comboBadgeInfo: User_ComboBadgeInfo | undefined;
  subscribeInfo: User_SubscribeInfo | undefined;
  badges: BadgeStruct[];
  mintTypeLabel: string[];
  fansClubInfo: User_FansClubInfo | undefined;
  allowFindByContacts: boolean;
  allowOthersDownloadVideo: boolean;
  allowOthersDownloadWhenSharingVideo: boolean;
  allowShareShowProfile: boolean;
  allowShowInGossip: boolean;
  allowShowMyAction: boolean;
  allowStrangeComment: boolean;
  allowUnfollowerComment: boolean;
  allowUseLinkmic: boolean;
  avatarJpg: Image | undefined;
  backgroundImgUrl: string;
  blockStatus: number;
  commentRestrict: number;
  constellation: string;
  disableIchat: number;
  enableIchatImg: string;
  exp: number;
  foldStrangerChat: boolean;
  followStatus: string;
  ichatRestrictType: number;
  idStr: string;
  isFollower: boolean;
  isFollowing: boolean;
  needProfileGuide: boolean;
  pushCommentStatus: boolean;
  pushDigg: boolean;
  pushFollow: boolean;
  pushFriendAction: boolean;
  pushIchat: boolean;
  pushStatus: boolean;
  pushVideoPost: boolean;
  pushVideoRecommend: boolean;
  verifiedReason: string;
  enableCarManagementPermission: boolean;
  upcomingEventList: User_LiveEventInfo[];
  scmLabel: string;
  ecommerceEntrance: User_EcommerceEntrance | undefined;
  isBlock: boolean;
  isSubscribe: boolean;
  isAnchorMarked: boolean;
}

export interface User_LiveEventInfo {
  eventId: string;
  startTime: string;
  duration: string;
  title: string;
  description: string;
  hasSubscribed: boolean;
  isPaidEvent: boolean;
  ticketAmount: string;
  /** @warning Enum not found, should be PayMethod */
  payMethod: string;
}

/**
 * @EventPayMethod
 * webcast.data.LiveEventInfo
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export enum User_LiveEventInfo_EventPayMethod {
  EVENTPAYMETHODINVALID = 0,
  EVENTPAYMETHODCOINS = 1,
  EVENTPAYMETHODCASH = 2,
  UNRECOGNIZED = -1,
}

/**
 * @WalletPackage
 * proto.webcast.data.LiveEventInfo
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface User_LiveEventInfo_WalletPackage {
  iapId: string;
  usdPriceShow: string;
}

/**
 * @ActivityInfo
 * proto.webcast.data.User
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface User_ActivityInfo {
  badge: Image | undefined;
  storytag: Image | undefined;
}

/**
 * @AnchorLevel
 * proto.webcast.data.User
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface User_AnchorLevel {
  level: string;
  experience: string;
  lowestExperienceThisLevel: string;
  highestExperienceThisLevel: string;
  taskStartExperience: string;
  taskStartTime: string;
  taskDecreaseExperience: string;
  taskTargetExperience: string;
  taskEndTime: string;
  profileDialogBg: Image | undefined;
  profileDialogBgBack: Image | undefined;
  stageLevel: Image | undefined;
  smallIcon: Image | undefined;
}

/**
 * @AuthenticationInfo
 * proto.webcast.data.User
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface User_AuthenticationInfo {
  customVerify: string;
  enterpriseVerifyReason: string;
  authenticationBadge: Image | undefined;
}

/**
 * @AuthorStats
 * proto.webcast.data.User
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface User_AuthorStats {
  videoTotalCount: string;
  videoTotalPlayCount: string;
  videoTotalShareCount: string;
  videoTotalSeriesCount: string;
  varietyShowPlayCount: string;
  videoTotalFavoriteCount: string;
}

/**
 * @Border
 * proto.webcast.data.User
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface User_Border {
  icon: Image | undefined;
  level: string;
  source: string;
  profileDecorationRibbon: Image | undefined;
  avatarBackgroundColor: string;
  avatarBackgroundBorderColor: string;
}

/**
 * @ComboBadgeInfo
 * proto.webcast.data.User
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface User_ComboBadgeInfo {
  icon: Image | undefined;
  comboCount: string;
}

/**
 * @EcommerceEntrance
 * proto.webcast.data.User
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface User_EcommerceEntrance {
  /** Enum */
  entranceType: User_EcommerceEntrance_EntranceType;
  /** Enum */
  creatorType: User_EcommerceEntrance_CreatorType;
  schema: string;
  shopEntranceInfo: User_EcommerceEntrance_ShopEntranceInfo | undefined;
  showcaseEntranceInfo: User_EcommerceEntrance_ShowcaseEntranceInfo | undefined;
}

/**
 * @CreatorType
 * webcast.data.User.EcommerceEntrance
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export enum User_EcommerceEntrance_CreatorType {
  UNDEFINED = 0,
  OFFICIAL = 1,
  MARKET = 2,
  NORMAL = 3,
  UNRECOGNIZED = -1,
}

/**
 * @EntranceType
 * webcast.data.User.EcommerceEntrance
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export enum User_EcommerceEntrance_EntranceType {
  PROFILE = 0,
  SHOWCASE = 1,
  SHOP = 2,
  UNRECOGNIZED = -1,
}

/**
 * @ShopEntranceInfo
 * proto.webcast.data.User.EcommerceEntrance
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface User_EcommerceEntrance_ShopEntranceInfo {
  shopId: string;
  shopName: string;
  shopRating: string;
  storeLabel: User_EcommerceEntrance_ShopEntranceInfo_StoreLabel | undefined;
  formatSoldCount: string;
  soldCount: string;
  expRatePercentile: number;
  expRateTopDisplay: string;
  rateDisplayStyle: number;
  showRateNotApplicable: boolean;
}

/**
 * @StoreLabel
 * proto.webcast.data.User.EcommerceEntrance.ShopEntranceInfo
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface User_EcommerceEntrance_ShopEntranceInfo_StoreLabel {
  officialLabel: User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel | undefined;
  isBytemall: boolean;
}

/**
 * @StoreBrandLabelType
 * webcast.data.User.EcommerceEntrance.ShopEntranceInfo.StoreLabel
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export enum User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreBrandLabelType {
  NONE = 0,
  OFFICIAL = 1,
  AUTHORIZED = 2,
  STORE_BRAND_LABEL_TYPE_BLUE_V = 3,
  STORE_BRAND_LABEL_TYPE_TOP_CHOICE = 4,
  UNRECOGNIZED = -1,
}

/**
 * @StoreOfficialLabel
 * proto.webcast.data.User.EcommerceEntrance.ShopEntranceInfo.StoreLabel
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel {
  labelImageLight: User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel_ShopLabelImage | undefined;
  labelImageDark:
    | User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel_ShopLabelImage
    | undefined;
  /** @warning Enum not found, should be LabelType */
  labelType: string;
  labelTypeStr: string;
}

/**
 * @ShopLabelImage
 * proto.webcast.data.User.EcommerceEntrance.ShopEntranceInfo.StoreLabel.StoreOfficialLabel
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel_ShopLabelImage {
  height: number;
  width: number;
  minetype: string;
  thumbUri: string;
  thumbUriList: string[];
  uri: string;
  urlList: string[];
  color: string;
}

/**
 * @ShowcaseEntranceInfo
 * proto.webcast.data.User.EcommerceEntrance
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface User_EcommerceEntrance_ShowcaseEntranceInfo {
  formatSoldCount: string;
  soldCount: string;
}

/**
 * @FansClub
 * proto.webcast.data.User
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface User_FansClub {
  data: User_FansClub_FansClubData | undefined;
}

/**
 * @PreferntialType
 * webcast.data.User.FansClub
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export enum User_FansClub_PreferntialType {
  PRESONALPROFILE = 0,
  OTHERROOM = 1,
  UNRECOGNIZED = -1,
}

/**
 * @FansClubData
 * proto.webcast.data.User.FansClub
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface User_FansClub_FansClubData {
  clubName: string;
  level: number;
  /** Enum */
  userFansClubStatus: User_FansClub_FansClubData_UserFansClubStatus;
  availableGiftIdsList: string[];
  anchorId: string;
}

/**
 * @BadgeIcon
 * webcast.data.User.FansClub.FansClubData
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export enum User_FansClub_FansClubData_BadgeIcon {
  UNKNOWN = 0,
  ICON = 1,
  SMALLICON = 2,
  UNRECOGNIZED = -1,
}

/**
 * @UserFansClubStatus
 * webcast.data.User.FansClub.FansClubData
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export enum User_FansClub_FansClubData_UserFansClubStatus {
  NOTJOINED = 0,
  ACTIVE = 1,
  INACTIVE = 2,
  UNRECOGNIZED = -1,
}

/**
 * @FansClubInfo
 * proto.webcast.data.User
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface User_FansClubInfo {
  isSleeping: boolean;
  fansLevel: string;
  fansScore: string;
  badge: Image | undefined;
  fansCount: string;
  fansClubName: string;
}

/**
 * @FollowInfo
 * proto.webcast.data.User
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface User_FollowInfo {
  followingCount: string;
  followerCount: string;
  followStatus: string;
  pushStatus: string;
}

/**
 * @OwnRoom
 * proto.webcast.data.User
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface User_OwnRoom {
  roomIdsList: string[];
  roomIdsStrList: string[];
}

/**
 * @PayGrade
 * proto.webcast.data.User
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface User_PayGrade {
  diamondIcon: Image | undefined;
  name: string;
  icon: Image | undefined;
  nextName: string;
  level: string;
  nextIcon: Image | undefined;
  gradeDescribe: string;
  gradeIconList: GradeIcon[];
  screenChatType: string;
  imIcon: Image | undefined;
  imIconWithLevel: Image | undefined;
  liveIcon: Image | undefined;
  newImIconWithLevel: Image | undefined;
  newLiveIcon: Image | undefined;
  upgradeNeedConsume: string;
  nextPrivileges: string;
  background: Image | undefined;
  backgroundBack: Image | undefined;
  score: string;
  gradeBanner: string;
  profileDialogBg: Image | undefined;
  profileDialogBgBack: Image | undefined;
}

/**
 * @SubscribeBadge
 * proto.webcast.data.User
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface User_SubscribeBadge {
  originImg: Image | undefined;
  previewImg: Image | undefined;
}

/**
 * @SubscribeInfo
 * proto.webcast.data.User
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface User_SubscribeInfo {
  qualification: boolean;
  isSubscribe: boolean;
  badge: User_SubscribeBadge | undefined;
  enableSubscription: boolean;
  subscriberCount: string;
  isInGracePeriod: boolean;
  isSubscribedToAnchor: boolean;
  userGiftSubAuth: boolean;
  anchorGiftSubAuth: boolean;
}

/**
 * @UserAttr
 * proto.webcast.data.User
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface User_UserAttr {
  isMuted: boolean;
  isAdmin: boolean;
  isSuperAdmin: boolean;
  muteDuration: string;
}

/**
 * @UserStats
 * proto.webcast.data.User
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface User_UserStats {
  id: string;
  idStr: string;
  followingCount: string;
  followerCount: string;
  recordCount: string;
  totalDuration: string;
  dailyFanTicketCount: string;
  dailyIncome: string;
  itemCount: string;
  favoriteItemCount: string;
  diamondConsumedCount: string;
  tuwenItemCount: string;
}

/** @Emote */
export interface Emote {
  emoteId: string;
  image:
    | Image
    | undefined;
  /** Enum */
  auditStatus: AuditStatus;
  uuid: string;
  /** Enum */
  emoteType: EmoteType;
  /** Enum */
  contentSource: ContentSource;
  /** Enum */
  emotePrivateType: EmotePrivateType;
  packageId: string;
  auditInfo: Emote_AuditInfo | undefined;
  rewardCondition: RewardCondition;
  emoteUploadInfo: Emote_EmoteUploadInfo | undefined;
  createTime: string;
  emoteScene: EmoteScene;
}

export interface Emote_AuditInfo {
  violationId: string;
  taskType: Emote_AuditInfo_AuditTaskType;
}

export enum Emote_AuditInfo_AuditTaskType {
  AUDIT_TASK_TYPE_DEFAULT = 0,
  AUDIT_TASK_TYPE_APPEAL = 1,
  UNRECOGNIZED = -1,
}

export interface Emote_EmoteUploadInfo {
  userId: string;
  emoteUploadSource: UserEmoteUploadSource;
  userInfo: User | undefined;
  userIdStr: string;
}

/** @PunishEventInfo */
export interface PunishEventInfo {
  punishType: string;
  punishReason: string;
  punishId: string;
  violationUid: string;
  /** Enum */
  punishTypeId: PunishTypeId;
  duration: string;
  punishPerceptionCode: string;
  violationUidStr: string;
  showReason: string;
}

/** @MsgFilter */
export interface MsgFilter {
  isGifter: boolean;
  isSubscribedToAnchor: boolean;
}

/**
 * @UserIdentity
 * proto.webcast.data
 */
export interface UserIdentity {
  isGiftGiverOfAnchor: boolean;
  isSubscriberOfAnchor: boolean;
  isMutualFollowingWithAnchor: boolean;
  isFollowerOfAnchor: boolean;
  isModeratorOfAnchor: boolean;
  isAnchor: boolean;
}

/**
 * @Goal
 * proto.webcast.data
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface LiveStreamGoal {
  id: string;
  type: number;
  status: number;
  subGoals: LiveStreamGoal_LiveStreamSubGoal[];
  description: string;
  auditStatus: AuditStatus;
  cycleType: number;
  startTime: string;
  expireTime: string;
  realFinishTime: string;
  contributors: LiveStreamGoal_LiveStreamGoalContributor[];
  contributorsLength: number;
  idStr: string;
  auditDescription: string;
  stats: LiveStreamGoal_GoalStats | undefined;
  goalExtraInfo: string;
  mode: number;
  auditInfo: LiveStreamGoal_AuditInfo | undefined;
  challengeType: string;
  isUneditable: boolean;
}

export interface LiveStreamGoal_AuditInfo {
  violationId: string;
  taskType: number;
}

export interface LiveStreamGoal_LiveStreamSubGoal {
  type: number;
  id: string;
  progress: string;
  target: string;
  gift: LiveStreamGoal_LiveStreamSubGoalGift | undefined;
  idStr: string;
  pinInfo: LiveStreamGoal_LiveStreamSubGoal_SubGoalPinInfo | undefined;
  source: number;
  recommendedText: string;
  recommendedHeader: string;
}

export interface LiveStreamGoal_LiveStreamSubGoal_SubGoalPinInfo {
  pinStartTime: string;
  pinEndTime: string;
  pinReadyTime: string;
}

export interface LiveStreamGoal_LiveStreamSubGoalGift {
  name: string;
  icon: Image | undefined;
  diamondCount: string;
  type: number;
}

export interface LiveStreamGoal_LiveStreamGoalContributor {
  userId: string;
  avatar: Image | undefined;
  displayId: string;
  score: string;
  userIdStr: string;
  inRoom: boolean;
  isFriend: boolean;
  followByOwner: boolean;
  isFistContribute: boolean;
  subGoalContributions: LiveStreamGoal_LiveStreamGoalContributor_SubGoalContribution[];
}

export interface LiveStreamGoal_LiveStreamGoalContributor_SubGoalContribution {
  id: string;
  contributionCount: string;
}

export interface LiveStreamGoal_GoalStats {
  totalCoins: string;
  totalContributor: string;
  comparison: LiveStreamGoal_GoalStats_GoalComparison | undefined;
  totalNewFans: string;
}

export interface LiveStreamGoal_GoalStats_GoalComparison {
  coinsIncr: string;
  contributorIncr: string;
}

/**
 * @Indicator
 * proto.webcast.data
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface LiveStreamGoalIndicator {
  key: string;
  op: number;
}

export interface Ranking {
  type: string;
  label: string;
  color: TikTokColor | undefined;
  details: ValueLabel[];
}

export interface TikTokColor {
  color: string;
  id: string;
  data1: number;
}

export interface ValueLabel {
  data: number;
  label: string;
  label2: string;
  label3: string;
}

export interface TimeStampContainer {
  timestamp1: string;
  timestamp2: string;
  timestamp3: string;
}

export interface PollStartContent {
  StartTime: string;
  EndTime: string;
  OptionList: PollOptionInfo[];
  Title: string;
  Operator: User | undefined;
}

export interface PollEndContent {
  EndType: PollEndType;
  OptionList: PollOptionInfo[];
  Operator: User | undefined;
}

export interface PollOptionInfo {
  Votes: number;
  DisplayContent: string;
  OptionIdx: number;
  VoteUserList: VoteUser[];
}

export interface VoteUser {
  UserId: string;
  NickName: string;
  AvatarThumb: Image | undefined;
}

export interface PollUpdateVotesContent {
  OptionList: PollOptionInfo[];
}

export interface UserFanTicket {
  UserId: string;
  FanTicket: string;
  MatchTotalScore: string;
  MatchRank: number;
}

export interface FanTicketRoomNoticeContent {
  UserFanTicketList: UserFanTicket[];
  TotalLinkMicFanTicket: string;
  MatchId: string;
  EventTime: string;
  FanTicketIconUrl: string;
  playId: string;
  playScene: PlayScene;
}

export interface LinkerAcceptNoticeContent {
  fromUserId: string;
  fromRoomId: string;
  toUserId: string;
}

export interface LinkerCancelContent {
  fromUserId: string;
  toUserId: string;
  cancelType: string;
  actionId: string;
}

export interface ListUser {
  user: User | undefined;
  linkmicId: string;
  linkmicIdStr: string;
  linkStatus: LinkmicRoleType;
  linkType: LinkType;
  userPosition: number;
  silenceStatus: LinkSilenceStatus;
  modifyTime: string;
  linkerId: string;
  roleType: LinkRoleType;
}

/** it is just empty */
export interface LinkerCloseContent {
}

export interface LinkerCreateContent {
  ownerId: string;
  ownerRoomId: string;
  /** Assuming this is LinkType enum */
  linkType: string;
}

export interface LinkerEnterContent {
  linkedUsersList: ListUser[];
  anchorMultiLiveEnum: LinkmicMultiLiveEnum;
  anchorSettingInfo: MultiLiveAnchorPanelSettings | undefined;
}

export interface LinkerInviteContent {
  fromUserId: string;
  fromRoomId: string;
  toRtcExtInfo: string;
  rtcJoinChannel: boolean;
  vendor: string;
  secFromUserId: string;
  toLinkmicIdStr: string;
  fromUser: User | undefined;
  requiredMicIdx: string;
  rtcExtInfoMap: { [key: string]: string };
  multiLiveLayoutEnable: LinkmicMultiLiveEnum;
  multiLiveSetting: MultiLiveAnchorPanelSettings | undefined;
  fromLinkmicIdStr: string;
  fromTopHostInfo: LinkerInviteContent_InviteTopHostInfo | undefined;
  actionId: string;
  linkedUsers: LinkerInviteContent_LinkmicUserInfo[];
  dialogInfo: LinkerInviteContent_PerceptionDialogInfo | undefined;
  punishEventInfo: PunishEventInfo | undefined;
  fromRoomAgeRestricted: number;
  abTestSetting: LinkerInviteContent_CohostABTestSetting[];
  linkerInviteMsgExtra: LinkerInviteContent_LinkerInviteMessageExtra | undefined;
}

export interface LinkerInviteContent_RtcExtInfoMapEntry {
  key: string;
  value: string;
}

export interface LinkerInviteContent_InviteTopHostInfo {
  rankType: string;
  topIndex: string;
}

export interface LinkerInviteContent_LinkmicUserInfo {
  userId: string;
  linkmicIdStr: string;
  roomId: string;
  linkedTime: string;
}

export interface LinkerInviteContent_PerceptionDialogInfo {
  iconType: PerceptionDialogIconType;
  title: Text | undefined;
  subTitle: Text | undefined;
  adviceActionText: Text | undefined;
  defaultActionText: Text | undefined;
  violationDetailUrl: string;
  scene: Scene;
  targetUserId: string;
  targetRoomId: string;
  countDownTime: string;
  showFeedback: boolean;
  feedbackOptions: LinkerInviteContent_PerceptionDialogInfo_PerceptionFeedbackOption[];
  policyTip: string;
  appealPopup: number;
}

export interface LinkerInviteContent_PerceptionDialogInfo_PerceptionFeedbackOption {
  id: string;
  contentKey: string;
}

export interface LinkerInviteContent_CohostABTestSetting {
  key: string;
  value: LinkerInviteContent_CohostABTestSetting_CohostABTestList | undefined;
}

export interface LinkerInviteContent_CohostABTestSetting_CohostABTestList {
  abTestList: LinkerInviteContent_CohostABTestSetting_CohostABTestList_CohostABTest[];
}

export interface LinkerInviteContent_CohostABTestSetting_CohostABTestList_CohostABTest {
  abTestType: CohostABTestType;
  group: string;
}

export interface LinkerInviteContent_LinkerInviteMessageExtra {
  matchType: number;
  inviteType: number;
  subType: number;
  theme: string;
  duration: number;
  layout: number;
  tips: string;
  inviterRivalExtra: LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra | undefined;
  otherRivalExtra: LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra[];
  topicInfo: CohostTopic | undefined;
  algoRequestId: string;
}

export interface LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra {
  textType: TextType;
  text: string;
  label: string;
  userCount: number;
  avatarThumb: Image | undefined;
  displayId: string;
  authenticationInfo: LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_AuthenticationInfo | undefined;
  nickname: string;
  followStatus: string;
  mHashtag: LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_Hashtag | undefined;
  userId: string;
  isBestTeammate: boolean;
  optPairInfo: LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo | undefined;
  followerCount: string;
}

export interface LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_AuthenticationInfo {
  customVerify: string;
  enterpriseVerifyReason: string;
  authenticationBadge: Image | undefined;
}

export interface LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_Hashtag {
  id: string;
  title: string;
  image: Image | undefined;
  namespace: HashtagNamespace;
}

export interface LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo {
  mappingId: string;
  displayUserList: LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo_OptPairUser[];
  buttonNoticeType: OptPairStatus;
  expectedTimeSec: string;
  optPairType: string;
}

export interface LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo_OptPairUser {
  user: User | undefined;
  roomId: string;
}

export interface CohostTopic {
  id: string;
  titleKey: string;
  titleText: string;
  liked: boolean;
  totalHeat: string;
  totalRivals: string;
  rivalsAvatar: Image[];
}

export interface LinkerKickOutContent {
  fromUserId: string;
  kickoutReason: KickoutReason;
}

export interface LinkerLeaveContent {
  userId: string;
  linkmicIdStr: string;
  sendLeaveUid: string;
  leaveReason: string;
}

/** Empty */
export interface LinkerLinkedListChangeContent {
}

/** Empty */
export interface CohostListChangeContent {
}

export interface LinkerListChangeContent {
  linkedUsers: ListUser[];
  appliedUsers: ListUser[];
  connectingUsers: ListUser[];
}

export interface LinkerMediaChangeContent {
  op: GuestMicCameraManageOp;
  toUserId: string;
  anchorId: string;
  roomId: string;
  changeScene: GuestMicCameraChangeScene;
  operatorInfo: LinkerMediaChangeContent_LinkerMediaChangeOperator | undefined;
}

export interface LinkerMediaChangeContent_LinkerMediaChangeOperator {
  userId: string;
  operatorType: LinkMicUserAdminType;
  nickName: string;
  displayId: string;
}

/** Empty */
export interface LinkerMicIdxUpdateContent {
}

export interface LinkerMuteContent {
  userId: string;
  status: MuteStatus;
}

export interface LinkerRandomMatchContent {
  user: User | undefined;
  roomId: string;
  inviteType: string;
  matchId: string;
  innerChannelId: string;
}

export interface LinkerReplyContent {
  fromUserId: string;
  fromRoomId: string;
  fromUserLinkmicInfo: LinkerReplyContent_LinkmicInfo | undefined;
  toUserId: string;
  toUserLinkmicInfo: LinkerReplyContent_LinkmicInfo | undefined;
  linkType: string;
  replyStatus: string;
  linkerSetting: LinkerSetting | undefined;
  fromUser: User | undefined;
  toUser: User | undefined;
}

export interface LinkerReplyContent_LinkmicInfo {
  accessKey: string;
  linkMicId: string;
  joinable: boolean;
  confluenceType: number;
  rtcExtInfo: string;
  rtcAppId: string;
  rtcAppSign: string;
  linkmicIdStr: string;
  vendor: string;
}

export interface LinkerSetting {
  MaxMemberLimit: string;
  LinkType: string;
  Scene: Scene;
  OwnerUserId: string;
  OwnerRoomId: string;
  Vendor: string;
}

export interface LinkerSysKickOutContent {
  userId: string;
  linkmicIdStr: string;
}

export interface LinkmicUserToastContent {
  userId: string;
  roomId: string;
  displayText: Text | undefined;
  leavedUserId: string;
}

export interface LinkerUpdateUserContent {
  fromUserId: string;
  toUserId: string;
  updateInfo: { [key: string]: string };
}

export interface LinkerUpdateUserContent_UpdateInfoEntry {
  key: string;
  value: string;
}

export interface LinkerUpdateUserSettingContent {
  multiLiveAnchorPanelSettings: MultiLiveAnchorPanelSettings | undefined;
}

/** Empty */
export interface LinkerWaitingListChangeContent {
}

export interface MultiLiveAnchorPanelSettings {
  userId: string;
  layout: string;
  fixMicNum: string;
  allowRequestFromUser: string;
  allowRequestFromFollowerOnly: string;
  applierSortSetting: LinkmicApplierSortSetting;
  applierSortGiftScoreThreshold: string;
  allowRequestFromFriends: number;
  allowRequestFromFollowers: number;
  allowRequestFromOthers: number;
  enableShowMultiGuestLayout: number;
}

export interface Player {
  roomId: string;
  userId: string;
}

export interface AllListUser {
  linkedList: LinkLayerListUser[];
  appliedList: LinkLayerListUser[];
  invitedList: LinkLayerListUser[];
  readyList: LinkLayerListUser[];
}

export interface LinkLayerListUser {
  user: User | undefined;
  linkmicId: string;
  pos: Position | undefined;
  linkedTimeNano: string;
  appVersion: string;
  magicNumber1: string;
}

export interface Position {
  type: number;
  link: LinkPosition | undefined;
}

export interface LinkPosition {
  position: number;
  opt: number;
}

export interface GroupPlayer {
  channelId: string;
  user: User | undefined;
}

export interface DSLConfig {
  sceneVersion: number;
  layoutId: string;
}

export interface GroupChannelAllUser {
  groupChannelId: string;
  userList: GroupChannelUser[];
  contentVersion: string;
}

export interface GroupChannelUser {
  channelId: string;
  status: GroupStatus;
  type: TextType;
  allUser: AllListUser | undefined;
  joinTime: string;
  linkedTime: string;
  ownerUser: GroupPlayer | undefined;
  groupLinkmicId: string;
}

export interface RTCExtraInfo {
  liveRtcEngineConfig: RTCExtraInfo_RTCEngineConfig | undefined;
  liveRtcVideoParamList: RTCExtraInfo_RTCLiveVideoParam[];
  rtcBitrateMap: RTCExtraInfo_RTCBitrateMap | undefined;
  rtcFps: number;
  rtcMixBase: RTCExtraInfo_RTCMixBase | undefined;
  byteRtcExtInfo: RTCExtraInfo_ByteRTCExtInfo | undefined;
  rtcInfoExtra: RTCExtraInfo_RTCInfoExtra | undefined;
  rtcBusinessId: string;
  rtcOther: RTCExtraInfo_RTCOther | undefined;
  interactClientType: number;
}

export interface RTCExtraInfo_RTCMixBase {
  bitrate: number;
}

export interface RTCExtraInfo_ByteRTCExtInfo {
  defaultSignaling: number;
}

export interface RTCExtraInfo_RTCInfoExtra {
  version: string;
}

export interface RTCExtraInfo_RTCOther {
  transCodingSecond: number;
}

export interface RTCExtraInfo_RTCEngineConfig {
  rtcAppId: string;
  rtcUserId: string;
  rtcToken: string;
  rtcChannelId: string;
}

export interface RTCExtraInfo_RTCLiveVideoParam {
  strategyId: number;
  params: RTCExtraInfo_RTCVideoParam | undefined;
}

export interface RTCExtraInfo_RTCVideoParam {
  width: number;
  height: number;
  fps: number;
  bitrateKbps: number;
}

export interface RTCExtraInfo_RTCBitrateMap {
  xx1: number;
  xx2: number;
  xx3: number;
  xx4: number;
}

export interface CreateChannelContent {
  owner: Player | undefined;
  ownerLinkMicId: string;
}

export interface ListChangeContent {
  listChangeType: number;
  userList: AllListUser | undefined;
  linkedUserUiPositions: string[];
  contentPos: ContentPosition[];
}

export interface ContentPosition {
  contentID: string;
  contentType: ContentPositionType;
  pos: MicPositionData | undefined;
  contentLinkmicID: string;
  startTimeNano: string;
}

export interface MicPositionData {
  type: number;
  linkPosition: LinkPosition | undefined;
}

export interface MultiLiveContent {
  applyBizContent: MultiLiveContent_ApplyBizContent | undefined;
  inviteBizContent: MultiLiveContent_InviteBizContent | undefined;
  replyBizContent: MultiLiveContent_ReplyBizContent | undefined;
  permitBizContent: MultiLiveContent_PermitBizContent | undefined;
  joinDirectBizContent: MultiLiveContent_JoinDirectBizContent | undefined;
  kickOutBizContent: MultiLiveContent_KickOutBizContent | undefined;
}

export interface MultiLiveContent_ApplyBizContent {
  user: User | undefined;
}

export interface MultiLiveContent_JoinDirectBizContent {
  replyImMsgId: string;
  outsideRoomInviteSource: MultiGuestOutsideRoomInviteSource;
}

export interface MultiLiveContent_InviteBizContent {
  anchorSettingInfo: MultiLiveAnchorPanelSettings | undefined;
  inviteSource: ContentInviteSource;
  operatorUserInfo: User | undefined;
  operatorLinkAdminType: LinkMicUserAdminType;
  inviteeUserInfo: User | undefined;
  shareRevenueSetting: LinkmicShareRevenueSetting;
}

export interface MultiLiveContent_ReplyBizContent {
  linkType: number;
  isTurnOffInvitation: number;
  replyUserInfo: User | undefined;
}

export interface MultiLiveContent_PermitBizContent {
  anchorSettingInfo: MultiLiveAnchorPanelSettings | undefined;
  expireTimestamp: string;
  operatorUserInfo: User | undefined;
  operatorLinkAdminType: LinkMicUserAdminType;
  linkUserType: LinkUserType;
}

export interface MultiLiveContent_KickOutBizContent {
  operatorUserInfo: User | undefined;
  operatorLinkAdminType: LinkMicUserAdminType;
  kickPlayerUserInfo: User | undefined;
}

export interface InviteContent {
  invitor: Player | undefined;
  inviteeRtcExtInfo: RTCExtraInfo | undefined;
  invitorLinkMicId: string;
  inviteeLinkMicId: string;
  isOwner: boolean;
  pos: Position | undefined;
  dsl: DSLConfig | undefined;
  invitee: User | undefined;
  operator: User | undefined;
}

/**
 * @ApplyContent
 * proto.webcast.im
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface ApplyContent {
  applier: Player | undefined;
  applierLinkMicId: string;
}

/**
 * @PermitApplyContent
 * proto.webcast.im
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface PermitApplyContent {
  permiter: Player | undefined;
  permiterLinkMicId: string;
  applierPos:
    | Position
    | undefined;
  /** Enum */
  replyStatus: ReplyStatus;
  dsl: DSLConfig | undefined;
  applier: User | undefined;
  operator: User | undefined;
  applierLinkMicId: string;
}

/**
 * @ReplyInviteContent
 * proto.webcast.im
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface ReplyInviteContent {
  invitee: Player | undefined;
  replyStatus: ReplyStatus;
  inviteeLinkMicId: string;
  inviteePos: Position | undefined;
  inviteOperatorUser: Player | undefined;
  linkedUserUiPositions: string[];
  uiPos: PosIdentity[];
}

/**
 * @KickOutContent
 * proto.webcast.im
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface KickOutContent {
  offliner: Player | undefined;
  kickoutReason: KickoutReason;
  linkedUserUiPositions: string[];
  uiPos: PosIdentity[];
}

export interface PosIdentity {
  type: PosIdentityType;
  value: string;
}

/**
 * @CancelApplyContent
 * proto.webcast.im
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface CancelApplyContent {
  applier: Player | undefined;
  applierLinkMicId: string;
}

/**
 * @CancelInviteContent
 * proto.webcast.im
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface CancelInviteContent {
  invitor: Player | undefined;
  invitorLinkMicId: string;
  inviteeLinkMicId: string;
  inviteSeqId: string;
  invitee: Player | undefined;
}

/**
 * @LeaveContent
 * proto.webcast.im
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface LeaveContent {
  leaver: Player | undefined;
  leaveReason: string;
  linkedUserUiPositions: string[];
  uiPos: PosIdentity[];
}

/**
 * @FinishChannelContent
 * proto.webcast.im
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface FinishChannelContent {
  owner: Player | undefined;
  finishReason: string;
}

/**
 * @JoinDirectContent
 * proto.webcast.im
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface JoinDirectContent {
  joiner: LinkLayerListUser | undefined;
  allUsers: AllListUser | undefined;
}

/**
 * @LeaveJoinGroupContent
 * proto.webcast.im
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface LeaveJoinGroupContent {
  operator: GroupPlayer | undefined;
  groupChannelId: string;
  leaveSource: string;
  linkedUserUiPositions: string[];
}

/**
 * @PermitJoinGroupContent
 * proto.webcast.im
 */
export interface PermitJoinGroupContent {
  approver: GroupPlayer | undefined;
  agreeStatus: AgreeStatus;
  type: JoinType;
  groupExtInfoList: RTCExtraInfo[];
  groupUser: GroupChannelAllUser | undefined;
  migrationDetails: MigrationDetails | undefined;
  linkedUserUiPositions: string[];
}

export interface MigrationDetails {
  isMigrate: boolean;
  sourceGroupChannelId: string;
  targetGroupChannelId: string;
}

/**
 * @CancelJoinGroupContent
 * proto.webcast.im
 */
export interface CancelJoinGroupContent {
  leaverList: GroupPlayer[];
  operator: GroupPlayer | undefined;
  type: JoinType;
  groupUser: GroupChannelAllUser | undefined;
}

export interface P2PGroupChangeContent {
  groupExtInfoList: RTCExtraInfo[];
  groupUser: GroupChannelAllUser | undefined;
  migrationDetails: MigrationDetails | undefined;
  contentPos: ContentPosition[];
}

export interface GroupChangeContent {
  groupUser: GroupChannelAllUser | undefined;
  linkedUserUiPositions: string[];
}

export interface BusinessContent {
  overLength: string;
  multiLiveContent: MultiLiveContent | undefined;
  cohostContent: BusinessContent_CohostContent | undefined;
}

export interface BusinessContent_CohostContent {
  joinGroupBizContent: BusinessContent_JoinGroupBizContent | undefined;
  permitJoinGroupBizContent: BusinessContent_PermitJoinGroupBizContent | undefined;
  listChangeBizContent: BusinessContent_ListChangeBizContent | undefined;
}

export interface BusinessContent_PermitJoinGroupBizContent {
  replyStatus: ReplyStatus;
  sourceType: SourceType;
}

export interface BusinessContent_ListChangeBizContent {
  userInfos: { [key: string]: BusinessContent_CohostUserInfo };
  waitingUsers: BusinessContent_ListChangeBizContent_VirtualWaitingUser[];
}

export interface BusinessContent_ListChangeBizContent_UserInfosEntry {
  key: string;
  value: BusinessContent_CohostUserInfo | undefined;
}

export interface BusinessContent_ListChangeBizContent_VirtualWaitingUser {
  userId: string;
  timestamp: string;
  avatars: Image[];
}

export interface BusinessContent_CohostUserInfo {
  permissionType: string;
  sourceType: SourceType;
  isLowVersion: boolean;
  bestTeammateUid: string;
  hasTopicPerm: boolean;
  streamConfig: BusinessContent_CohostUserInfo_CohostStreamConfig | undefined;
  inDifferentInviteTypeControlGroup: boolean;
  nickname: string;
  displayId: string;
  avatarThumb: Image | undefined;
  followStatus: string;
  userIdStr: string;
}

export interface BusinessContent_CohostUserInfo_CohostStreamConfig {
  screenShareStreamId: string;
}

export interface BusinessContent_JoinGroupBizContent {
  fromRoomAgeRestricted: number;
  fromTag: BusinessContent_Tag | undefined;
  dialog: BusinessContent_PerceptionDialogInfo | undefined;
  punishInfo: PunishEventInfo | undefined;
  topicInfo: CohostTopic | undefined;
  algoRequestId: string;
  cohostLayoutMode: CohostLayoutMode;
  tag: BusinessContent_JoinGroupBizContent_TagV2 | undefined;
  gameTag: BusinessContent_JoinGroupBizContent_RivalsGameTag | undefined;
  newUserEducation: string;
  joinGroupMsgExtra: BusinessContent_JoinGroupMessageExtra | undefined;
}

export interface BusinessContent_JoinGroupBizContent_RivalsGameTag {
  tagId: string;
  tagDisplayText: string;
}

export interface BusinessContent_JoinGroupBizContent_TagV2 {
  tagClassification: TagClassification;
  tagType: number;
  tagValue: string;
  starlingKey: string;
  secondDegreeRelationContent: BusinessContent_JoinGroupBizContent_TagV2_SecondDegreeRelationContent | undefined;
  cohostHistoryDay: string;
  similarInterestContent: BusinessContent_JoinGroupBizContent_TagV2_SimilarInterestContent | undefined;
}

export interface BusinessContent_JoinGroupBizContent_TagV2_UserInfo {
  userId: string;
  nickName: string;
  avatarThumb: Image | undefined;
}

export interface BusinessContent_JoinGroupBizContent_TagV2_SecondDegreeRelationContent {
  relatedUsers: BusinessContent_JoinGroupBizContent_TagV2_UserInfo[];
  totalRelatedUserCnt: string;
}

export interface BusinessContent_JoinGroupBizContent_TagV2_SimilarInterestContent {
  contentId: string;
  displayText: string;
}

export interface BusinessContent_Tag {
  tagType: number;
  tagValue: string;
  tagText: string;
}

export interface BusinessContent_PerceptionDialogInfo {
  /** @warning Enum not found, should be IconType */
  iconType: string;
  title: Text | undefined;
  subTitle: Text | undefined;
  adviceActionText: Text | undefined;
  defaultActionText: Text | undefined;
  violationDetailUrl: string;
  scene: number;
  targetUserId: string;
  targetRoomId: string;
  countDownTime: string;
  showFeedback: boolean;
  feedbackOptionsList: BusinessContent_PerceptionFeedbackOption[];
  policyTip: string;
}

export interface BusinessContent_PerceptionFeedbackOption {
  id: string;
  contentKey: string;
}

export interface BusinessContent_JoinGroupMessageExtra {
  sourceType: string;
  extra: BusinessContent_JoinGroupMessageExtra_RivalExtra | undefined;
  otherUsersList: BusinessContent_JoinGroupMessageExtra_RivalExtra[];
}

/**
 * @RivalExtra
 * proto.webcast.im.JoinGroupMessageExtra
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface BusinessContent_JoinGroupMessageExtra_RivalExtra {
  userCount: string;
  avatarThumb: Image | undefined;
  displayId: string;
  authenticationInfo: BusinessContent_JoinGroupMessageExtra_RivalExtra_AuthenticationInfo | undefined;
  nickname: string;
  followStatus: string;
  hashtag: BusinessContent_Hashtag | undefined;
  topHostInfo: BusinessContent_TopHostInfo | undefined;
  userId: string;
  isBestTeammate: boolean;
}

export interface BusinessContent_JoinGroupMessageExtra_RivalExtra_AuthenticationInfo {
  customVerify: string;
  enterpriseVerifyReason: string;
  authenticationBadge: Image | undefined;
}

export interface BusinessContent_Hashtag {
  id: string;
  title: string;
  image: Image | undefined;
  namespace: HashtagNamespace;
}

export interface BusinessContent_TopHostInfo {
  rankType: string;
  topIndex: string;
}

export interface JoinGroupContent {
  groupUser: GroupChannelAllUser | undefined;
  joinUser: GroupPlayer | undefined;
  type: JoinType;
  groupExtInfo: RTCExtraInfo[];
}

export interface PrivilegeLogExtra {
  dataVersion: string;
  privilegeId: string;
  privilegeVersion: string;
  privilegeOrderId: string;
  level: string;
}

export interface FontStyle {
  fontSize: number;
  fontWidth: number;
  fontColor: string;
  borderColor: string;
}

export interface UserHonor {
  totalDiamond: string;
  diamondIcon: Image | undefined;
  currentHonorName: string;
  currentHonorIcon: Image | undefined;
  nextHonorName: string;
  level: number;
  nextHonorIcon: Image | undefined;
  currentDiamond: string;
  thisGradeMinDiamond: string;
  thisGradeMaxDiamond: string;
  gradeDescribe: string;
  gradeIconList: GradeIcon[];
  screenChatType: string;
  imIcon: Image | undefined;
  imIconWithLevel: Image | undefined;
  liveIcon: Image | undefined;
  newImIconWithLevel: Image | undefined;
  newLiveIcon: Image | undefined;
  upgradeNeedConsume: string;
  nextPrivileges: string;
  profileDialogBg: Image | undefined;
  profileDialogBackBg: Image | undefined;
  score: string;
  gradeBanner: string;
}

/**
 * @GradeIcon
 * proto.webcast.data.User.PayGrade
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface GradeIcon {
  icon: Image | undefined;
  iconDiamond: string;
  level: string;
  levelStr: string;
}

export interface BorderInfo {
  icon: Image | undefined;
  level: string;
  source: string;
  profileDecorationRibbon: Image | undefined;
  borderLogExtra: PrivilegeLogExtra | undefined;
  ribbonLogExtra: PrivilegeLogExtra | undefined;
  avatarBackgroundColor: string;
  avatarBackgroundBorderColor: string;
}

export interface FansClubMember {
  data: FansClubData | undefined;
  preferData: { [key: number]: FansClubData };
}

export interface FansClubMember_PreferDataEntry {
  key: number;
  value: FansClubData | undefined;
}

export interface FansClubData {
  clubName: string;
  level: number;
  userFansClubStatus: number;
  badge: FansClubData_UserBadge | undefined;
  availableGiftIds: string[];
  anchorId: string;
}

export interface FansClubData_UserBadge {
  icons: { [key: number]: Image };
  title: string;
}

export interface FansClubData_UserBadge_IconsEntry {
  key: number;
  value: Image | undefined;
}

export interface Author {
  videoTotalCount: string;
  videoTotalPlayCount: string;
  videoTotalFavoriteCount: string;
}

export interface PublicAreaCommon {
  userLabel: Image | undefined;
  userConsumeInRoom: string;
}

export interface PublicAreaMessageCommon {
  scrollGapCount: string;
  anchorScrollGapCount: string;
  releaseToScrollArea: boolean;
  anchorReleaseToScrollArea: boolean;
  isAnchorMarked: boolean;
  creatorSuccessInfo: PublicAreaMessageCommon_CreatorSuccessInfo | undefined;
  portraitInfo: PublicAreaMessageCommon_PortraitInfo | undefined;
  userInteractionInfo: PublicAreaMessageCommon_UserInteractionInfo | undefined;
  adminFoldType: string;
}

export interface PublicAreaMessageCommon_TagItem {
  tagType: TagType;
  tagText: Text | undefined;
}

export interface PublicAreaMessageCommon_Topic {
  topicActionType: TopicActionType;
  topicText: Text | undefined;
  topicTips: Text | undefined;
}

export interface PublicAreaMessageCommon_CreatorSuccessInfo {
  tags: PublicAreaMessageCommon_TagItem[];
  topic: PublicAreaMessageCommon_Topic | undefined;
}

export interface PublicAreaMessageCommon_UserMetrics {
  type: UserMetricsType;
  metricsValue: string;
}

export interface PublicAreaMessageCommon_PortraitTag {
  tagId: string;
  priority: string;
  showValue: string;
  showArgs: string;
}

export interface PublicAreaMessageCommon_PortraitInfo {
  userMetrics: PublicAreaMessageCommon_UserMetrics[];
  portraitTag: PublicAreaMessageCommon_PortraitTag[];
}

export interface PublicAreaMessageCommon_UserInteractionInfo {
  likeCnt: string;
  commentCnt: string;
  shareCnt: string;
}

export interface GiftModeMeta {
  giftId: string;
  giftNameKey: string;
  giftIconImage: Image | undefined;
  giftModeDesc: Text | undefined;
}

export interface BattleTeamUser {
  userId: string;
  score: string;
  userIdStr: string;
}

export interface BattleSetting {
  battleId: string;
  startTimeMs: string;
  duration: number;
  channelId: string;
  status: number;
  inviteType: BattleInviteType;
  giftModeMeta: GiftModeMeta | undefined;
  battleType: BattleType;
  extraDurationSecond: string;
  endTimeMs: string;
}

export interface BattleTeamUserArmies {
  teamId: string;
  teamUsers: BattleTeamUser[];
  teamTotalScore: string;
  userArmies: BattleUserArmies | undefined;
  hostRank: string;
}

export interface BattleUserArmies {
  userArmy: BattleUserArmy[];
  hostScore: string;
  anchorIdStr: string;
}

export interface BattleUserArmy {
  userId: string;
  score: string;
  nickname: string;
  avatarThumb: Image | undefined;
  diamondScore: string;
  userIdStr: string;
}

export interface HighScoreControlCfg {
  normalControlApplied: boolean;
  threshold: string;
  originDisplayToUserList: string[];
}

/** Heartbeat message */
export interface HeartbeatMessage {
  roomId: string;
}

/** Incoming & outbound messages */
export interface WebcastPushFrame {
  seqId: string;
  logId: string;
  service: string;
  method: string;
  headers: { [key: string]: string };
  payloadEncoding: string;
  payloadType: string;
  payload: Uint8Array;
}

export interface WebcastPushFrame_HeadersEntry {
  key: string;
  value: string;
}

export interface Message {
  type: string;
  binary: Uint8Array;
}

export interface WebsocketParam {
  name: string;
  value: string;
}

export interface WebcastRoomUserSeqMessage {
  common: CommonMessageData | undefined;
  viewerCount: number;
  ranksList: WebcastRoomUserSeqMessage_Contributor[];
  popStr: string;
  seatsList: WebcastRoomUserSeqMessage_Contributor[];
  popularity: string;
  totalUser: number;
  anonymous: string;
}

export interface WebcastRoomUserSeqMessage_Contributor {
  coinCount: number;
  user: User | undefined;
  rank: number;
  delta: string;
}

export interface ImageModel {
  mUrls: string[];
  mUri: string;
  height: number;
  width: number;
  avgColor: string;
  imageType: number;
  schema: string;
  content: ImageModel_Content | undefined;
  isAnimated: boolean;
}

export interface ImageModel_Content {
  name: string;
  fontColor: string;
  level: string;
}

export interface WebcastChatMessage {
  common: CommonMessageData | undefined;
  user: User | undefined;
  comment: string;
  visibleToSender: boolean;
  background: ImageModel | undefined;
  fullScreenTextColor: string;
  backgroundImageV2: ImageModel | undefined;
  publicAreaCommon: PublicAreaCommon | undefined;
  giftImage: ImageModel | undefined;
  inputType: number;
  atUser: User | undefined;
  emotes: WebcastSubEmote[];
  contentLanguage: string;
  msgFilter: MsgFilter | undefined;
  quickChatScene: number;
  communityflaggedStatus: number;
  commentQualityScores: WebcastChatMessage_CommentQualityScore[];
  userIdentity: WebcastChatMessage_UserIdentity | undefined;
  commentTag: WebcastChatMessage_CommentTag[];
  publicAreaMessageCommon: PublicAreaMessageCommon | undefined;
  screenTime: string;
  signature: string;
  signatureVersion: string;
  ecStreamerKey: string;
}

export enum WebcastChatMessage_CommentTag {
  COMMENT_TAG_NORMAL = 0,
  COMMENT_TAG_CANDIDATE = 1,
  COMMENT_TAG_OVERAGE = 2,
  UNRECOGNIZED = -1,
}

export interface WebcastChatMessage_UserIdentity {
  isGiftGiverOfAnchor: boolean;
  isSubscriberOfAnchor: boolean;
  isMutualFollowingWithAnchor: boolean;
  isFollowerOfAnchor: boolean;
  isModeratorOfAnchor: boolean;
  isAnchor: boolean;
}

export interface WebcastChatMessage_CommentQualityScore {
  version: string;
  score: string;
}

export interface EmoteUploadInfo {
  userId: string;
  emoteUploadSource?: EmoteUploadInfo_UserEmoteUploadSource | undefined;
  userInfo: User | undefined;
  userIdStr: string;
}

export enum EmoteUploadInfo_UserEmoteUploadSource {
  USER_EMOTE_UPLOAD_SOURCE_EMOTE_UPLOAD_SOURCE_ANCHOR = 0,
  USER_EMOTE_UPLOAD_SOURCE_EMOTE_UPLOAD_SOURCE_SUBSCRIBER = 1,
  USER_EMOTE_UPLOAD_SOURCE_EMOTE_UPLOAD_SOURCE_MODERATOR = 2,
  UNRECOGNIZED = -1,
}

/** Chat Emotes (Subscriber) */
export interface WebcastEmoteChatMessage {
  common: CommonMessageData | undefined;
  user: User | undefined;
  emoteList: Emote[];
  msgFilter: MsgFilter | undefined;
  userIdentity: UserIdentity | undefined;
}

export interface WebcastSubEmote {
  /** starting at 0, you insert the emote itself into the comment at that place */
  placeInComment: number;
  emote: EmoteDetails | undefined;
}

export interface WebcastMemberMessage {
  common: CommonMessageData | undefined;
  user: User | undefined;
  action: MemberMessageAction;
  memberCount: number;
  operator: User | undefined;
  isSetToAdmin: boolean;
  isTopUser: boolean;
  rankScore: string;
  topUserNo: string;
  enterType: string;
  actionDescription: string;
  userId: string;
  effectConfig: WebcastMemberMessage_EffectConfig | undefined;
  popStr: string;
  enterEffectConfig: WebcastMemberMessage_EffectConfig | undefined;
  backgroundImage: Image | undefined;
  backgroundImageV2: Image | undefined;
  anchorDisplayText: Text | undefined;
  clientEnterSource: string;
  clientEnterType: string;
  clientLiveReason: string;
  actionDuration: string;
  userShareType: string;
  displayStyle: WebcastMemberMessage_DisplayStyle;
  adminPermissions: { [key: number]: number };
  kickSource: number;
  allowPreviewTime: string;
  lastSubscriptionAction: string;
  publicAreaMessageCommon: PublicAreaMessageCommon | undefined;
  liveSubOnlyTier: string;
  liveSubOnlyMonth: string;
  ecStreamerKey: string;
  showWave: string;
  waveAlgorithmData: WebcastMemberMessage_WaveAlgorithmData | undefined;
  hitAbStatus: WebcastMemberMessage_HitABStatus;
}

export enum WebcastMemberMessage_DisplayStyle {
  DISPLAY_STYLE_NORMAL = 0,
  DISPLAY_STYLE_STAY = 1,
  DISPLAY_STYLE_CHAT = 2,
  UNRECOGNIZED = -1,
}

export enum WebcastMemberMessage_HitABStatus {
  HIT_A_B_STATUS_HIT_AB_STATUS_NO_HIT = 0,
  HIT_A_B_STATUS_HIT_AB_STATUS_ENTER_FROM_EXTERNAL_LINK_NEW_TEXT = 1,
  HIT_A_B_STATUS_HIT_AB_STATUS_ENTER_FROM_RE_POST_NEW_TEXT = 2,
  UNRECOGNIZED = -1,
}

export interface WebcastMemberMessage_AdminPermissionsEntry {
  key: number;
  value: number;
}

/**
 * @EffectConfig
 * proto.webcast.im.MemberMessage
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface WebcastMemberMessage_EffectConfig {
  type: string;
  icon: Image | undefined;
  avatarPos: string;
  text: Text | undefined;
  textIcon: Image | undefined;
  stayTime: number;
  animAssetId: string;
  badge: Image | undefined;
  flexSettingArrayList: string[];
}

export interface WebcastMemberMessage_WaveAlgorithmData {
  algorithmVersion: string;
  isAlgHit: boolean;
  predictScore: string;
  isRewatch: boolean;
  isFollow: boolean;
}

export interface WebcastMemberMessage_EffectConfigBean {
  type: number;
  icon: ImageModel | undefined;
  textKey: Text | undefined;
  badge: ImageModel | undefined;
}

export interface WebcastGiftMessage {
  common: CommonMessageData | undefined;
  giftId: number;
  user: User | undefined;
  repeatEnd: number;
  groupId: string;
  giftDetails: Gift | undefined;
  monitorExtra: string;
  fanTicketCount: string;
  groupCount: number;
  repeatCount: number;
  comboCount: number;
  toUser: User | undefined;
  textEffect: WebcastGiftMessage_TextEffect | undefined;
  incomeTaskgifts: string;
  roomFanTicketCount: string;
  priority: WebcastGiftMessage_GiftIMPriority | undefined;
  logId: string;
  sendType: string;
  publicAreaCommon: PublicAreaCommon | undefined;
  trayDisplayText: Text | undefined;
  bannedDisplayEffects: string;
  mTrayInfo: WebcastGiftMessage_GiftTrayInfo | undefined;
  giftExtra: WebcastGiftMessage_GiftMonitorInfo | undefined;
  colorId: string;
  isFirstSent: boolean;
  displayTextForAnchor: Text | undefined;
  displayTextForAudience: Text | undefined;
  orderId: string;
  giftsInBox: WebcastGiftMessage_GiftsBoxInfo | undefined;
  msgFilter: MsgFilter | undefined;
  lynxExtra: WebcastGiftMessage_LynxGiftExtra[];
  userIdentity: UserIdentity | undefined;
  matchInfo: WebcastGiftMessage_MatchInfo | undefined;
  linkmicGiftExpressionStrategy: LinkmicGiftExpressionStrategy;
  flyingMicResources: WebcastGiftMessage_FlyingMicResources | undefined;
  disableGiftTracking: boolean;
  asset: WebcastGiftMessage_AssetsModel | undefined;
  version: GiftMessageVersion;
  sponsorshipInfo: WebcastGiftMessage_SponsorshipInfo[];
  flyingMicResourcesV2: WebcastGiftMessage_FlyingMicResources | undefined;
  publicAreaMessageCommon: PublicAreaMessageCommon | undefined;
  signature: string;
  signatureVersion: string;
  multiGenerateMessage: boolean;
  toMemberId: string;
  toMemberIdInt: string;
  toMemberNickname: string;
  interactiveGiftInfo: WebcastGiftMessage_InteractiveGiftInfo | undefined;
}

export interface WebcastGiftMessage_InteractiveGiftInfo {
  crossScreenDelay: string;
  crossScreenRole: string;
  ignoreConfig: GiftMessageIgnoreConfig;
  uniqId: string;
  toUserTeamId: string;
}

export interface WebcastGiftMessage_GiftIMPriority {
  queueSizesList: string[];
  selfQueuePriority: string;
  priority: string;
}

export interface WebcastGiftMessage_TextEffect {
  portraitDetail: WebcastGiftMessage_TextEffect_Detail | undefined;
  landscapeDetail: WebcastGiftMessage_TextEffect_Detail | undefined;
}

export interface WebcastGiftMessage_TextEffect_Detail {
  text: Text | undefined;
  textFontSize: number;
  background: Image | undefined;
  start: string;
  duration: string;
  x: number;
  y: number;
  width: number;
  height: number;
  shadowDx: number;
  shadowDy: number;
  shadowRadius: number;
  shadowColor: string;
  strokeColor: string;
  strokeWidth: number;
}

export interface WebcastGiftMessage_GiftTrayInfo {
  mDynamicImg: Image | undefined;
  canMirror: boolean;
  trayNormalBgImg: Image | undefined;
  trayNormalBgColor: string[];
  traySmallBgImg: Image | undefined;
  traySmallBgColor: string[];
  rightTagText: Text | undefined;
  rightTagBgImg: Image | undefined;
  rightTagBgColor: string[];
  trayNameTextColor: string;
  trayDescTextColor: string;
  rightTagJumpSchema: string;
}

export interface WebcastGiftMessage_GiftMonitorInfo {
  anchorId: string;
  profitApiMessageDur: string;
  sendGiftProfitApiStartMs: string;
  sendGiftProfitCoreStartMs: string;
  sendGiftReqStartMs: string;
  sendGiftSendMessageSuccessMs: string;
  sendProfitApiDur: string;
  toUserId: string;
  sendGiftStartClientLocalMs: string;
  fromPlatform: string;
  fromVersion: string;
}

export interface WebcastGiftMessage_MatchInfo {
  critical: string;
  effectCardInUse: boolean;
  multiplierType: MultiplierType;
  multiplierValue: string;
}

export interface WebcastGiftMessage_GiftsBoxInfo {
  gifts: WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox[];
}

export interface WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox {
  giftId: string;
  effectId: string;
  colorId: string;
  remainTimes: number;
  asset: WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel | undefined;
}

export interface WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel {
  name: string;
  resourceUri: string;
  resourceModel: WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_ResourceModel | undefined;
  describe: string;
  id: string;
  resourceType: number;
  md5: string;
  size: string;
  lokiExtraContent: WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContent | undefined;
  downloadType: number;
  resourceByteVC1Model: WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_ResourceModel | undefined;
  bytevc1Md5: string;
  videoResourceList: WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_VideoResource[];
  faceRecognitionArchiveMeta: WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_FaceRecognitionMeta | undefined;
  lynxUrlSettingsKey: string;
  downgradeResourceType: number;
  assetExtra: WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_AssetExtra | undefined;
  stickerAssetVariant: number;
  immediateDownload: boolean;
  stickerAssetVariantReason: number;
}

export interface WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_AssetExtra {
  effectStarlingKey: string;
}

export interface WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_ResourceModel {
  urlList: string[];
  uri: string;
}

export interface WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContent {
  giftType: string;
  giftDuration: string;
  needScreenShot: boolean;
  ismultiFrame: boolean;
  viewOverlay: string;
  befViewRenderSize:
    | WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContent_BEFViewRenderSize
    | undefined;
  befViewRenderFPS: number;
  befViewFitMode: number;
  modelNames: string;
  requirements: string[];
}

export interface WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContent_BEFViewRenderSize {
  with: number;
  height: number;
}

export interface WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_VideoResource {
  videoTypeName: string;
  videoUrl: WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_ResourceModel | undefined;
  videoMd5: string;
}

export interface WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_FaceRecognitionMeta {
  version: string;
  requirements: string[];
  modelNames: string;
  sdkExtra: string;
}

export interface WebcastGiftMessage_AssetsModel {
  name: string;
  resourceUri: string;
  resourceModel: WebcastGiftMessage_AssetsModel_ResourceModel | undefined;
  describe: string;
  id: string;
  resourceType: number;
  md5: string;
  size: string;
  lokiExtraContent: WebcastGiftMessage_AssetsModel_LokiExtraContent | undefined;
  downloadType: number;
  resourceByteVC1Model: WebcastGiftMessage_AssetsModel_ResourceModel | undefined;
  bytevc1Md5: string;
  videoResourceList: WebcastGiftMessage_AssetsModel_VideoResource[];
  faceRecognitionArchiveMeta: WebcastGiftMessage_AssetsModel_FaceRecognitionMeta | undefined;
  lynxUrlSettingsKey: string;
  downgradeResourceType: number;
  assetExtra: WebcastGiftMessage_AssetsModel_AssetExtra | undefined;
  stickerAssetVariant: number;
  immediateDownload: boolean;
  stickerAssetVariantReason: number;
}

export interface WebcastGiftMessage_AssetsModel_AssetExtra {
  effectStarlingKey: string;
}

export interface WebcastGiftMessage_AssetsModel_ResourceModel {
  urlList: string[];
  uri: string;
}

export interface WebcastGiftMessage_AssetsModel_LokiExtraContent {
  giftType: string;
  giftDuration: string;
  needScreenShot: boolean;
  ismultiFrame: boolean;
  viewOverlay: string;
  befViewRenderSize: WebcastGiftMessage_AssetsModel_LokiExtraContent_BEFViewRenderSize | undefined;
  befViewRenderFPS: number;
  befViewFitMode: number;
  modelNames: string;
  requirements: string[];
}

export interface WebcastGiftMessage_AssetsModel_LokiExtraContent_BEFViewRenderSize {
  with: number;
  height: number;
}

export interface WebcastGiftMessage_AssetsModel_VideoResource {
  videoTypeName: string;
  videoUrl: WebcastGiftMessage_AssetsModel_ResourceModel | undefined;
  videoMd5: string;
}

export interface WebcastGiftMessage_AssetsModel_FaceRecognitionMeta {
  version: string;
  requirements: string[];
  modelNames: string;
  sdkExtra: string;
}

export interface WebcastGiftMessage_LynxGiftExtra {
  id: string;
  code: string;
  type: string;
  params: string[];
  extra: string;
}

export interface WebcastGiftMessage_FlyingMicResources {
  pathImage: Image | undefined;
  micImage: Image | undefined;
  transitionConfigs: WebcastGiftMessage_FlyingMicResources_TransitionConfig[];
}

export interface WebcastGiftMessage_FlyingMicResources_TransitionConfig {
  configId: string;
  resourceImage: Image | undefined;
}

export interface WebcastGiftMessage_SponsorshipInfo {
  giftId: string;
  sponsorId: string;
  lightGiftUp: boolean;
  unlightedGiftIcon: string;
  giftGalleryDetailPageSchemeUrl: string;
  giftGalleryClickSponsor: boolean;
  becomeAllSponsored: boolean;
}

/** Battle start */
export interface WebcastLinkMicBattle {
  common: CommonMessageData | undefined;
  battleId: string;
  battleSetting: BattleSetting | undefined;
  action: BattleAction;
  battleResult: { [key: string]: WebcastLinkMicBattle_BattleResult };
  mBattleDisplayConfig: WebcastLinkMicBattle_BattleDisplayConfig | undefined;
  inviteeGiftPermissionType: GiftPermissionType;
  armies: { [key: string]: BattleUserArmies };
  anchorInfo: { [key: string]: WebcastLinkMicBattle_BattleUserInfo };
  bubbleText: string;
  supportedActions: WebcastLinkMicBattle_SupportedActionsWrapper[];
  battleCombos: { [key: string]: WebcastLinkMicBattle_BattleComboInfo };
  teamUsers: WebcastLinkMicBattle_TeamUsersInfo[];
  inviteeGiftPermissionTypes: WebcastLinkMicBattle_BattleInviteeGiftPermission[];
  actionByUserId: string;
  teamBattleResult: WebcastLinkMicBattle_BattleTeamResult[];
  teamArmies: BattleTeamUserArmies[];
  abtestSettings: WebcastLinkMicBattle_BattleABTestSetting[];
  teamMatchCampaign: WebcastLinkMicBattle_TeamMatchCampaign | undefined;
  fuzzyDisplayConfigV2: HighScoreControlCfg | undefined;
}

export interface WebcastLinkMicBattle_BattleResultEntry {
  key: string;
  value: WebcastLinkMicBattle_BattleResult | undefined;
}

export interface WebcastLinkMicBattle_ArmiesEntry {
  key: string;
  value: BattleUserArmies | undefined;
}

export interface WebcastLinkMicBattle_AnchorInfoEntry {
  key: string;
  value: WebcastLinkMicBattle_BattleUserInfo | undefined;
}

export interface WebcastLinkMicBattle_BattleCombosEntry {
  key: string;
  value: WebcastLinkMicBattle_BattleComboInfo | undefined;
}

export interface WebcastLinkMicBattle_TeamMatchCampaign {
  bestTeammateRelation: WebcastLinkMicBattle_TeamMatchCampaign_BestTeammateRelation[];
  startSfxTeamId: string[];
  hasTeamMatchMvpSfx: boolean;
}

export interface WebcastLinkMicBattle_TeamMatchCampaign_BestTeammateRelation {
  userId: string;
  bestTeammateId: string;
}

export interface WebcastLinkMicBattle_BattleTeamResult {
  teamId: string;
  teamUsers: BattleTeamUser[];
  result: number;
  totalScore: string;
}

export interface WebcastLinkMicBattle_BattleInviteeGiftPermission {
  userId: string;
  giftPermissionType: number;
}

export interface WebcastLinkMicBattle_SupportedActionsWrapper {
  actionType: string;
}

export interface WebcastLinkMicBattle_TeamUsersInfo {
  teamId: string;
  userIds: string[];
}

export interface WebcastLinkMicBattle_BattleComboInfo {
  userId: string;
  comboStatus: string;
  comboCount: string;
  comboIconUrl: string;
  comboType: number;
  comboRuleGuideSchema: string;
}

export interface WebcastLinkMicBattle_BattleResult {
  userId: string;
  result: Result;
  score: string;
}

export interface WebcastLinkMicBattle_BattleDisplayConfig {
  threshold: number;
  text: string;
  diffThreshold: number;
  diffText: string;
  exemptStrategy: WebcastLinkMicBattle_BattleDisplayConfig_ExemptStrategy | undefined;
}

export interface WebcastLinkMicBattle_BattleDisplayConfig_ExemptStrategy {
  exemptBothHost: boolean;
  exemptAudienceTop: number;
}

export interface WebcastLinkMicBattle_BattleUserInfo {
  user: WebcastLinkMicBattle_BattleUserInfo_BattleBaseUserInfo | undefined;
  tags: WebcastLinkMicBattle_BattleUserInfo_BattleRivalTag[];
}

export interface WebcastLinkMicBattle_BattleUserInfo_BattleBaseUserInfo {
  userId: string;
  nickName: string;
  avatarThumb: Image | undefined;
  displayId: string;
}

export interface WebcastLinkMicBattle_BattleUserInfo_BattleRivalTag {
  bgImage: Image | undefined;
  iconImage: Image | undefined;
  content: string;
}

export interface WebcastLinkMicBattle_BattleABTestSetting {
  uid: string;
  abTestList: WebcastLinkMicBattle_BattleABTestSetting_BattleABTestList | undefined;
}

export interface WebcastLinkMicBattle_BattleABTestSetting_BattleABTestList {
  abTestList: WebcastLinkMicBattle_BattleABTestSetting_BattleABTestList_BattleABTest[];
}

export interface WebcastLinkMicBattle_BattleABTestSetting_BattleABTestList_BattleABTest {
  abTestType: BattleABTestType;
  group: number;
}

/** Battle status */
export interface WebcastLinkMicArmies {
  common: CommonMessageData | undefined;
  battleId: string;
  battleItems: { [key: string]: BattleUserArmies };
  channelId: string;
  giftSentTime: string;
  scoreUpdateTime: string;
  battleStatus: TriggerReason;
  fromUserId: string;
  giftId: string;
  giftCount: number;
  gifIconImage: Image | undefined;
  totalDiamondCount: number;
  repeatCount: number;
  teamArmies: BattleTeamUserArmies[];
  triggerCriticalStrike: boolean;
  hasTeamMatchMvpSfx: boolean;
  logId: string;
  battleSettings: BattleSetting | undefined;
  fuzzyDisplayConfigV2: HighScoreControlCfg | undefined;
}

export interface WebcastLinkMicArmies_BattleItemsEntry {
  key: string;
  value: BattleUserArmies | undefined;
}

export interface WebcastLinkMicArmiesItems {
  hostUserId: string;
  battleGroups: WebcastLinkMicArmiesGroup[];
}

export interface WebcastLinkMicArmiesGroup {
  users: User[];
  points: number;
}

/** Follow & share event */
export interface WebcastSocialMessage {
  common: CommonMessageData | undefined;
  user: User | undefined;
  shareType: string;
  action: string;
  shareTarget: string;
  followCount: number;
  shareDisplayStyle: string;
  shareCount: number;
  publicAreaMessageCommon: PublicAreaMessageCommon | undefined;
  signature: string;
  signatureVersion: string;
  showDurationMs: string;
}

/** Like event (is only sent from time to time, not with every like) */
export interface WebcastLikeMessage {
  common: CommonMessageData | undefined;
  likeCount: number;
  totalLikeCount: number;
  color: number;
  user: User | undefined;
  icon: string;
  icons: Image[];
  specifiedDisplayText: SpecifiedDisplayText[];
  effectCnt: string;
  likeEffect: LikeEffect[];
  publicAreaMessageCommon: PublicAreaMessageCommon | undefined;
  roomMessageHeatLevel: string;
}

export interface SpecifiedDisplayText {
  uid: string;
  displayText: Text | undefined;
}

export interface LikeEffect {
  version: string;
  effectCnt: string;
  effectIntervalMs: string;
  level: string;
}

/** New question event */
export interface WebcastQuestionNewMessage {
  common: CommonMessageData | undefined;
  details: WebcastQuestionNewMessage_Question | undefined;
}

export interface WebcastQuestionNewMessage_Question {
  questionId: string;
  questionText: string;
  answerStatus: number;
  createTime: string;
  user: User | undefined;
  createFrom: number;
  answerFrom: number;
}

/** Contains UI information */
export interface WebcastMessageEventDetails {
  displayType: string;
  label: string;
}

/** Source: Co-opted https://github.com/zerodytrash/TikTok-Livestream-Chat-Connector/issues/19#issuecomment-1074150342 */
export interface WebcastLiveIntroMessage {
  common: CommonMessageData | undefined;
  roomId: string;
  auditStatus: AuditStatus;
  description: string;
  host: User | undefined;
  introMode: number;
  badges: BadgeStruct[];
  language: string;
}

export interface SystemMessage {
  description: string;
}

export interface RankItem {
  colour: string;
  id: string;
}

export interface WebcastHourlyRankMessage {
  data: WebcastHourlyRankMessage_RankContainer | undefined;
  common: CommonMessageData | undefined;
  data2: number;
}

export interface WebcastHourlyRankMessage_RankContainer {
  data1: number;
  rankingData: WebcastHourlyRankMessage_RankContainer_RankingData | undefined;
  data2: number;
  rankings: Ranking | undefined;
  rankingData2: WebcastHourlyRankMessage_RankContainer_RankingData2 | undefined;
  data3: number;
  data4: number;
}

export interface WebcastHourlyRankMessage_RankContainer_RankingData {
  data1: number;
  rankdata: Ranking | undefined;
  data2: string;
}

export interface WebcastHourlyRankMessage_RankContainer_RankingData2 {
  data1: number;
  data2: number;
  rankdata: Ranking | undefined;
  data3: string;
  data4: number;
  data5: number;
}

export interface EmoteDetails {
  emoteId: string;
  image: EmoteImage | undefined;
}

export interface EmoteImage {
  imageUrl: string;
}

export interface WebcastEnvelopeMessage {
  common: CommonMessageData | undefined;
  envelopeInfo: WebcastEnvelopeMessage_EnvelopeInfo | undefined;
  display: EnvelopeDisplay;
}

export interface WebcastEnvelopeMessage_EnvelopeInfo {
  envelopeId: string;
  businessType: EnvelopeBusinessType;
  envelopeIdc: string;
  sendUserName: string;
  diamondCount: number;
  peopleCount: number;
  unpackAt: number;
  sendUserId: string;
  sendUserAvatar: Image | undefined;
  createAt: string;
  roomId: string;
  followShowStatus: EnvelopeFollowShowStatus;
  skinId: number;
}

export interface TreasureBoxData {
  coins: number;
  canOpen: number;
  timestamp: string;
}

/** New Subscriber message */
export interface WebcastSubNotifyMessage {
  common: CommonMessageData | undefined;
  user: User | undefined;
  exhibitionType: ExhibitionType;
  subMonth: string;
  subscribeType: SubscribeType;
  oldSubscribeStatus: OldSubscribeStatus;
  subscribeMessageType?: MessageType | undefined;
  subscribingStatus: SubscribingStatus;
  isSend: boolean;
  isCustom: boolean;
  giftSource: GiftSource;
  messageDisplayStyle: MessageDisplayStyle;
  publicAreaMessageCommon: PublicAreaMessageCommon | undefined;
  packageId: string;
  eventTracking: WebcastSubNotifyMessage_EventTracking | undefined;
}

export interface WebcastSubNotifyMessage_EventTracking {
  giftSubSenderId: string;
  giftSubReceiverId: string;
  anchorId: string;
  giftSubOrderCreateTime: string;
}

export interface FollowInfo {
  followingCount: number;
  followerCount: number;
  followStatus: number;
  pushStatus: number;
}

export interface ProfilePicture {
  urls: string[];
}

export interface UserBadgesAttributes {
  badgeSceneType: number;
  imageBadges: UserImageBadge[];
  badges: UserBadge[];
  privilegeLogExtra: PrivilegeLogExtra | undefined;
}

export interface UserBadge {
  type: string;
  name: string;
}

export interface UserImageBadge {
  displayType: number;
  image: UserImageBadgeImage | undefined;
}

export interface UserImageBadgeImage {
  url: string;
}

export interface WebcastBarrageMessage {
  common: CommonMessageData | undefined;
  event: WebcastBarrageMessage_BarrageEvent | undefined;
  msgType?: WebcastBarrageMessage_BarrageType | undefined;
  icon: ImageModel | undefined;
  duration: string;
  backGround: ImageModel | undefined;
  rightIcon: ImageModel | undefined;
  displayConfig: number;
  galleryGiftId: string;
  useMarquee: boolean;
  showType?: WebcastBarrageMessage_ShowType | undefined;
  renderType?: WebcastBarrageMessage_RenderType | undefined;
  leftIconDisplayType?: WebcastBarrageMessage_IconDisplayType | undefined;
  ribbonAnimation: ImageModel | undefined;
  hybridUrl: string;
  schema: string;
  subType: string;
  privilegeLogExtra: PrivilegeLogExtra | undefined;
  content: Text | undefined;
  scene: Scene;
  control: WebcastBarrageMessage_DisplayControl | undefined;
  rightLabel: WebcastBarrageMessage_RightLabel | undefined;
  badge: BadgeStruct | undefined;
  animationData: WebcastBarrageMessage_AnimationData | undefined;
  commonBarrageContent: Text | undefined;
  userGradeParam: WebcastBarrageMessage_BarrageTypeUserGradeParam | undefined;
  fansLevelParam: WebcastBarrageMessage_BarrageTypeFansLevelParam | undefined;
  subscribeGiftParam: WebcastBarrageMessage_BarrageTypeSubscribeGiftParam | undefined;
  giftGalleryParams: WebcastBarrageMessage_BarrageTypeGiftGalleryParam | undefined;
}

export enum WebcastBarrageMessage_BarrageType {
  BARRAGE_TYPE_UNKNOWN = 0,
  BARRAGE_TYPE_E_COM_ORDERING = 1,
  BARRAGE_TYPE_E_COM_BUYING = 2,
  BARRAGE_TYPE_NORMAL = 3,
  BARRAGE_TYPE_SUBSCRIBE = 4,
  BARRAGE_TYPE_EVENT_VIEW = 5,
  BARRAGE_TYPE_EVENT_REGISTERED = 6,
  BARRAGE_TYPE_SUBSCRIBE_GIFT = 7,
  BARRAGE_TYPE_USER_UPGRADE = 8,
  BARRAGE_TYPE_GRADE_USER_ENTRANCE_NOTIFICATION = 9,
  BARRAGE_TYPE_FANS_LEVEL_UPGRADE = 10,
  BARRAGE_TYPE_FANS_LEVEL_ENTRANCE = 11,
  BARRAGE_TYPE_GAME_PARTNERSHIP = 12,
  BARRAGE_TYPE_GIFT_GALLERY = 13,
  BARRAGE_TYPE_E_COM_BOUGHT = 14,
  BARRAGE_TYPE_COMMON_BARRAGE = 100,
  UNRECOGNIZED = -1,
}

export enum WebcastBarrageMessage_ShowType {
  SHOW_TYPE_NORMAL = 0,
  SHOW_TYPE_FADE_IN_OUT = 1,
  UNRECOGNIZED = -1,
}

export enum WebcastBarrageMessage_RenderType {
  RENDER_TYPE_NATIVE = 0,
  RENDER_TYPE_HYBRID = 1,
  RENDER_TYPE_ALPHA = 2,
  UNRECOGNIZED = -1,
}

export enum WebcastBarrageMessage_IconDisplayType {
  ICON_DISPLAY_TYPE_IMAGE = 0,
  ICON_DISPLAY_TYPE_BADGE = 1,
  UNRECOGNIZED = -1,
}

export interface WebcastBarrageMessage_BarrageEvent {
  eventName: string;
  params: { [key: string]: string };
}

export interface WebcastBarrageMessage_BarrageEvent_ParamsEntry {
  key: string;
  value: string;
}

export interface WebcastBarrageMessage_BarrageTypeUserGradeParam {
  currentGrade: number;
  displayConfig: number;
  userId: string;
  user: User | undefined;
}

export interface WebcastBarrageMessage_BarrageTypeFansLevelParam {
  currentGrade: number;
  displayConfig: number;
  user: User | undefined;
}

export interface WebcastBarrageMessage_BarrageTypeSubscribeGiftParam {
  giftSubCount: string;
  showGiftSubCount: boolean;
}

export interface WebcastBarrageMessage_AnimationData {
  geckoChannelName: string;
  fileName: string;
  height: string;
  width: string;
  rightOffset: string;
}

export interface WebcastBarrageMessage_BarrageTypeGiftGalleryParam {
  fromUserId: string;
  toUserId: string;
}

export interface WebcastBarrageMessage_DisplayControl {
  priority: number;
  duration: string;
  targetGroupShowRst: { [key: number]: WebcastBarrageMessage_DisplayControl_ShowResult };
  horizontalTriggerType: HorizontalOnclickTriggerType;
}

export interface WebcastBarrageMessage_DisplayControl_TargetGroupShowRstEntry {
  key: number;
  value: WebcastBarrageMessage_DisplayControl_ShowResult | undefined;
}

export interface WebcastBarrageMessage_DisplayControl_ShowResult {
  banned: boolean;
}

export interface WebcastBarrageMessage_RightLabel {
  backgroundColor: string;
  content: Text | undefined;
  height: string;
}

/** Response from TikTokServer. Container for Messages */
export interface ProtoMessageFetchResult {
  messages: BaseProtoMessage[];
  cursor: string;
  fetchInterval: string;
  now: string;
  internalExt: string;
  fetchType: number;
  wsParams: { [key: string]: string };
  heartBeatDuration: number;
  needsAck: boolean;
  wsUrl: string;
  isFirst: boolean;
  historyCommentCursor: string;
  historyNoMore: boolean;
}

export interface ProtoMessageFetchResult_WsParamsEntry {
  key: string;
  value: string;
}

export interface BaseProtoMessage {
  type: string;
  payload: Uint8Array;
  msgId: string;
  msgType: number;
  offset: string;
  isHistory: boolean;
}

export interface WebcastRoomMessage {
  common: CommonMessageData | undefined;
  content: string;
  supportLandscape: boolean;
  source: string;
  icon: Image | undefined;
  scene: Scene;
  isWelcome: boolean;
  publicAreaCommon: PublicAreaMessageCommon | undefined;
  showDurationMs: string;
  subScene: string;
}

/** Closed Captioning for Video */
export interface WebcastCaptionMessage {
  common: CommonMessageData | undefined;
  timestampMs: string;
  durationMs: string;
  content: WebcastCaptionMessage_CaptionContent[];
  sentenceId: string;
  sequenceId: string;
  definite: boolean;
}

export interface WebcastCaptionMessage_CaptionContent {
  lang: string;
  content: string;
}

/** System-Control Message from Room (e.g. Host ended Stream) */
export interface WebcastControlMessage {
  common: CommonMessageData | undefined;
  action: ControlAction;
  tips: string;
  extra: WebcastControlMessage_Extra | undefined;
  perceptionDialog: WebcastControlMessage_PerceptionDialogInfo | undefined;
  perceptionAudienceText: Text | undefined;
  punishInfo: PunishEventInfo | undefined;
  floatText: Text | undefined;
  floatStyle: number;
}

/**
 * @Extra
 * proto.webcast.im.ControlMessage
 */
export interface WebcastControlMessage_Extra {
  banInfoUrl: string;
  reasonNo: string;
  title: Text | undefined;
  violationReason: Text | undefined;
  content: Text | undefined;
  gotItButton: Text | undefined;
  banDetailButton: Text | undefined;
  source: string;
}

export interface WebcastControlMessage_PerceptionDialogInfo {
  iconType: PerceptionDialogIconType;
  title: Text | undefined;
  subTitle: Text | undefined;
  adviceActionText: Text | undefined;
  defaultActionText: Text | undefined;
  violationDetailUrl: string;
  scene: Scene;
  targetUserId: string;
  targetRoomId: string;
  countDownTime: string;
  showFeedback: boolean;
  feedbackOptions: WebcastControlMessage_PerceptionDialogInfo_PerceptionFeedbackOption[];
  policyTip: string;
  appealPopup: number;
}

export interface WebcastControlMessage_PerceptionDialogInfo_PerceptionFeedbackOption {
  id: string;
  contentKey: string;
}

export interface WebcastGoalUpdateMessage {
  common: CommonMessageData | undefined;
  indicator: LiveStreamGoalIndicator | undefined;
  goal: LiveStreamGoal | undefined;
  contributorId: string;
  contributorAvatar: Image | undefined;
  contributorDisplayId: string;
  contributeSubgoal: WebcastGoalUpdateMessage_LiveStreamSubGoal | undefined;
  contributeCount: string;
  contributeScore: string;
  giftRepeatCount: string;
  contributorIdStr: string;
  pin: boolean;
  unpin: boolean;
  pinInfo: WebcastGoalUpdateMessage_GoalPinInfo | undefined;
  updateSource: GoalMessageSource;
  goalExtra: string;
}

export interface WebcastGoalUpdateMessage_LiveStreamSubGoal {
  type: number;
  id: string;
  progress: string;
  target: string;
  gift: WebcastGoalUpdateMessage_LiveStreamSubGoal_LiveStreamSubGoalGift | undefined;
  idStr: string;
  pinInfo: WebcastGoalUpdateMessage_LiveStreamSubGoal_SubGoalPinInfo | undefined;
  source: number;
  recommendedText: string;
  recommendedCommon: string;
}

export interface WebcastGoalUpdateMessage_LiveStreamSubGoal_LiveStreamSubGoalGift {
  name: string;
  icon: Image | undefined;
  diamondCount: string;
  type: number;
}

export interface WebcastGoalUpdateMessage_LiveStreamSubGoal_SubGoalPinInfo {
  pinStartTime: string;
  pinEndTime: string;
  pinReadyTime: string;
}

export interface WebcastGoalUpdateMessage_GoalPinInfo {
  pin: boolean;
  unpin: boolean;
  pinEndTime: string;
  subGoalId: string;
  subGoalIdStr: string;
}

/** Message related to Chat-moderation? */
export interface WebcastImDeleteMessage {
  common: CommonMessageData | undefined;
  deleteMsgIdsList: string[];
  deleteUserIdsList: string[];
}

export interface WebcastInRoomBannerMessage {
  common: CommonMessageData | undefined;
  data: { [key: string]: string };
  position: number;
  actionType: number;
}

export interface WebcastInRoomBannerMessage_DataEntry {
  key: string;
  value: string;
}

export interface WebcastRankUpdateMessage {
  common: CommonMessageData | undefined;
  updatesList: WebcastRankUpdateMessage_RankUpdate[];
  /** @warning Enum not found, should be GroupType */
  groupType: string;
  priority: string;
  tabsList: WebcastRankUpdateMessage_RankTabInfo[];
  isAnimationLoopPlay: boolean;
  animationLoopForOff: boolean;
  unionAnimation: WebcastRankUpdateMessage_UnionAnimationInfo[];
  tabInfo: WebcastRankUpdateMessage_RankListTabInfo[];
}

export interface WebcastRankUpdateMessage_UnionAnimationInfo {
  unionType: UnionAnimationInfoType;
  rankTypeArray: ProfitRankType;
  supportedVersion: string;
}

export interface WebcastRankUpdateMessage_RankListTabInfo {
  tabs: WebcastRankUpdateMessage_RankTabInfo[];
  supportedVersion: string;
}

export interface WebcastRankUpdateMessage_RankTabInfo {
  rankType: ProfitRankType;
  title: string;
  titleText: Text | undefined;
  listLynxType: string;
}

/**
 * @RankUpdate
 * proto.webcast.im.RankUpdateMessage
 */
export interface WebcastRankUpdateMessage_RankUpdate {
  /** @warning Enum not found, should be RankType */
  rankType: string;
  ownerRank: string;
  defaultContent: Text | undefined;
  showEntranceAnimation: boolean;
  countdown: string;
  /** @warning Enum not found, should be RelatedTabRankType */
  relatedTabRankType: string;
  /** @warning Enum not found, should be RequestFirstShowType */
  requestFirstShowType: string;
  supportedVersion: string;
  owneronrank: boolean;
}

/** --- HandMade -- */
export interface WebcastPollMessage {
  common: CommonMessageData | undefined;
  messageType: MessageType;
  pollId: string;
  startContent: PollStartContent | undefined;
  endContent: PollEndContent | undefined;
  updateContent: PollUpdateVotesContent | undefined;
  pollKind: PollKind;
  pollBasicInfo: WebcastPollMessage_PollBasicInfo | undefined;
  templateContent: WebcastPollMessage_TemplateContent | undefined;
}

export interface WebcastPollMessage_TemplateContent {
  templateId: string;
  templateIdStr: string;
  status: PollTemplateStatus;
  pollKind: PollKind;
  appealStatus: PollAppealStatus;
  violationIdStr: string;
}

export interface WebcastPollMessage_PollBasicInfo {
  pollSponsor: string;
  giftId: string;
  title: string;
  isSuggestedQuestion: boolean;
  userCnt: string;
  gift: Gift | undefined;
  pollIdStr: string;
  suggestedQuestionKey: string;
  pollDuration: string;
  timeRemain: string;
  pollIndex: string;
  templateId: string;
}

export interface WebcastRankTextMessage {
  common: CommonMessageData | undefined;
  scene: RankTestMessageScene;
  ownerIdxBeforeUpdate: string;
  ownerIdxAfterUpdate: string;
  selfGetBadgeMsg: Text | undefined;
  otherGetBadgeMsg: Text | undefined;
  curUserId: string;
}

export interface WebcastLinkMicBattlePunishFinish {
  common: CommonMessageData | undefined;
  channelId: string;
  opUid: string;
  reason: Reason;
  battleId: string;
  battleSettings: BattleSetting | undefined;
}

export interface WebcastLinkmicBattleTaskMessage {
  common: CommonMessageData | undefined;
  battleTaskMessageType: BattleTaskMessageType;
  taskStart: WebcastLinkmicBattleTaskMessage_BattleTaskStart | undefined;
  taskUpdate: WebcastLinkmicBattleTaskMessage_BattleTaskUpdate | undefined;
  taskSettle: WebcastLinkmicBattleTaskMessage_BattleTaskSettle | undefined;
  rewardSettle: WebcastLinkmicBattleTaskMessage_BattleRewardSettle | undefined;
  battleId: string;
}

export interface WebcastLinkmicBattleTaskMessage_BattlePrompt {
  promptKey: string;
  promptElements: WebcastLinkmicBattleTaskMessage_BattlePrompt_BattlePromptElem[];
}

export interface WebcastLinkmicBattleTaskMessage_BattlePrompt_BattlePromptElem {
  promptFieldKey: string;
  promptFieldValue: string;
}

export interface WebcastLinkmicBattleTaskMessage_BattleTaskStart {
  battleBonusConfig: WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig | undefined;
}

export interface WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig {
  previewStartTime: string;
  previewPeriodConfig: WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_PreviewPeriod[];
  taskPeriodConfig: WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_TaskPeriodConfig | undefined;
  rewardPeriodConfig: WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_RewardPeriodConfig | undefined;
  taskGiftGuide: {
    [key: string]: WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_BattleTaskGiftAmountGuide;
  };
  previewStartTimestamp: string;
  previewClickActionSchemaUrl: string;
}

export interface WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_TaskGiftGuideEntry {
  key: string;
  value: WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_BattleTaskGiftAmountGuide | undefined;
}

export interface WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_PreviewPeriod {
  duration: string;
  promot: WebcastLinkmicBattleTaskMessage_BattlePrompt | undefined;
  icon: Image | undefined;
}

export interface WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_TaskPeriodConfig {
  taskStartTime: string;
  duration: string;
  targetStartTimestamp: string;
  clickAction: number;
  clickToastPrompt: WebcastLinkmicBattleTaskMessage_BattlePrompt | undefined;
  promptType: number;
  taskStaticPrompt: WebcastLinkmicBattleTaskMessage_BattlePrompt | undefined;
  progressTarget: string;
  targetType: number;
  icon: Image | undefined;
  clickActionSchemaUrl: string;
}

export interface WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_RewardPeriodConfig {
  rewardStartTime: string;
  duration: string;
  rewardMultiple: number;
  rewardStartTimestamp: string;
  rewardPraparePrompt: WebcastLinkmicBattleTaskMessage_BattlePrompt | undefined;
  rewardingPrompt: WebcastLinkmicBattleTaskMessage_BattlePrompt | undefined;
  clickPrompt: WebcastLinkmicBattleTaskMessage_BattlePrompt | undefined;
}

export interface WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_BattleTaskGiftAmountGuide {
  guidePrompt: WebcastLinkmicBattleTaskMessage_BattlePrompt | undefined;
  promptType: number;
  disappearDuration: number;
  iconImage: Image | undefined;
  giftImage: Image | undefined;
  recommendGiftId: string;
  recommendGiftCount: number;
  guideContent: Text | undefined;
}

export interface WebcastLinkmicBattleTaskMessage_BattleTaskUpdate {
  taskProgress: string;
  fromUserUid: string;
  promptKey: string;
  logId: string;
}

export interface WebcastLinkmicBattleTaskMessage_BattleTaskSettle {
  taskResult: WebcastLinkmicBattleTaskMessage_BattleTaskSettle_Result;
  rewardStartTime: string;
  rewardStartTimestamp: string;
}

export enum WebcastLinkmicBattleTaskMessage_BattleTaskSettle_Result {
  RESULT_SUCCEED = 0,
  RESULT_FAILED = 1,
  RESULT_BOTH_SUCCEED = 2,
  UNRECOGNIZED = -1,
}

export interface WebcastLinkmicBattleTaskMessage_BattleRewardSettle {
  rewardSettlePrompt: WebcastLinkmicBattleTaskMessage_BattlePrompt | undefined;
  status: RewardStatus;
}

export interface WebcastLinkMicFanTicketMethod {
  common: CommonMessageData | undefined;
  FanTicketRoomNotice: FanTicketRoomNoticeContent | undefined;
}

export interface WebcastLinkMicMethod {
  common: CommonMessageData | undefined;
  messageType: MessageType;
  accessKey: string;
  anchorLinkmicId: string;
  userId: string;
  fanTicket: string;
  totalLinkMicFanTicket: string;
  channelId: string;
  layout: string;
  vendor: string;
  dimension: string;
  theme: string;
  inviteUid: string;
  reply: number;
  duration: number;
  matchType: number;
  win: boolean;
  prompts: string;
  toUserId: string;
  tips: string;
  startTimeMs: string;
  confluenceType: number;
  fromRoomId: string;
  inviteType: number;
  subType: string;
  rtcExtInfo: string;
  appId: string;
  appSign: string;
  anchorLinkMicIdStr: string;
  rivalAnchorId: string;
  rivalLinkmicId: number;
  rivalLinkmicIdStr: string;
  shouldShowPopup: boolean;
  rtcJoinChannel: boolean;
  fanTicketType: number;
}

export interface WebcastUnauthorizedMemberMessage {
  common: CommonMessageData | undefined;
  action: number;
  nickNamePrefix: Text | undefined;
  nickName: string;
  enterText: Text | undefined;
  publicAreaCommon: PublicAreaMessageCommon | undefined;
}

export interface WebcastMsgDetectMessage {
  common: CommonMessageData | undefined;
  detectType: number;
  triggerCondition: WebcastMsgDetectMessage_TriggerCondition | undefined;
  timeInfo: WebcastMsgDetectMessage_TimeInfo | undefined;
  triggerBy: number;
  fromRegion: string;
}

export interface WebcastMsgDetectMessage_TimeInfo {
  clientStartMs: string;
  apiRecvTimeMs: string;
  apiSendToGoimMs: string;
}

export interface WebcastMsgDetectMessage_TriggerCondition {
  uplinkDetectHttp: boolean;
  uplinkDetectWebSocket: boolean;
  detectP2PMsg: boolean;
  detectRoomMsg: boolean;
  httpOptimize: boolean;
}

export interface WebcastOecLiveShoppingMessage {
  common: CommonMessageData | undefined;
  data1: number;
  shopData:
    | WebcastOecLiveShoppingMessage_LiveShoppingData
    | undefined;
  /** Uses index 1, 2 & 3 */
  shopTimings: TimeStampContainer | undefined;
  details: WebcastOecLiveShoppingMessage_LiveShoppingDetails | undefined;
}

export interface WebcastOecLiveShoppingMessage_LiveShoppingData {
  title: string;
  /** $55.99 */
  priceString: string;
  imageUrl: string;
  shopUrl: string;
  data1: string;
  /** "Shopify" */
  shopName: string;
  data2: string;
  shopUrl2: string;
  data3: string;
  data4: string;
}

export interface WebcastOecLiveShoppingMessage_LiveShoppingDetails {
  id1: string;
  data1: string;
  data2: number;
  timestamp: string;
  data: ValueLabel | undefined;
}

/** Host Pins comment to stream */
export interface WebcastRoomPinMessage {
  common: CommonMessageData | undefined;
  chatMessage?: WebcastChatMessage | undefined;
  socialMessage?: WebcastSocialMessage | undefined;
  giftMessage?: WebcastGiftMessage | undefined;
  memberMessage?: WebcastMemberMessage | undefined;
  likeMessage?: WebcastLikeMessage | undefined;
  method: string;
  pinTime: string;
  operator: User | undefined;
  action: number;
  displayDuration: string;
  pinId: string;
  ecStreamerKey: string;
}

export interface WebcastLinkMessage {
  common: CommonMessageData | undefined;
  MessageType: LinkMessageType;
  LinkerId: string;
  Scene: Scene;
  InviteContent: LinkerInviteContent | undefined;
  ReplyContent: LinkerReplyContent | undefined;
  CreateContent: LinkerCreateContent | undefined;
  CloseContent: LinkerCloseContent | undefined;
  EnterContent: LinkerEnterContent | undefined;
  LeaveContent: LinkerLeaveContent | undefined;
  CancelContent: LinkerCancelContent | undefined;
  KickOutContent: LinkerKickOutContent | undefined;
  LinkedListChangeContent: LinkerLinkedListChangeContent | undefined;
  UpdateUserContent: LinkerUpdateUserContent | undefined;
  WaitingListChangeContent: LinkerWaitingListChangeContent | undefined;
  MuteContent: LinkerMuteContent | undefined;
  RandomMatchContent: LinkerRandomMatchContent | undefined;
  UpdateUserSettingContent: LinkerUpdateUserSettingContent | undefined;
  MicIdxUpdateContent: LinkerMicIdxUpdateContent | undefined;
  ListChangeContent: LinkerListChangeContent | undefined;
  CohostListChangeContent: CohostListChangeContent | undefined;
  MediaChangeContent: LinkerMediaChangeContent | undefined;
  AcceptNoticeContent: LinkerAcceptNoticeContent | undefined;
  SysKickOutContent: LinkerSysKickOutContent | undefined;
  UserToastContent: LinkmicUserToastContent | undefined;
  extra: string;
  expireTimestamp: string;
  transferExtra: string;
}

/** @WebcastLinkLayerMessage */
export interface WebcastLinkLayerMessage {
  common: CommonMessageData | undefined;
  messageType: MessageType;
  channelId: string;
  scene: Scene;
  source: string;
  centerizedIdc: string;
  rtcRoomId: string;
  createChannelContent: CreateChannelContent | undefined;
  listChangeContent: ListChangeContent | undefined;
  inviteContent: InviteContent | undefined;
  applyContent: ApplyContent | undefined;
  permitApplyContent: PermitApplyContent | undefined;
  replyInviteContent: ReplyInviteContent | undefined;
  kickOutContent: KickOutContent | undefined;
  cancelApplyContent: CancelApplyContent | undefined;
  cancelInviteContent: CancelInviteContent | undefined;
  leaveContent: LeaveContent | undefined;
  finishContent: FinishChannelContent | undefined;
  joinDirectContent: JoinDirectContent | undefined;
  joinGroupContent: JoinGroupContent | undefined;
  permitGroupContent: PermitJoinGroupContent | undefined;
  cancelGroupContent: CancelJoinGroupContent | undefined;
  leaveGroupContent: LeaveJoinGroupContent | undefined;
  p2pGroupChangeContent: P2PGroupChangeContent | undefined;
  groupChangeContent: GroupChangeContent | undefined;
  businessContent: BusinessContent | undefined;
}

/** @RoomVerifyMessage */
export interface RoomVerifyMessage {
  common: CommonMessageData | undefined;
  action: number;
  content: string;
  noticeType: string;
  closeRoom: boolean;
}

export interface WebcastBarrageMessageOld {
  event: CommonMessageData | undefined;
  msgType: number;
  content: WebcastBarrageMessageOld_Text | undefined;
}

export interface WebcastBarrageMessageOld_Text {
  key: string;
  defaultPattern: string;
  pieces: WebcastBarrageMessageOld_TextPiece[];
}

export interface WebcastBarrageMessageOld_TextPiece {
  type: number;
  stringValue: string;
  userValue: WebcastBarrageMessageOld_TextPieceUser | undefined;
}

export interface WebcastBarrageMessageOld_TextPieceUser {
  user: User | undefined;
  withColon: boolean;
}

export interface WebcastImEnterRoomMessage {
  /** sent */
  roomId: string;
  /** Not sent, even when there is a hashtag on the room */
  roomTag: string;
  /** not sent */
  liveRegion: string;
  /** "12" <- It's a STATIC value for all streams, I checked the decompiled proto */
  liveId: string;
  /** "audience" */
  identity: string;
  /** "" */
  cursor: string;
  /** 0 */
  accountType: string;
  /** NOT sent */
  enterUniqueId: string;
  /** "0" */
  filterWelcomeMsg: string;
  /** 0 */
  isAnchorContinueKeepMsg: boolean;
}

function createBaseCommonMessageData(): CommonMessageData {
  return {
    method: "",
    msgId: "0",
    roomId: "0",
    createTime: "0",
    monitor: 0,
    isShowMsg: false,
    describe: "",
    displayText: undefined,
    foldType: "0",
    anchorFoldType: "0",
    priorityScore: "0",
    logId: "",
    msgProcessFilterK: "",
    msgProcessFilterV: "",
    fromIdc: "",
    toIdc: "",
    filterMsgTagsList: [],
    sei: undefined,
    dependRootId: undefined,
    dependId: undefined,
    anchorPriorityScore: "0",
    roomMessageHeatLevel: "0",
    foldTypeForWeb: "0",
    anchorFoldTypeForWeb: "0",
    clientSendTime: "0",
    dispatchStrategy: 0,
  };
}

export const CommonMessageDataDecoder: MessageFns<CommonMessageData> = {
  encode(message: CommonMessageData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.method !== "") {
      writer.uint32(10).string(message.method);
    }
    if (message.msgId !== "0") {
      writer.uint32(16).int64(message.msgId);
    }
    if (message.roomId !== "0") {
      writer.uint32(24).int64(message.roomId);
    }
    if (message.createTime !== "0") {
      writer.uint32(32).int64(message.createTime);
    }
    if (message.monitor !== 0) {
      writer.uint32(40).int32(message.monitor);
    }
    if (message.isShowMsg !== false) {
      writer.uint32(48).bool(message.isShowMsg);
    }
    if (message.describe !== "") {
      writer.uint32(58).string(message.describe);
    }
    if (message.displayText !== undefined) {
      TextDecoder.encode(message.displayText, writer.uint32(66).fork()).join();
    }
    if (message.foldType !== "0") {
      writer.uint32(72).int64(message.foldType);
    }
    if (message.anchorFoldType !== "0") {
      writer.uint32(80).int64(message.anchorFoldType);
    }
    if (message.priorityScore !== "0") {
      writer.uint32(88).int64(message.priorityScore);
    }
    if (message.logId !== "") {
      writer.uint32(98).string(message.logId);
    }
    if (message.msgProcessFilterK !== "") {
      writer.uint32(106).string(message.msgProcessFilterK);
    }
    if (message.msgProcessFilterV !== "") {
      writer.uint32(114).string(message.msgProcessFilterV);
    }
    if (message.fromIdc !== "") {
      writer.uint32(122).string(message.fromIdc);
    }
    if (message.toIdc !== "") {
      writer.uint32(130).string(message.toIdc);
    }
    for (const v of message.filterMsgTagsList) {
      writer.uint32(138).string(v!);
    }
    if (message.sei !== undefined) {
      CommonMessageData_LiveMessageSEIDecoder.encode(message.sei, writer.uint32(146).fork()).join();
    }
    if (message.dependRootId !== undefined) {
      CommonMessageData_LiveMessageIDDecoder.encode(message.dependRootId, writer.uint32(154).fork()).join();
    }
    if (message.dependId !== undefined) {
      CommonMessageData_LiveMessageIDDecoder.encode(message.dependId, writer.uint32(162).fork()).join();
    }
    if (message.anchorPriorityScore !== "0") {
      writer.uint32(168).int64(message.anchorPriorityScore);
    }
    if (message.roomMessageHeatLevel !== "0") {
      writer.uint32(176).int64(message.roomMessageHeatLevel);
    }
    if (message.foldTypeForWeb !== "0") {
      writer.uint32(184).int64(message.foldTypeForWeb);
    }
    if (message.anchorFoldTypeForWeb !== "0") {
      writer.uint32(192).int64(message.anchorFoldTypeForWeb);
    }
    if (message.clientSendTime !== "0") {
      writer.uint32(200).int64(message.clientSendTime);
    }
    if (message.dispatchStrategy !== 0) {
      writer.uint32(208).int32(message.dispatchStrategy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommonMessageData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommonMessageData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.method = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.msgId = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.roomId = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.createTime = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.monitor = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isShowMsg = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.describe = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.displayText = TextDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.foldType = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.anchorFoldType = reader.int64().toString();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.priorityScore = reader.int64().toString();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.logId = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.msgProcessFilterK = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.msgProcessFilterV = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.fromIdc = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.toIdc = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.filterMsgTagsList.push(reader.string());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.sei = CommonMessageData_LiveMessageSEIDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.dependRootId = CommonMessageData_LiveMessageIDDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.dependId = CommonMessageData_LiveMessageIDDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.anchorPriorityScore = reader.int64().toString();
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.roomMessageHeatLevel = reader.int64().toString();
          continue;
        }
        case 23: {
          if (tag !== 184) {
            break;
          }

          message.foldTypeForWeb = reader.int64().toString();
          continue;
        }
        case 24: {
          if (tag !== 192) {
            break;
          }

          message.anchorFoldTypeForWeb = reader.int64().toString();
          continue;
        }
        case 25: {
          if (tag !== 200) {
            break;
          }

          message.clientSendTime = reader.int64().toString();
          continue;
        }
        case 26: {
          if (tag !== 208) {
            break;
          }

          message.dispatchStrategy = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCommonMessageData_LiveMessageSEI(): CommonMessageData_LiveMessageSEI {
  return { uniqueId: undefined, timestamp: "0" };
}

export const CommonMessageData_LiveMessageSEIDecoder: MessageFns<CommonMessageData_LiveMessageSEI> = {
  encode(message: CommonMessageData_LiveMessageSEI, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uniqueId !== undefined) {
      CommonMessageData_LiveMessageIDDecoder.encode(message.uniqueId, writer.uint32(10).fork()).join();
    }
    if (message.timestamp !== "0") {
      writer.uint32(16).int64(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommonMessageData_LiveMessageSEI {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommonMessageData_LiveMessageSEI();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.uniqueId = CommonMessageData_LiveMessageIDDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.timestamp = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCommonMessageData_LiveMessageID(): CommonMessageData_LiveMessageID {
  return { primaryId: "", messageScene: "" };
}

export const CommonMessageData_LiveMessageIDDecoder: MessageFns<CommonMessageData_LiveMessageID> = {
  encode(message: CommonMessageData_LiveMessageID, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.primaryId !== "") {
      writer.uint32(10).string(message.primaryId);
    }
    if (message.messageScene !== "") {
      writer.uint32(18).string(message.messageScene);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommonMessageData_LiveMessageID {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommonMessageData_LiveMessageID();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.primaryId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.messageScene = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseText(): Text {
  return { displayType: "", defaultPattern: "", defaultFormat: undefined, piecesList: [] };
}

export const TextDecoder: MessageFns<Text> = {
  encode(message: Text, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayType !== "") {
      writer.uint32(10).string(message.displayType);
    }
    if (message.defaultPattern !== "") {
      writer.uint32(18).string(message.defaultPattern);
    }
    if (message.defaultFormat !== undefined) {
      Text_TextFormatDecoder.encode(message.defaultFormat, writer.uint32(26).fork()).join();
    }
    for (const v of message.piecesList) {
      Text_TextPieceDecoder.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Text {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseText();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.displayType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.defaultPattern = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.defaultFormat = Text_TextFormatDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.piecesList.push(Text_TextPieceDecoder.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseText_TextPiece(): Text_TextPiece {
  return {
    type: 0,
    format: undefined,
    stringValue: "",
    userValue: undefined,
    giftValue: undefined,
    patternRefValue: undefined,
  };
}

export const Text_TextPieceDecoder: MessageFns<Text_TextPiece> = {
  encode(message: Text_TextPiece, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.format !== undefined) {
      Text_TextFormatDecoder.encode(message.format, writer.uint32(18).fork()).join();
    }
    if (message.stringValue !== "") {
      writer.uint32(90).string(message.stringValue);
    }
    if (message.userValue !== undefined) {
      Text_TextPieceUserDecoder.encode(message.userValue, writer.uint32(170).fork()).join();
    }
    if (message.giftValue !== undefined) {
      Text_TextPieceGiftDecoder.encode(message.giftValue, writer.uint32(178).fork()).join();
    }
    if (message.patternRefValue !== undefined) {
      Text_TextPiecePatternRefDecoder.encode(message.patternRefValue, writer.uint32(194).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Text_TextPiece {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseText_TextPiece();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.format = Text_TextFormatDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.stringValue = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.userValue = Text_TextPieceUserDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.giftValue = Text_TextPieceGiftDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.patternRefValue = Text_TextPiecePatternRefDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseText_TextFormat(): Text_TextFormat {
  return {
    color: "",
    bold: false,
    italic: false,
    weight: 0,
    italicAngle: 0,
    fontSize: 0,
    useHeighLightColor: false,
    useRemoteClor: false,
  };
}

export const Text_TextFormatDecoder: MessageFns<Text_TextFormat> = {
  encode(message: Text_TextFormat, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.color !== "") {
      writer.uint32(10).string(message.color);
    }
    if (message.bold !== false) {
      writer.uint32(16).bool(message.bold);
    }
    if (message.italic !== false) {
      writer.uint32(24).bool(message.italic);
    }
    if (message.weight !== 0) {
      writer.uint32(32).int32(message.weight);
    }
    if (message.italicAngle !== 0) {
      writer.uint32(40).int32(message.italicAngle);
    }
    if (message.fontSize !== 0) {
      writer.uint32(48).int32(message.fontSize);
    }
    if (message.useHeighLightColor !== false) {
      writer.uint32(56).bool(message.useHeighLightColor);
    }
    if (message.useRemoteClor !== false) {
      writer.uint32(64).bool(message.useRemoteClor);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Text_TextFormat {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseText_TextFormat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.color = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.bold = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.italic = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.weight = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.italicAngle = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.fontSize = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.useHeighLightColor = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.useRemoteClor = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseText_TextPieceGift(): Text_TextPieceGift {
  return { giftId: 0, nameRef: undefined, showType: 0, colorId: "0" };
}

export const Text_TextPieceGiftDecoder: MessageFns<Text_TextPieceGift> = {
  encode(message: Text_TextPieceGift, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.giftId !== 0) {
      writer.uint32(8).int32(message.giftId);
    }
    if (message.nameRef !== undefined) {
      Text_PatternRefDecoder.encode(message.nameRef, writer.uint32(18).fork()).join();
    }
    if (message.showType !== 0) {
      writer.uint32(24).int32(message.showType);
    }
    if (message.colorId !== "0") {
      writer.uint32(32).int64(message.colorId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Text_TextPieceGift {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseText_TextPieceGift();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.giftId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nameRef = Text_PatternRefDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.showType = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.colorId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseText_TextPiecePatternRef(): Text_TextPiecePatternRef {
  return { key: "", defaultPattern: "" };
}

export const Text_TextPiecePatternRefDecoder: MessageFns<Text_TextPiecePatternRef> = {
  encode(message: Text_TextPiecePatternRef, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.defaultPattern !== "") {
      writer.uint32(18).string(message.defaultPattern);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Text_TextPiecePatternRef {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseText_TextPiecePatternRef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.defaultPattern = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseText_TextPieceUser(): Text_TextPieceUser {
  return { user: undefined, withColon: false };
}

export const Text_TextPieceUserDecoder: MessageFns<Text_TextPieceUser> = {
  encode(message: Text_TextPieceUser, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      UserDecoder.encode(message.user, writer.uint32(10).fork()).join();
    }
    if (message.withColon !== false) {
      writer.uint32(16).bool(message.withColon);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Text_TextPieceUser {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseText_TextPieceUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = UserDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.withColon = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseText_PatternRef(): Text_PatternRef {
  return { key: "", defaultPattern: "" };
}

export const Text_PatternRefDecoder: MessageFns<Text_PatternRef> = {
  encode(message: Text_PatternRef, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.defaultPattern !== "") {
      writer.uint32(18).string(message.defaultPattern);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Text_PatternRef {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseText_PatternRef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.defaultPattern = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseImage(): Image {
  return {
    url: [],
    mUri: "",
    height: 0,
    width: 0,
    avgColor: "",
    imageType: 0,
    schema: "",
    content: undefined,
    isAnimated: false,
  };
}

export const ImageDecoder: MessageFns<Image> = {
  encode(message: Image, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.url) {
      writer.uint32(10).string(v!);
    }
    if (message.mUri !== "") {
      writer.uint32(18).string(message.mUri);
    }
    if (message.height !== 0) {
      writer.uint32(24).int32(message.height);
    }
    if (message.width !== 0) {
      writer.uint32(32).int32(message.width);
    }
    if (message.avgColor !== "") {
      writer.uint32(42).string(message.avgColor);
    }
    if (message.imageType !== 0) {
      writer.uint32(48).int32(message.imageType);
    }
    if (message.schema !== "") {
      writer.uint32(58).string(message.schema);
    }
    if (message.content !== undefined) {
      Image_ContentDecoder.encode(message.content, writer.uint32(66).fork()).join();
    }
    if (message.isAnimated !== false) {
      writer.uint32(72).bool(message.isAnimated);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Image {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.url.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mUri = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.height = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.width = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.avgColor = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.imageType = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.schema = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.content = Image_ContentDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.isAnimated = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseImage_Content(): Image_Content {
  return { name: "", fontColor: "", level: "0" };
}

export const Image_ContentDecoder: MessageFns<Image_Content> = {
  encode(message: Image_Content, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.fontColor !== "") {
      writer.uint32(18).string(message.fontColor);
    }
    if (message.level !== "0") {
      writer.uint32(24).int64(message.level);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Image_Content {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImage_Content();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fontColor = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.level = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBadgeStruct(): BadgeStruct {
  return {
    badgeDisplayType: 0,
    badgePriorityType: 0,
    badgeScene: 0,
    position: 0,
    displayStatus: 0,
    greyedByClient: "0",
    exhibitionType: 0,
    schemaUrl: "",
    display: false,
    logExtra: undefined,
    image: undefined,
    text: undefined,
    str: undefined,
    combine: undefined,
    isCustomized: false,
  };
}

export const BadgeStructDecoder: MessageFns<BadgeStruct> = {
  encode(message: BadgeStruct, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.badgeDisplayType !== 0) {
      writer.uint32(8).int32(message.badgeDisplayType);
    }
    if (message.badgePriorityType !== 0) {
      writer.uint32(16).int32(message.badgePriorityType);
    }
    if (message.badgeScene !== 0) {
      writer.uint32(24).int32(message.badgeScene);
    }
    if (message.position !== 0) {
      writer.uint32(32).int32(message.position);
    }
    if (message.displayStatus !== 0) {
      writer.uint32(40).int32(message.displayStatus);
    }
    if (message.greyedByClient !== "0") {
      writer.uint32(48).int64(message.greyedByClient);
    }
    if (message.exhibitionType !== 0) {
      writer.uint32(56).int32(message.exhibitionType);
    }
    if (message.schemaUrl !== "") {
      writer.uint32(82).string(message.schemaUrl);
    }
    if (message.display !== false) {
      writer.uint32(88).bool(message.display);
    }
    if (message.logExtra !== undefined) {
      PrivilegeLogExtraDecoder.encode(message.logExtra, writer.uint32(98).fork()).join();
    }
    if (message.image !== undefined) {
      BadgeStruct_ImageBadgeDecoder.encode(message.image, writer.uint32(162).fork()).join();
    }
    if (message.text !== undefined) {
      BadgeStruct_TextBadgeDecoder.encode(message.text, writer.uint32(170).fork()).join();
    }
    if (message.str !== undefined) {
      BadgeStruct_StringBadgeDecoder.encode(message.str, writer.uint32(178).fork()).join();
    }
    if (message.combine !== undefined) {
      BadgeStruct_CombineBadgeDecoder.encode(message.combine, writer.uint32(186).fork()).join();
    }
    if (message.isCustomized !== false) {
      writer.uint32(192).bool(message.isCustomized);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BadgeStruct {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBadgeStruct();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.badgeDisplayType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.badgePriorityType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.badgeScene = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.position = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.displayStatus = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.greyedByClient = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.exhibitionType = reader.int32() as any;
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.schemaUrl = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.display = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.logExtra = PrivilegeLogExtraDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.image = BadgeStruct_ImageBadgeDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.text = BadgeStruct_TextBadgeDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.str = BadgeStruct_StringBadgeDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.combine = BadgeStruct_CombineBadgeDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 192) {
            break;
          }

          message.isCustomized = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBadgeStruct_CombineBadge(): BadgeStruct_CombineBadge {
  return {
    badgeDisplayType: 0,
    icon: undefined,
    text: undefined,
    str: "",
    padding: undefined,
    fontStyle: undefined,
    profileCardPanel: undefined,
    background: undefined,
    backgroundDarkMode: undefined,
    iconAutoMirrored: false,
    bgAutoMirrored: false,
    publicScreenShowStyle: 0,
    personalCardShowStyle: 0,
    rankListOnlineAudienceShowStyle: 0,
    multiGuestShowStyle: 0,
    arrowConfig: undefined,
    paddingNewFont: undefined,
  };
}

export const BadgeStruct_CombineBadgeDecoder: MessageFns<BadgeStruct_CombineBadge> = {
  encode(message: BadgeStruct_CombineBadge, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.badgeDisplayType !== 0) {
      writer.uint32(8).int32(message.badgeDisplayType);
    }
    if (message.icon !== undefined) {
      ImageDecoder.encode(message.icon, writer.uint32(18).fork()).join();
    }
    if (message.text !== undefined) {
      BadgeStruct_TextBadgeDecoder.encode(message.text, writer.uint32(26).fork()).join();
    }
    if (message.str !== "") {
      writer.uint32(34).string(message.str);
    }
    if (message.padding !== undefined) {
      BadgeStruct_PaddingInfoDecoder.encode(message.padding, writer.uint32(42).fork()).join();
    }
    if (message.fontStyle !== undefined) {
      FontStyleDecoder.encode(message.fontStyle, writer.uint32(50).fork()).join();
    }
    if (message.profileCardPanel !== undefined) {
      BadgeStruct_ProfileCardPanelDecoder.encode(message.profileCardPanel, writer.uint32(58).fork()).join();
    }
    if (message.background !== undefined) {
      BadgeStruct_CombineBadgeBackgroundDecoder.encode(message.background, writer.uint32(90).fork()).join();
    }
    if (message.backgroundDarkMode !== undefined) {
      BadgeStruct_CombineBadgeBackgroundDecoder.encode(message.backgroundDarkMode, writer.uint32(98).fork()).join();
    }
    if (message.iconAutoMirrored !== false) {
      writer.uint32(104).bool(message.iconAutoMirrored);
    }
    if (message.bgAutoMirrored !== false) {
      writer.uint32(112).bool(message.bgAutoMirrored);
    }
    if (message.publicScreenShowStyle !== 0) {
      writer.uint32(120).int32(message.publicScreenShowStyle);
    }
    if (message.personalCardShowStyle !== 0) {
      writer.uint32(128).int32(message.personalCardShowStyle);
    }
    if (message.rankListOnlineAudienceShowStyle !== 0) {
      writer.uint32(136).int32(message.rankListOnlineAudienceShowStyle);
    }
    if (message.multiGuestShowStyle !== 0) {
      writer.uint32(144).int32(message.multiGuestShowStyle);
    }
    if (message.arrowConfig !== undefined) {
      BadgeStruct_ArrowConfigDecoder.encode(message.arrowConfig, writer.uint32(154).fork()).join();
    }
    if (message.paddingNewFont !== undefined) {
      BadgeStruct_PaddingInfoDecoder.encode(message.paddingNewFont, writer.uint32(162).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BadgeStruct_CombineBadge {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBadgeStruct_CombineBadge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.badgeDisplayType = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.icon = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.text = BadgeStruct_TextBadgeDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.str = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.padding = BadgeStruct_PaddingInfoDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.fontStyle = FontStyleDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.profileCardPanel = BadgeStruct_ProfileCardPanelDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.background = BadgeStruct_CombineBadgeBackgroundDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.backgroundDarkMode = BadgeStruct_CombineBadgeBackgroundDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.iconAutoMirrored = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.bgAutoMirrored = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.publicScreenShowStyle = reader.int32();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.personalCardShowStyle = reader.int32();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.rankListOnlineAudienceShowStyle = reader.int32();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.multiGuestShowStyle = reader.int32();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.arrowConfig = BadgeStruct_ArrowConfigDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.paddingNewFont = BadgeStruct_PaddingInfoDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBadgeStruct_ArrowConfig(): BadgeStruct_ArrowConfig {
  return { icon: undefined };
}

export const BadgeStruct_ArrowConfigDecoder: MessageFns<BadgeStruct_ArrowConfig> = {
  encode(message: BadgeStruct_ArrowConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.icon !== undefined) {
      ImageDecoder.encode(message.icon, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BadgeStruct_ArrowConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBadgeStruct_ArrowConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.icon = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBadgeStruct_ProfileContent(): BadgeStruct_ProfileContent {
  return { useContent: false, iconList: [], numberConfig: undefined };
}

export const BadgeStruct_ProfileContentDecoder: MessageFns<BadgeStruct_ProfileContent> = {
  encode(message: BadgeStruct_ProfileContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.useContent !== false) {
      writer.uint32(8).bool(message.useContent);
    }
    for (const v of message.iconList) {
      BadgeStruct_IconConfigDecoder.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.numberConfig !== undefined) {
      BadgeStruct_NumberConfigDecoder.encode(message.numberConfig, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BadgeStruct_ProfileContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBadgeStruct_ProfileContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.useContent = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.iconList.push(BadgeStruct_IconConfigDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.numberConfig = BadgeStruct_NumberConfigDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBadgeStruct_ProjectionConfig(): BadgeStruct_ProjectionConfig {
  return { useProjection: false, icon: undefined };
}

export const BadgeStruct_ProjectionConfigDecoder: MessageFns<BadgeStruct_ProjectionConfig> = {
  encode(message: BadgeStruct_ProjectionConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.useProjection !== false) {
      writer.uint32(8).bool(message.useProjection);
    }
    if (message.icon !== undefined) {
      ImageDecoder.encode(message.icon, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BadgeStruct_ProjectionConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBadgeStruct_ProjectionConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.useProjection = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.icon = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBadgeStruct_NumberConfig(): BadgeStruct_NumberConfig {
  return { number: "0", fontStyle: undefined, background: undefined };
}

export const BadgeStruct_NumberConfigDecoder: MessageFns<BadgeStruct_NumberConfig> = {
  encode(message: BadgeStruct_NumberConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.number !== "0") {
      writer.uint32(8).int64(message.number);
    }
    if (message.fontStyle !== undefined) {
      FontStyleDecoder.encode(message.fontStyle, writer.uint32(18).fork()).join();
    }
    if (message.background !== undefined) {
      BadgeStruct_CombineBadgeBackgroundDecoder.encode(message.background, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BadgeStruct_NumberConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBadgeStruct_NumberConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.number = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fontStyle = FontStyleDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.background = BadgeStruct_CombineBadgeBackgroundDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBadgeStruct_ProfileCardPanel(): BadgeStruct_ProfileCardPanel {
  return { useNewProfileCardStyle: false, projectionConfig: undefined, profileContent: undefined };
}

export const BadgeStruct_ProfileCardPanelDecoder: MessageFns<BadgeStruct_ProfileCardPanel> = {
  encode(message: BadgeStruct_ProfileCardPanel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.useNewProfileCardStyle !== false) {
      writer.uint32(8).bool(message.useNewProfileCardStyle);
    }
    if (message.projectionConfig !== undefined) {
      BadgeStruct_ProjectionConfigDecoder.encode(message.projectionConfig, writer.uint32(26).fork()).join();
    }
    if (message.profileContent !== undefined) {
      BadgeStruct_ProfileContentDecoder.encode(message.profileContent, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BadgeStruct_ProfileCardPanel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBadgeStruct_ProfileCardPanel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.useNewProfileCardStyle = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.projectionConfig = BadgeStruct_ProjectionConfigDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.profileContent = BadgeStruct_ProfileContentDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBadgeStruct_CombineBadgeBackground(): BadgeStruct_CombineBadgeBackground {
  return { image: undefined, backgroundColorCode: "", borderColorCode: "" };
}

export const BadgeStruct_CombineBadgeBackgroundDecoder: MessageFns<BadgeStruct_CombineBadgeBackground> = {
  encode(message: BadgeStruct_CombineBadgeBackground, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.image !== undefined) {
      ImageDecoder.encode(message.image, writer.uint32(10).fork()).join();
    }
    if (message.backgroundColorCode !== "") {
      writer.uint32(18).string(message.backgroundColorCode);
    }
    if (message.borderColorCode !== "") {
      writer.uint32(26).string(message.borderColorCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BadgeStruct_CombineBadgeBackground {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBadgeStruct_CombineBadgeBackground();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.image = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.backgroundColorCode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.borderColorCode = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBadgeStruct_ImageBadge(): BadgeStruct_ImageBadge {
  return { badgeDisplayType: 0, image: undefined };
}

export const BadgeStruct_ImageBadgeDecoder: MessageFns<BadgeStruct_ImageBadge> = {
  encode(message: BadgeStruct_ImageBadge, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.badgeDisplayType !== 0) {
      writer.uint32(8).int32(message.badgeDisplayType);
    }
    if (message.image !== undefined) {
      ImageDecoder.encode(message.image, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BadgeStruct_ImageBadge {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBadgeStruct_ImageBadge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.badgeDisplayType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.image = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBadgeStruct_TextBadge(): BadgeStruct_TextBadge {
  return { badgeDisplayType: 0, key: "", defaultPattern: "", pieces: [] };
}

export const BadgeStruct_TextBadgeDecoder: MessageFns<BadgeStruct_TextBadge> = {
  encode(message: BadgeStruct_TextBadge, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.badgeDisplayType !== 0) {
      writer.uint32(8).int32(message.badgeDisplayType);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    if (message.defaultPattern !== "") {
      writer.uint32(26).string(message.defaultPattern);
    }
    for (const v of message.pieces) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BadgeStruct_TextBadge {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBadgeStruct_TextBadge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.badgeDisplayType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.defaultPattern = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.pieces.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBadgeStruct_IconConfig(): BadgeStruct_IconConfig {
  return { icon: undefined, background: undefined };
}

export const BadgeStruct_IconConfigDecoder: MessageFns<BadgeStruct_IconConfig> = {
  encode(message: BadgeStruct_IconConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.icon !== undefined) {
      ImageDecoder.encode(message.icon, writer.uint32(10).fork()).join();
    }
    if (message.background !== undefined) {
      BadgeStruct_CombineBadgeBackgroundDecoder.encode(message.background, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BadgeStruct_IconConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBadgeStruct_IconConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.icon = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.background = BadgeStruct_CombineBadgeBackgroundDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBadgeStruct_StringBadge(): BadgeStruct_StringBadge {
  return { badgeDisplayType: 0, str: "" };
}

export const BadgeStruct_StringBadgeDecoder: MessageFns<BadgeStruct_StringBadge> = {
  encode(message: BadgeStruct_StringBadge, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.badgeDisplayType !== 0) {
      writer.uint32(8).int32(message.badgeDisplayType);
    }
    if (message.str !== "") {
      writer.uint32(18).string(message.str);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BadgeStruct_StringBadge {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBadgeStruct_StringBadge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.badgeDisplayType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.str = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBadgeStruct_PaddingInfo(): BadgeStruct_PaddingInfo {
  return {
    useSpecific: false,
    middlePadding: 0,
    badgeWidth: 0,
    leftPadding: 0,
    rightPadding: 0,
    iconTopPadding: 0,
    iconBottomPadding: 0,
    horizontalPaddingRule: 0,
    verticalPaddingRule: 0,
  };
}

export const BadgeStruct_PaddingInfoDecoder: MessageFns<BadgeStruct_PaddingInfo> = {
  encode(message: BadgeStruct_PaddingInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.useSpecific !== false) {
      writer.uint32(8).bool(message.useSpecific);
    }
    if (message.middlePadding !== 0) {
      writer.uint32(16).int32(message.middlePadding);
    }
    if (message.badgeWidth !== 0) {
      writer.uint32(24).int32(message.badgeWidth);
    }
    if (message.leftPadding !== 0) {
      writer.uint32(32).int32(message.leftPadding);
    }
    if (message.rightPadding !== 0) {
      writer.uint32(40).int32(message.rightPadding);
    }
    if (message.iconTopPadding !== 0) {
      writer.uint32(48).int32(message.iconTopPadding);
    }
    if (message.iconBottomPadding !== 0) {
      writer.uint32(56).int32(message.iconBottomPadding);
    }
    if (message.horizontalPaddingRule !== 0) {
      writer.uint32(64).int32(message.horizontalPaddingRule);
    }
    if (message.verticalPaddingRule !== 0) {
      writer.uint32(72).int32(message.verticalPaddingRule);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BadgeStruct_PaddingInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBadgeStruct_PaddingInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.useSpecific = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.middlePadding = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.badgeWidth = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.leftPadding = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.rightPadding = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.iconTopPadding = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.iconBottomPadding = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.horizontalPaddingRule = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.verticalPaddingRule = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGift(): Gift {
  return {
    giftImage: undefined,
    describe: "",
    duration: 0,
    id: "0",
    forLinkMic: false,
    combo: false,
    giftType: 0,
    diamondCount: 0,
    isDisplayedOnPanel: false,
    primaryEffectId: "0",
    giftLabelIcon: undefined,
    giftName: "",
    icon: undefined,
    goldEffect: "",
    previewImage: undefined,
    giftPanelBanner: undefined,
    isBroadcastGift: false,
    isEffectBefview: false,
    isRandomGift: false,
    isBoxGift: false,
    canPutInGiftBox: false,
    giftBoxInfo: undefined,
  };
}

export const GiftDecoder: MessageFns<Gift> = {
  encode(message: Gift, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.giftImage !== undefined) {
      ImageDecoder.encode(message.giftImage, writer.uint32(10).fork()).join();
    }
    if (message.describe !== "") {
      writer.uint32(18).string(message.describe);
    }
    if (message.duration !== 0) {
      writer.uint32(32).int32(message.duration);
    }
    if (message.id !== "0") {
      writer.uint32(40).int64(message.id);
    }
    if (message.forLinkMic !== false) {
      writer.uint32(56).bool(message.forLinkMic);
    }
    if (message.combo !== false) {
      writer.uint32(80).bool(message.combo);
    }
    if (message.giftType !== 0) {
      writer.uint32(88).int32(message.giftType);
    }
    if (message.diamondCount !== 0) {
      writer.uint32(96).int32(message.diamondCount);
    }
    if (message.isDisplayedOnPanel !== false) {
      writer.uint32(104).bool(message.isDisplayedOnPanel);
    }
    if (message.primaryEffectId !== "0") {
      writer.uint32(112).int64(message.primaryEffectId);
    }
    if (message.giftLabelIcon !== undefined) {
      ImageDecoder.encode(message.giftLabelIcon, writer.uint32(122).fork()).join();
    }
    if (message.giftName !== "") {
      writer.uint32(130).string(message.giftName);
    }
    if (message.icon !== undefined) {
      ImageDecoder.encode(message.icon, writer.uint32(170).fork()).join();
    }
    if (message.goldEffect !== "") {
      writer.uint32(194).string(message.goldEffect);
    }
    if (message.previewImage !== undefined) {
      ImageDecoder.encode(message.previewImage, writer.uint32(378).fork()).join();
    }
    if (message.giftPanelBanner !== undefined) {
      Gift_GiftPanelBannerDecoder.encode(message.giftPanelBanner, writer.uint32(386).fork()).join();
    }
    if (message.isBroadcastGift !== false) {
      writer.uint32(392).bool(message.isBroadcastGift);
    }
    if (message.isEffectBefview !== false) {
      writer.uint32(400).bool(message.isEffectBefview);
    }
    if (message.isRandomGift !== false) {
      writer.uint32(408).bool(message.isRandomGift);
    }
    if (message.isBoxGift !== false) {
      writer.uint32(416).bool(message.isBoxGift);
    }
    if (message.canPutInGiftBox !== false) {
      writer.uint32(424).bool(message.canPutInGiftBox);
    }
    if (message.giftBoxInfo !== undefined) {
      Gift_GiftBoxInfoDecoder.encode(message.giftBoxInfo, writer.uint32(434).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Gift {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGift();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.giftImage = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.describe = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.duration = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.id = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.forLinkMic = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.combo = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.giftType = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.diamondCount = reader.int32();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.isDisplayedOnPanel = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.primaryEffectId = reader.int64().toString();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.giftLabelIcon = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.giftName = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.icon = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.goldEffect = reader.string();
          continue;
        }
        case 47: {
          if (tag !== 378) {
            break;
          }

          message.previewImage = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 48: {
          if (tag !== 386) {
            break;
          }

          message.giftPanelBanner = Gift_GiftPanelBannerDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 49: {
          if (tag !== 392) {
            break;
          }

          message.isBroadcastGift = reader.bool();
          continue;
        }
        case 50: {
          if (tag !== 400) {
            break;
          }

          message.isEffectBefview = reader.bool();
          continue;
        }
        case 51: {
          if (tag !== 408) {
            break;
          }

          message.isRandomGift = reader.bool();
          continue;
        }
        case 52: {
          if (tag !== 416) {
            break;
          }

          message.isBoxGift = reader.bool();
          continue;
        }
        case 53: {
          if (tag !== 424) {
            break;
          }

          message.canPutInGiftBox = reader.bool();
          continue;
        }
        case 54: {
          if (tag !== 434) {
            break;
          }

          message.giftBoxInfo = Gift_GiftBoxInfoDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGift_GiftPanelBanner(): Gift_GiftPanelBanner {
  return {
    displayText: undefined,
    leftIcon: undefined,
    schemaUrl: "",
    bgColors: [],
    bannerLynxUrl: "",
    bannerPriority: 0,
    bannerLynxExtra: "",
    bgImage: undefined,
  };
}

export const Gift_GiftPanelBannerDecoder: MessageFns<Gift_GiftPanelBanner> = {
  encode(message: Gift_GiftPanelBanner, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayText !== undefined) {
      TextDecoder.encode(message.displayText, writer.uint32(10).fork()).join();
    }
    if (message.leftIcon !== undefined) {
      ImageDecoder.encode(message.leftIcon, writer.uint32(18).fork()).join();
    }
    if (message.schemaUrl !== "") {
      writer.uint32(26).string(message.schemaUrl);
    }
    for (const v of message.bgColors) {
      writer.uint32(42).string(v!);
    }
    if (message.bannerLynxUrl !== "") {
      writer.uint32(50).string(message.bannerLynxUrl);
    }
    if (message.bannerPriority !== 0) {
      writer.uint32(56).int32(message.bannerPriority);
    }
    if (message.bannerLynxExtra !== "") {
      writer.uint32(66).string(message.bannerLynxExtra);
    }
    if (message.bgImage !== undefined) {
      ImageDecoder.encode(message.bgImage, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Gift_GiftPanelBanner {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGift_GiftPanelBanner();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.displayText = TextDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.leftIcon = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.schemaUrl = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.bgColors.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.bannerLynxUrl = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.bannerPriority = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.bannerLynxExtra = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.bgImage = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGift_BatchGiftInfo(): Gift_BatchGiftInfo {
  return { canBatchSend: false, availableCounts: [] };
}

export const Gift_BatchGiftInfoDecoder: MessageFns<Gift_BatchGiftInfo> = {
  encode(message: Gift_BatchGiftInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.canBatchSend !== false) {
      writer.uint32(8).bool(message.canBatchSend);
    }
    writer.uint32(18).fork();
    for (const v of message.availableCounts) {
      writer.int64(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Gift_BatchGiftInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGift_BatchGiftInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.canBatchSend = reader.bool();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.availableCounts.push(reader.int64().toString());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.availableCounts.push(reader.int64().toString());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGift_CrossScreenEffectInfo(): Gift_CrossScreenEffectInfo {
  return { singleActionEffectIds: {}, actionEffectIds: {}, reactionEffectIds: {} };
}

export const Gift_CrossScreenEffectInfoDecoder: MessageFns<Gift_CrossScreenEffectInfo> = {
  encode(message: Gift_CrossScreenEffectInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.singleActionEffectIds).forEach(([key, value]) => {
      Gift_CrossScreenEffectInfo_SingleActionEffectIdsEntryDecoder.encode({ key: key as any, value }, writer.uint32(10).fork())
        .join();
    });
    Object.entries(message.actionEffectIds).forEach(([key, value]) => {
      Gift_CrossScreenEffectInfo_ActionEffectIdsEntryDecoder.encode({ key: key as any, value }, writer.uint32(18).fork())
        .join();
    });
    Object.entries(message.reactionEffectIds).forEach(([key, value]) => {
      Gift_CrossScreenEffectInfo_ReactionEffectIdsEntryDecoder.encode({ key: key as any, value }, writer.uint32(26).fork())
        .join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Gift_CrossScreenEffectInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGift_CrossScreenEffectInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = Gift_CrossScreenEffectInfo_SingleActionEffectIdsEntryDecoder.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.singleActionEffectIds[entry1.key] = entry1.value;
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = Gift_CrossScreenEffectInfo_ActionEffectIdsEntryDecoder.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.actionEffectIds[entry2.key] = entry2.value;
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = Gift_CrossScreenEffectInfo_ReactionEffectIdsEntryDecoder.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.reactionEffectIds[entry3.key] = entry3.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGift_CrossScreenEffectInfo_SingleActionEffectIdsEntry(): Gift_CrossScreenEffectInfo_SingleActionEffectIdsEntry {
  return { key: "0", value: 0 };
}

export const Gift_CrossScreenEffectInfo_SingleActionEffectIdsEntryDecoder: MessageFns<Gift_CrossScreenEffectInfo_SingleActionEffectIdsEntry> = {
  encode(
    message: Gift_CrossScreenEffectInfo_SingleActionEffectIdsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "0") {
      writer.uint32(8).int64(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Gift_CrossScreenEffectInfo_SingleActionEffectIdsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGift_CrossScreenEffectInfo_SingleActionEffectIdsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGift_CrossScreenEffectInfo_ActionEffectIdsEntry(): Gift_CrossScreenEffectInfo_ActionEffectIdsEntry {
  return { key: "0", value: 0 };
}

export const Gift_CrossScreenEffectInfo_ActionEffectIdsEntryDecoder: MessageFns<Gift_CrossScreenEffectInfo_ActionEffectIdsEntry> = {
  encode(
    message: Gift_CrossScreenEffectInfo_ActionEffectIdsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "0") {
      writer.uint32(8).int64(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Gift_CrossScreenEffectInfo_ActionEffectIdsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGift_CrossScreenEffectInfo_ActionEffectIdsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGift_CrossScreenEffectInfo_ReactionEffectIdsEntry(): Gift_CrossScreenEffectInfo_ReactionEffectIdsEntry {
  return { key: "0", value: 0 };
}

export const Gift_CrossScreenEffectInfo_ReactionEffectIdsEntryDecoder: MessageFns<Gift_CrossScreenEffectInfo_ReactionEffectIdsEntry> = {
  encode(
    message: Gift_CrossScreenEffectInfo_ReactionEffectIdsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "0") {
      writer.uint32(8).int64(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Gift_CrossScreenEffectInfo_ReactionEffectIdsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGift_CrossScreenEffectInfo_ReactionEffectIdsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGift_GiftSponsorInfo(): Gift_GiftSponsorInfo {
  return { sponsorId: "0", sponsorCount: "0", currentCount: "0", leftCountToSponsor: "0", canSponsor: false };
}

export const Gift_GiftSponsorInfoDecoder: MessageFns<Gift_GiftSponsorInfo> = {
  encode(message: Gift_GiftSponsorInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sponsorId !== "0") {
      writer.uint32(8).int64(message.sponsorId);
    }
    if (message.sponsorCount !== "0") {
      writer.uint32(16).int64(message.sponsorCount);
    }
    if (message.currentCount !== "0") {
      writer.uint32(24).int64(message.currentCount);
    }
    if (message.leftCountToSponsor !== "0") {
      writer.uint32(32).int64(message.leftCountToSponsor);
    }
    if (message.canSponsor !== false) {
      writer.uint32(40).bool(message.canSponsor);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Gift_GiftSponsorInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGift_GiftSponsorInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.sponsorId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.sponsorCount = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.currentCount = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.leftCountToSponsor = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.canSponsor = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGift_UGGiftStructInfo(): Gift_UGGiftStructInfo {
  return { isUgGift: false, ugPointsCost: "0" };
}

export const Gift_UGGiftStructInfoDecoder: MessageFns<Gift_UGGiftStructInfo> = {
  encode(message: Gift_UGGiftStructInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isUgGift !== false) {
      writer.uint32(8).bool(message.isUgGift);
    }
    if (message.ugPointsCost !== "0") {
      writer.uint32(16).int64(message.ugPointsCost);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Gift_UGGiftStructInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGift_UGGiftStructInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isUgGift = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.ugPointsCost = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGift_GiftSkin(): Gift_GiftSkin {
  return { giftSkinId: "0", giftSkinName: "", staticImage: undefined, animatedImage: undefined };
}

export const Gift_GiftSkinDecoder: MessageFns<Gift_GiftSkin> = {
  encode(message: Gift_GiftSkin, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.giftSkinId !== "0") {
      writer.uint32(8).int64(message.giftSkinId);
    }
    if (message.giftSkinName !== "") {
      writer.uint32(18).string(message.giftSkinName);
    }
    if (message.staticImage !== undefined) {
      ImageDecoder.encode(message.staticImage, writer.uint32(26).fork()).join();
    }
    if (message.animatedImage !== undefined) {
      ImageDecoder.encode(message.animatedImage, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Gift_GiftSkin {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGift_GiftSkin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.giftSkinId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.giftSkinName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.staticImage = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.animatedImage = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGift_GiftText(): Gift_GiftText {
  return { giftTextId: "0", giftTextName: "" };
}

export const Gift_GiftTextDecoder: MessageFns<Gift_GiftText> = {
  encode(message: Gift_GiftText, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.giftTextId !== "0") {
      writer.uint32(8).int64(message.giftTextId);
    }
    if (message.giftTextName !== "") {
      writer.uint32(18).string(message.giftTextName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Gift_GiftText {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGift_GiftText();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.giftTextId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.giftTextName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGift_GiftSkinToGiftTextsInfo(): Gift_GiftSkinToGiftTextsInfo {
  return { giftSkinId: "0", giftTextIds: [] };
}

export const Gift_GiftSkinToGiftTextsInfoDecoder: MessageFns<Gift_GiftSkinToGiftTextsInfo> = {
  encode(message: Gift_GiftSkinToGiftTextsInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.giftSkinId !== "0") {
      writer.uint32(8).int64(message.giftSkinId);
    }
    writer.uint32(18).fork();
    for (const v of message.giftTextIds) {
      writer.int64(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Gift_GiftSkinToGiftTextsInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGift_GiftSkinToGiftTextsInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.giftSkinId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.giftTextIds.push(reader.int64().toString());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.giftTextIds.push(reader.int64().toString());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGift_GiftBoxInfo(): Gift_GiftBoxInfo {
  return { capacity: "0", isPrimaryBox: false, schemeUrl: "" };
}

export const Gift_GiftBoxInfoDecoder: MessageFns<Gift_GiftBoxInfo> = {
  encode(message: Gift_GiftBoxInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.capacity !== "0") {
      writer.uint32(8).int64(message.capacity);
    }
    if (message.isPrimaryBox !== false) {
      writer.uint32(16).bool(message.isPrimaryBox);
    }
    if (message.schemeUrl !== "") {
      writer.uint32(26).string(message.schemeUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Gift_GiftBoxInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGift_GiftBoxInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.capacity = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isPrimaryBox = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.schemeUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUser(): User {
  return {
    userId: "0",
    nickname: "",
    bioDescription: "",
    profilePicture: undefined,
    profilePictureMedium: undefined,
    profilePictureLarge: undefined,
    verified: false,
    status: 0,
    createTime: "0",
    modifyTime: "0",
    secret: 0,
    shareQrcodeUri: "",
    badgeImageList: [],
    followInfo: undefined,
    userHonor: undefined,
    fansClub: undefined,
    border: undefined,
    specialId: "",
    avatarBorder: undefined,
    medal: undefined,
    userBadges: [],
    newUserBadges: [],
    topVipNo: 0,
    userAttr: undefined,
    ownRoom: undefined,
    payScore: "0",
    fanTicketCount: "0",
    anchorInfo: undefined,
    linkMicStats: 0,
    uniqueId: "",
    enableShowCommerceSale: false,
    withFusionShopEntry: false,
    payScores: "0",
    anchorLevel: undefined,
    verifiedContent: "",
    authorInfo: undefined,
    topFans: [],
    secUid: "",
    userRole: 0,
    rewardInfo: undefined,
    personalCard: undefined,
    authenticationInfo: undefined,
    mediaBadgeImageList: [],
    commerceWebcastConfigIds: [],
    borders: [],
    comboBadgeInfo: undefined,
    subscribeInfo: undefined,
    badges: [],
    mintTypeLabel: [],
    fansClubInfo: undefined,
    allowFindByContacts: false,
    allowOthersDownloadVideo: false,
    allowOthersDownloadWhenSharingVideo: false,
    allowShareShowProfile: false,
    allowShowInGossip: false,
    allowShowMyAction: false,
    allowStrangeComment: false,
    allowUnfollowerComment: false,
    allowUseLinkmic: false,
    avatarJpg: undefined,
    backgroundImgUrl: "",
    blockStatus: 0,
    commentRestrict: 0,
    constellation: "",
    disableIchat: 0,
    enableIchatImg: "0",
    exp: 0,
    foldStrangerChat: false,
    followStatus: "0",
    ichatRestrictType: 0,
    idStr: "",
    isFollower: false,
    isFollowing: false,
    needProfileGuide: false,
    pushCommentStatus: false,
    pushDigg: false,
    pushFollow: false,
    pushFriendAction: false,
    pushIchat: false,
    pushStatus: false,
    pushVideoPost: false,
    pushVideoRecommend: false,
    verifiedReason: "",
    enableCarManagementPermission: false,
    upcomingEventList: [],
    scmLabel: "",
    ecommerceEntrance: undefined,
    isBlock: false,
    isSubscribe: false,
    isAnchorMarked: false,
  };
}

export const UserDecoder: MessageFns<User> = {
  encode(message: User, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "0") {
      writer.uint32(8).int64(message.userId);
    }
    if (message.nickname !== "") {
      writer.uint32(26).string(message.nickname);
    }
    if (message.bioDescription !== "") {
      writer.uint32(42).string(message.bioDescription);
    }
    if (message.profilePicture !== undefined) {
      ImageDecoder.encode(message.profilePicture, writer.uint32(74).fork()).join();
    }
    if (message.profilePictureMedium !== undefined) {
      ImageDecoder.encode(message.profilePictureMedium, writer.uint32(82).fork()).join();
    }
    if (message.profilePictureLarge !== undefined) {
      ImageDecoder.encode(message.profilePictureLarge, writer.uint32(90).fork()).join();
    }
    if (message.verified !== false) {
      writer.uint32(96).bool(message.verified);
    }
    if (message.status !== 0) {
      writer.uint32(120).int32(message.status);
    }
    if (message.createTime !== "0") {
      writer.uint32(128).int64(message.createTime);
    }
    if (message.modifyTime !== "0") {
      writer.uint32(136).int64(message.modifyTime);
    }
    if (message.secret !== 0) {
      writer.uint32(144).int32(message.secret);
    }
    if (message.shareQrcodeUri !== "") {
      writer.uint32(154).string(message.shareQrcodeUri);
    }
    for (const v of message.badgeImageList) {
      ImageDecoder.encode(v!, writer.uint32(170).fork()).join();
    }
    if (message.followInfo !== undefined) {
      User_FollowInfoDecoder.encode(message.followInfo, writer.uint32(178).fork()).join();
    }
    if (message.userHonor !== undefined) {
      UserHonorDecoder.encode(message.userHonor, writer.uint32(186).fork()).join();
    }
    if (message.fansClub !== undefined) {
      FansClubMemberDecoder.encode(message.fansClub, writer.uint32(194).fork()).join();
    }
    if (message.border !== undefined) {
      BorderInfoDecoder.encode(message.border, writer.uint32(202).fork()).join();
    }
    if (message.specialId !== "") {
      writer.uint32(210).string(message.specialId);
    }
    if (message.avatarBorder !== undefined) {
      ImageDecoder.encode(message.avatarBorder, writer.uint32(218).fork()).join();
    }
    if (message.medal !== undefined) {
      ImageDecoder.encode(message.medal, writer.uint32(226).fork()).join();
    }
    for (const v of message.userBadges) {
      ImageDecoder.encode(v!, writer.uint32(234).fork()).join();
    }
    for (const v of message.newUserBadges) {
      ImageDecoder.encode(v!, writer.uint32(242).fork()).join();
    }
    if (message.topVipNo !== 0) {
      writer.uint32(248).int32(message.topVipNo);
    }
    if (message.userAttr !== undefined) {
      User_UserAttrDecoder.encode(message.userAttr, writer.uint32(258).fork()).join();
    }
    if (message.ownRoom !== undefined) {
      User_OwnRoomDecoder.encode(message.ownRoom, writer.uint32(266).fork()).join();
    }
    if (message.payScore !== "0") {
      writer.uint32(272).int64(message.payScore);
    }
    if (message.fanTicketCount !== "0") {
      writer.uint32(280).int64(message.fanTicketCount);
    }
    if (message.anchorInfo !== undefined) {
      User_AnchorLevelDecoder.encode(message.anchorInfo, writer.uint32(290).fork()).join();
    }
    if (message.linkMicStats !== 0) {
      writer.uint32(296).int32(message.linkMicStats);
    }
    if (message.uniqueId !== "") {
      writer.uint32(306).string(message.uniqueId);
    }
    if (message.enableShowCommerceSale !== false) {
      writer.uint32(312).bool(message.enableShowCommerceSale);
    }
    if (message.withFusionShopEntry !== false) {
      writer.uint32(320).bool(message.withFusionShopEntry);
    }
    if (message.payScores !== "0") {
      writer.uint32(328).int64(message.payScores);
    }
    if (message.anchorLevel !== undefined) {
      User_AnchorLevelDecoder.encode(message.anchorLevel, writer.uint32(338).fork()).join();
    }
    if (message.verifiedContent !== "") {
      writer.uint32(346).string(message.verifiedContent);
    }
    if (message.authorInfo !== undefined) {
      AuthorDecoder.encode(message.authorInfo, writer.uint32(354).fork()).join();
    }
    for (const v of message.topFans) {
      UserDecoder.encode(v!, writer.uint32(362).fork()).join();
    }
    if (message.secUid !== "") {
      writer.uint32(370).string(message.secUid);
    }
    if (message.userRole !== 0) {
      writer.uint32(376).int32(message.userRole);
    }
    if (message.rewardInfo !== undefined) {
      User_ActivityInfoDecoder.encode(message.rewardInfo, writer.uint32(394).fork()).join();
    }
    if (message.personalCard !== undefined) {
      ImageDecoder.encode(message.personalCard, writer.uint32(418).fork()).join();
    }
    if (message.authenticationInfo !== undefined) {
      User_AuthenticationInfoDecoder.encode(message.authenticationInfo, writer.uint32(426).fork()).join();
    }
    for (const v of message.mediaBadgeImageList) {
      ImageDecoder.encode(v!, writer.uint32(458).fork()).join();
    }
    writer.uint32(482).fork();
    for (const v of message.commerceWebcastConfigIds) {
      writer.int64(v);
    }
    writer.join();
    for (const v of message.borders) {
      BorderInfoDecoder.encode(v!, writer.uint32(490).fork()).join();
    }
    if (message.comboBadgeInfo !== undefined) {
      User_ComboBadgeInfoDecoder.encode(message.comboBadgeInfo, writer.uint32(498).fork()).join();
    }
    if (message.subscribeInfo !== undefined) {
      User_SubscribeInfoDecoder.encode(message.subscribeInfo, writer.uint32(506).fork()).join();
    }
    for (const v of message.badges) {
      BadgeStructDecoder.encode(v!, writer.uint32(514).fork()).join();
    }
    writer.uint32(522).fork();
    for (const v of message.mintTypeLabel) {
      writer.int64(v);
    }
    writer.join();
    if (message.fansClubInfo !== undefined) {
      User_FansClubInfoDecoder.encode(message.fansClubInfo, writer.uint32(530).fork()).join();
    }
    if (message.allowFindByContacts !== false) {
      writer.uint32(8016).bool(message.allowFindByContacts);
    }
    if (message.allowOthersDownloadVideo !== false) {
      writer.uint32(8024).bool(message.allowOthersDownloadVideo);
    }
    if (message.allowOthersDownloadWhenSharingVideo !== false) {
      writer.uint32(8032).bool(message.allowOthersDownloadWhenSharingVideo);
    }
    if (message.allowShareShowProfile !== false) {
      writer.uint32(8040).bool(message.allowShareShowProfile);
    }
    if (message.allowShowInGossip !== false) {
      writer.uint32(8048).bool(message.allowShowInGossip);
    }
    if (message.allowShowMyAction !== false) {
      writer.uint32(8056).bool(message.allowShowMyAction);
    }
    if (message.allowStrangeComment !== false) {
      writer.uint32(8064).bool(message.allowStrangeComment);
    }
    if (message.allowUnfollowerComment !== false) {
      writer.uint32(8072).bool(message.allowUnfollowerComment);
    }
    if (message.allowUseLinkmic !== false) {
      writer.uint32(8080).bool(message.allowUseLinkmic);
    }
    if (message.avatarJpg !== undefined) {
      ImageDecoder.encode(message.avatarJpg, writer.uint32(8098).fork()).join();
    }
    if (message.backgroundImgUrl !== "") {
      writer.uint32(8106).string(message.backgroundImgUrl);
    }
    if (message.blockStatus !== 0) {
      writer.uint32(8128).int32(message.blockStatus);
    }
    if (message.commentRestrict !== 0) {
      writer.uint32(8136).int32(message.commentRestrict);
    }
    if (message.constellation !== "") {
      writer.uint32(8146).string(message.constellation);
    }
    if (message.disableIchat !== 0) {
      writer.uint32(8152).int32(message.disableIchat);
    }
    if (message.enableIchatImg !== "0") {
      writer.uint32(8160).int64(message.enableIchatImg);
    }
    if (message.exp !== 0) {
      writer.uint32(8168).int32(message.exp);
    }
    if (message.foldStrangerChat !== false) {
      writer.uint32(8184).bool(message.foldStrangerChat);
    }
    if (message.followStatus !== "0") {
      writer.uint32(8192).int64(message.followStatus);
    }
    if (message.ichatRestrictType !== 0) {
      writer.uint32(8216).int32(message.ichatRestrictType);
    }
    if (message.idStr !== "") {
      writer.uint32(8226).string(message.idStr);
    }
    if (message.isFollower !== false) {
      writer.uint32(8232).bool(message.isFollower);
    }
    if (message.isFollowing !== false) {
      writer.uint32(8240).bool(message.isFollowing);
    }
    if (message.needProfileGuide !== false) {
      writer.uint32(8248).bool(message.needProfileGuide);
    }
    if (message.pushCommentStatus !== false) {
      writer.uint32(8264).bool(message.pushCommentStatus);
    }
    if (message.pushDigg !== false) {
      writer.uint32(8272).bool(message.pushDigg);
    }
    if (message.pushFollow !== false) {
      writer.uint32(8280).bool(message.pushFollow);
    }
    if (message.pushFriendAction !== false) {
      writer.uint32(8288).bool(message.pushFriendAction);
    }
    if (message.pushIchat !== false) {
      writer.uint32(8296).bool(message.pushIchat);
    }
    if (message.pushStatus !== false) {
      writer.uint32(8304).bool(message.pushStatus);
    }
    if (message.pushVideoPost !== false) {
      writer.uint32(8312).bool(message.pushVideoPost);
    }
    if (message.pushVideoRecommend !== false) {
      writer.uint32(8320).bool(message.pushVideoRecommend);
    }
    if (message.verifiedReason !== "") {
      writer.uint32(8346).string(message.verifiedReason);
    }
    if (message.enableCarManagementPermission !== false) {
      writer.uint32(8352).bool(message.enableCarManagementPermission);
    }
    for (const v of message.upcomingEventList) {
      User_LiveEventInfoDecoder.encode(v!, writer.uint32(8362).fork()).join();
    }
    if (message.scmLabel !== "") {
      writer.uint32(8370).string(message.scmLabel);
    }
    if (message.ecommerceEntrance !== undefined) {
      User_EcommerceEntranceDecoder.encode(message.ecommerceEntrance, writer.uint32(8378).fork()).join();
    }
    if (message.isBlock !== false) {
      writer.uint32(8384).bool(message.isBlock);
    }
    if (message.isSubscribe !== false) {
      writer.uint32(8720).bool(message.isSubscribe);
    }
    if (message.isAnchorMarked !== false) {
      writer.uint32(8728).bool(message.isAnchorMarked);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nickname = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.bioDescription = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.profilePicture = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.profilePictureMedium = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.profilePictureLarge = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.verified = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.status = reader.int32();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.createTime = reader.int64().toString();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.modifyTime = reader.int64().toString();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.secret = reader.int32();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.shareQrcodeUri = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.badgeImageList.push(ImageDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.followInfo = User_FollowInfoDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.userHonor = UserHonorDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.fansClub = FansClubMemberDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.border = BorderInfoDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.specialId = reader.string();
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.avatarBorder = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.medal = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.userBadges.push(ImageDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.newUserBadges.push(ImageDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 31: {
          if (tag !== 248) {
            break;
          }

          message.topVipNo = reader.int32();
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.userAttr = User_UserAttrDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 33: {
          if (tag !== 266) {
            break;
          }

          message.ownRoom = User_OwnRoomDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 34: {
          if (tag !== 272) {
            break;
          }

          message.payScore = reader.int64().toString();
          continue;
        }
        case 35: {
          if (tag !== 280) {
            break;
          }

          message.fanTicketCount = reader.int64().toString();
          continue;
        }
        case 36: {
          if (tag !== 290) {
            break;
          }

          message.anchorInfo = User_AnchorLevelDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 37: {
          if (tag !== 296) {
            break;
          }

          message.linkMicStats = reader.int32() as any;
          continue;
        }
        case 38: {
          if (tag !== 306) {
            break;
          }

          message.uniqueId = reader.string();
          continue;
        }
        case 39: {
          if (tag !== 312) {
            break;
          }

          message.enableShowCommerceSale = reader.bool();
          continue;
        }
        case 40: {
          if (tag !== 320) {
            break;
          }

          message.withFusionShopEntry = reader.bool();
          continue;
        }
        case 41: {
          if (tag !== 328) {
            break;
          }

          message.payScores = reader.int64().toString();
          continue;
        }
        case 42: {
          if (tag !== 338) {
            break;
          }

          message.anchorLevel = User_AnchorLevelDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 43: {
          if (tag !== 346) {
            break;
          }

          message.verifiedContent = reader.string();
          continue;
        }
        case 44: {
          if (tag !== 354) {
            break;
          }

          message.authorInfo = AuthorDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 45: {
          if (tag !== 362) {
            break;
          }

          message.topFans.push(UserDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 46: {
          if (tag !== 370) {
            break;
          }

          message.secUid = reader.string();
          continue;
        }
        case 47: {
          if (tag !== 376) {
            break;
          }

          message.userRole = reader.int32();
          continue;
        }
        case 49: {
          if (tag !== 394) {
            break;
          }

          message.rewardInfo = User_ActivityInfoDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 52: {
          if (tag !== 418) {
            break;
          }

          message.personalCard = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 53: {
          if (tag !== 426) {
            break;
          }

          message.authenticationInfo = User_AuthenticationInfoDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 57: {
          if (tag !== 458) {
            break;
          }

          message.mediaBadgeImageList.push(ImageDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 60: {
          if (tag === 480) {
            message.commerceWebcastConfigIds.push(reader.int64().toString());

            continue;
          }

          if (tag === 482) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.commerceWebcastConfigIds.push(reader.int64().toString());
            }

            continue;
          }

          break;
        }
        case 61: {
          if (tag !== 490) {
            break;
          }

          message.borders.push(BorderInfoDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 62: {
          if (tag !== 498) {
            break;
          }

          message.comboBadgeInfo = User_ComboBadgeInfoDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 63: {
          if (tag !== 506) {
            break;
          }

          message.subscribeInfo = User_SubscribeInfoDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 64: {
          if (tag !== 514) {
            break;
          }

          message.badges.push(BadgeStructDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 65: {
          if (tag === 520) {
            message.mintTypeLabel.push(reader.int64().toString());

            continue;
          }

          if (tag === 522) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.mintTypeLabel.push(reader.int64().toString());
            }

            continue;
          }

          break;
        }
        case 66: {
          if (tag !== 530) {
            break;
          }

          message.fansClubInfo = User_FansClubInfoDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 1002: {
          if (tag !== 8016) {
            break;
          }

          message.allowFindByContacts = reader.bool();
          continue;
        }
        case 1003: {
          if (tag !== 8024) {
            break;
          }

          message.allowOthersDownloadVideo = reader.bool();
          continue;
        }
        case 1004: {
          if (tag !== 8032) {
            break;
          }

          message.allowOthersDownloadWhenSharingVideo = reader.bool();
          continue;
        }
        case 1005: {
          if (tag !== 8040) {
            break;
          }

          message.allowShareShowProfile = reader.bool();
          continue;
        }
        case 1006: {
          if (tag !== 8048) {
            break;
          }

          message.allowShowInGossip = reader.bool();
          continue;
        }
        case 1007: {
          if (tag !== 8056) {
            break;
          }

          message.allowShowMyAction = reader.bool();
          continue;
        }
        case 1008: {
          if (tag !== 8064) {
            break;
          }

          message.allowStrangeComment = reader.bool();
          continue;
        }
        case 1009: {
          if (tag !== 8072) {
            break;
          }

          message.allowUnfollowerComment = reader.bool();
          continue;
        }
        case 1010: {
          if (tag !== 8080) {
            break;
          }

          message.allowUseLinkmic = reader.bool();
          continue;
        }
        case 1012: {
          if (tag !== 8098) {
            break;
          }

          message.avatarJpg = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 1013: {
          if (tag !== 8106) {
            break;
          }

          message.backgroundImgUrl = reader.string();
          continue;
        }
        case 1016: {
          if (tag !== 8128) {
            break;
          }

          message.blockStatus = reader.int32();
          continue;
        }
        case 1017: {
          if (tag !== 8136) {
            break;
          }

          message.commentRestrict = reader.int32();
          continue;
        }
        case 1018: {
          if (tag !== 8146) {
            break;
          }

          message.constellation = reader.string();
          continue;
        }
        case 1019: {
          if (tag !== 8152) {
            break;
          }

          message.disableIchat = reader.int32();
          continue;
        }
        case 1020: {
          if (tag !== 8160) {
            break;
          }

          message.enableIchatImg = reader.int64().toString();
          continue;
        }
        case 1021: {
          if (tag !== 8168) {
            break;
          }

          message.exp = reader.int32();
          continue;
        }
        case 1023: {
          if (tag !== 8184) {
            break;
          }

          message.foldStrangerChat = reader.bool();
          continue;
        }
        case 1024: {
          if (tag !== 8192) {
            break;
          }

          message.followStatus = reader.int64().toString();
          continue;
        }
        case 1027: {
          if (tag !== 8216) {
            break;
          }

          message.ichatRestrictType = reader.int32();
          continue;
        }
        case 1028: {
          if (tag !== 8226) {
            break;
          }

          message.idStr = reader.string();
          continue;
        }
        case 1029: {
          if (tag !== 8232) {
            break;
          }

          message.isFollower = reader.bool();
          continue;
        }
        case 1030: {
          if (tag !== 8240) {
            break;
          }

          message.isFollowing = reader.bool();
          continue;
        }
        case 1031: {
          if (tag !== 8248) {
            break;
          }

          message.needProfileGuide = reader.bool();
          continue;
        }
        case 1033: {
          if (tag !== 8264) {
            break;
          }

          message.pushCommentStatus = reader.bool();
          continue;
        }
        case 1034: {
          if (tag !== 8272) {
            break;
          }

          message.pushDigg = reader.bool();
          continue;
        }
        case 1035: {
          if (tag !== 8280) {
            break;
          }

          message.pushFollow = reader.bool();
          continue;
        }
        case 1036: {
          if (tag !== 8288) {
            break;
          }

          message.pushFriendAction = reader.bool();
          continue;
        }
        case 1037: {
          if (tag !== 8296) {
            break;
          }

          message.pushIchat = reader.bool();
          continue;
        }
        case 1038: {
          if (tag !== 8304) {
            break;
          }

          message.pushStatus = reader.bool();
          continue;
        }
        case 1039: {
          if (tag !== 8312) {
            break;
          }

          message.pushVideoPost = reader.bool();
          continue;
        }
        case 1040: {
          if (tag !== 8320) {
            break;
          }

          message.pushVideoRecommend = reader.bool();
          continue;
        }
        case 1043: {
          if (tag !== 8346) {
            break;
          }

          message.verifiedReason = reader.string();
          continue;
        }
        case 1044: {
          if (tag !== 8352) {
            break;
          }

          message.enableCarManagementPermission = reader.bool();
          continue;
        }
        case 1045: {
          if (tag !== 8362) {
            break;
          }

          message.upcomingEventList.push(User_LiveEventInfoDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 1046: {
          if (tag !== 8370) {
            break;
          }

          message.scmLabel = reader.string();
          continue;
        }
        case 1047: {
          if (tag !== 8378) {
            break;
          }

          message.ecommerceEntrance = User_EcommerceEntranceDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 1048: {
          if (tag !== 8384) {
            break;
          }

          message.isBlock = reader.bool();
          continue;
        }
        case 1090: {
          if (tag !== 8720) {
            break;
          }

          message.isSubscribe = reader.bool();
          continue;
        }
        case 1091: {
          if (tag !== 8728) {
            break;
          }

          message.isAnchorMarked = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUser_LiveEventInfo(): User_LiveEventInfo {
  return {
    eventId: "0",
    startTime: "0",
    duration: "0",
    title: "",
    description: "",
    hasSubscribed: false,
    isPaidEvent: false,
    ticketAmount: "0",
    payMethod: "0",
  };
}

export const User_LiveEventInfoDecoder: MessageFns<User_LiveEventInfo> = {
  encode(message: User_LiveEventInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventId !== "0") {
      writer.uint32(8).int64(message.eventId);
    }
    if (message.startTime !== "0") {
      writer.uint32(16).int64(message.startTime);
    }
    if (message.duration !== "0") {
      writer.uint32(24).int64(message.duration);
    }
    if (message.title !== "") {
      writer.uint32(34).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.hasSubscribed !== false) {
      writer.uint32(48).bool(message.hasSubscribed);
    }
    if (message.isPaidEvent !== false) {
      writer.uint32(56).bool(message.isPaidEvent);
    }
    if (message.ticketAmount !== "0") {
      writer.uint32(64).int64(message.ticketAmount);
    }
    if (message.payMethod !== "0") {
      writer.uint32(72).int64(message.payMethod);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User_LiveEventInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser_LiveEventInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.eventId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.startTime = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.duration = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.hasSubscribed = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.isPaidEvent = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.ticketAmount = reader.int64().toString();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.payMethod = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUser_LiveEventInfo_WalletPackage(): User_LiveEventInfo_WalletPackage {
  return { iapId: "", usdPriceShow: "" };
}

export const User_LiveEventInfo_WalletPackageDecoder: MessageFns<User_LiveEventInfo_WalletPackage> = {
  encode(message: User_LiveEventInfo_WalletPackage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.iapId !== "") {
      writer.uint32(10).string(message.iapId);
    }
    if (message.usdPriceShow !== "") {
      writer.uint32(18).string(message.usdPriceShow);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User_LiveEventInfo_WalletPackage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser_LiveEventInfo_WalletPackage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.iapId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.usdPriceShow = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUser_ActivityInfo(): User_ActivityInfo {
  return { badge: undefined, storytag: undefined };
}

export const User_ActivityInfoDecoder: MessageFns<User_ActivityInfo> = {
  encode(message: User_ActivityInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.badge !== undefined) {
      ImageDecoder.encode(message.badge, writer.uint32(10).fork()).join();
    }
    if (message.storytag !== undefined) {
      ImageDecoder.encode(message.storytag, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User_ActivityInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser_ActivityInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.badge = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.storytag = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUser_AnchorLevel(): User_AnchorLevel {
  return {
    level: "0",
    experience: "0",
    lowestExperienceThisLevel: "0",
    highestExperienceThisLevel: "0",
    taskStartExperience: "0",
    taskStartTime: "0",
    taskDecreaseExperience: "0",
    taskTargetExperience: "0",
    taskEndTime: "0",
    profileDialogBg: undefined,
    profileDialogBgBack: undefined,
    stageLevel: undefined,
    smallIcon: undefined,
  };
}

export const User_AnchorLevelDecoder: MessageFns<User_AnchorLevel> = {
  encode(message: User_AnchorLevel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.level !== "0") {
      writer.uint32(8).int64(message.level);
    }
    if (message.experience !== "0") {
      writer.uint32(16).int64(message.experience);
    }
    if (message.lowestExperienceThisLevel !== "0") {
      writer.uint32(24).int64(message.lowestExperienceThisLevel);
    }
    if (message.highestExperienceThisLevel !== "0") {
      writer.uint32(32).int64(message.highestExperienceThisLevel);
    }
    if (message.taskStartExperience !== "0") {
      writer.uint32(40).int64(message.taskStartExperience);
    }
    if (message.taskStartTime !== "0") {
      writer.uint32(48).int64(message.taskStartTime);
    }
    if (message.taskDecreaseExperience !== "0") {
      writer.uint32(56).int64(message.taskDecreaseExperience);
    }
    if (message.taskTargetExperience !== "0") {
      writer.uint32(64).int64(message.taskTargetExperience);
    }
    if (message.taskEndTime !== "0") {
      writer.uint32(72).int64(message.taskEndTime);
    }
    if (message.profileDialogBg !== undefined) {
      ImageDecoder.encode(message.profileDialogBg, writer.uint32(82).fork()).join();
    }
    if (message.profileDialogBgBack !== undefined) {
      ImageDecoder.encode(message.profileDialogBgBack, writer.uint32(90).fork()).join();
    }
    if (message.stageLevel !== undefined) {
      ImageDecoder.encode(message.stageLevel, writer.uint32(98).fork()).join();
    }
    if (message.smallIcon !== undefined) {
      ImageDecoder.encode(message.smallIcon, writer.uint32(106).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User_AnchorLevel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser_AnchorLevel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.level = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.experience = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.lowestExperienceThisLevel = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.highestExperienceThisLevel = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.taskStartExperience = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.taskStartTime = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.taskDecreaseExperience = reader.int64().toString();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.taskTargetExperience = reader.int64().toString();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.taskEndTime = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.profileDialogBg = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.profileDialogBgBack = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.stageLevel = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.smallIcon = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUser_AuthenticationInfo(): User_AuthenticationInfo {
  return { customVerify: "", enterpriseVerifyReason: "", authenticationBadge: undefined };
}

export const User_AuthenticationInfoDecoder: MessageFns<User_AuthenticationInfo> = {
  encode(message: User_AuthenticationInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.customVerify !== "") {
      writer.uint32(10).string(message.customVerify);
    }
    if (message.enterpriseVerifyReason !== "") {
      writer.uint32(18).string(message.enterpriseVerifyReason);
    }
    if (message.authenticationBadge !== undefined) {
      ImageDecoder.encode(message.authenticationBadge, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User_AuthenticationInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser_AuthenticationInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.customVerify = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.enterpriseVerifyReason = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.authenticationBadge = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUser_AuthorStats(): User_AuthorStats {
  return {
    videoTotalCount: "0",
    videoTotalPlayCount: "0",
    videoTotalShareCount: "0",
    videoTotalSeriesCount: "0",
    varietyShowPlayCount: "0",
    videoTotalFavoriteCount: "0",
  };
}

export const User_AuthorStatsDecoder: MessageFns<User_AuthorStats> = {
  encode(message: User_AuthorStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.videoTotalCount !== "0") {
      writer.uint32(8).int64(message.videoTotalCount);
    }
    if (message.videoTotalPlayCount !== "0") {
      writer.uint32(16).int64(message.videoTotalPlayCount);
    }
    if (message.videoTotalShareCount !== "0") {
      writer.uint32(24).int64(message.videoTotalShareCount);
    }
    if (message.videoTotalSeriesCount !== "0") {
      writer.uint32(32).int64(message.videoTotalSeriesCount);
    }
    if (message.varietyShowPlayCount !== "0") {
      writer.uint32(40).int64(message.varietyShowPlayCount);
    }
    if (message.videoTotalFavoriteCount !== "0") {
      writer.uint32(48).int64(message.videoTotalFavoriteCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User_AuthorStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser_AuthorStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.videoTotalCount = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.videoTotalPlayCount = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.videoTotalShareCount = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.videoTotalSeriesCount = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.varietyShowPlayCount = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.videoTotalFavoriteCount = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUser_Border(): User_Border {
  return {
    icon: undefined,
    level: "0",
    source: "",
    profileDecorationRibbon: undefined,
    avatarBackgroundColor: "",
    avatarBackgroundBorderColor: "",
  };
}

export const User_BorderDecoder: MessageFns<User_Border> = {
  encode(message: User_Border, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.icon !== undefined) {
      ImageDecoder.encode(message.icon, writer.uint32(10).fork()).join();
    }
    if (message.level !== "0") {
      writer.uint32(16).int64(message.level);
    }
    if (message.source !== "") {
      writer.uint32(26).string(message.source);
    }
    if (message.profileDecorationRibbon !== undefined) {
      ImageDecoder.encode(message.profileDecorationRibbon, writer.uint32(34).fork()).join();
    }
    if (message.avatarBackgroundColor !== "") {
      writer.uint32(58).string(message.avatarBackgroundColor);
    }
    if (message.avatarBackgroundBorderColor !== "") {
      writer.uint32(66).string(message.avatarBackgroundBorderColor);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User_Border {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser_Border();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.icon = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.level = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.source = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.profileDecorationRibbon = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.avatarBackgroundColor = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.avatarBackgroundBorderColor = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUser_ComboBadgeInfo(): User_ComboBadgeInfo {
  return { icon: undefined, comboCount: "0" };
}

export const User_ComboBadgeInfoDecoder: MessageFns<User_ComboBadgeInfo> = {
  encode(message: User_ComboBadgeInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.icon !== undefined) {
      ImageDecoder.encode(message.icon, writer.uint32(10).fork()).join();
    }
    if (message.comboCount !== "0") {
      writer.uint32(16).int64(message.comboCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User_ComboBadgeInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser_ComboBadgeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.icon = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.comboCount = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUser_EcommerceEntrance(): User_EcommerceEntrance {
  return { entranceType: 0, creatorType: 0, schema: "", shopEntranceInfo: undefined, showcaseEntranceInfo: undefined };
}

export const User_EcommerceEntranceDecoder: MessageFns<User_EcommerceEntrance> = {
  encode(message: User_EcommerceEntrance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.entranceType !== 0) {
      writer.uint32(8).int32(message.entranceType);
    }
    if (message.creatorType !== 0) {
      writer.uint32(16).int32(message.creatorType);
    }
    if (message.schema !== "") {
      writer.uint32(26).string(message.schema);
    }
    if (message.shopEntranceInfo !== undefined) {
      User_EcommerceEntrance_ShopEntranceInfoDecoder.encode(message.shopEntranceInfo, writer.uint32(34).fork()).join();
    }
    if (message.showcaseEntranceInfo !== undefined) {
      User_EcommerceEntrance_ShowcaseEntranceInfoDecoder.encode(message.showcaseEntranceInfo, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User_EcommerceEntrance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser_EcommerceEntrance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.entranceType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.creatorType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.schema = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.shopEntranceInfo = User_EcommerceEntrance_ShopEntranceInfoDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.showcaseEntranceInfo = User_EcommerceEntrance_ShowcaseEntranceInfoDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUser_EcommerceEntrance_ShopEntranceInfo(): User_EcommerceEntrance_ShopEntranceInfo {
  return {
    shopId: "",
    shopName: "",
    shopRating: "",
    storeLabel: undefined,
    formatSoldCount: "",
    soldCount: "0",
    expRatePercentile: 0,
    expRateTopDisplay: "",
    rateDisplayStyle: 0,
    showRateNotApplicable: false,
  };
}

export const User_EcommerceEntrance_ShopEntranceInfoDecoder: MessageFns<User_EcommerceEntrance_ShopEntranceInfo> = {
  encode(message: User_EcommerceEntrance_ShopEntranceInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.shopId !== "") {
      writer.uint32(10).string(message.shopId);
    }
    if (message.shopName !== "") {
      writer.uint32(18).string(message.shopName);
    }
    if (message.shopRating !== "") {
      writer.uint32(26).string(message.shopRating);
    }
    if (message.storeLabel !== undefined) {
      User_EcommerceEntrance_ShopEntranceInfo_StoreLabelDecoder.encode(message.storeLabel, writer.uint32(34).fork()).join();
    }
    if (message.formatSoldCount !== "") {
      writer.uint32(42).string(message.formatSoldCount);
    }
    if (message.soldCount !== "0") {
      writer.uint32(48).int64(message.soldCount);
    }
    if (message.expRatePercentile !== 0) {
      writer.uint32(56).int32(message.expRatePercentile);
    }
    if (message.expRateTopDisplay !== "") {
      writer.uint32(66).string(message.expRateTopDisplay);
    }
    if (message.rateDisplayStyle !== 0) {
      writer.uint32(72).int32(message.rateDisplayStyle);
    }
    if (message.showRateNotApplicable !== false) {
      writer.uint32(80).bool(message.showRateNotApplicable);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User_EcommerceEntrance_ShopEntranceInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser_EcommerceEntrance_ShopEntranceInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.shopId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.shopName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.shopRating = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.storeLabel = User_EcommerceEntrance_ShopEntranceInfo_StoreLabelDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.formatSoldCount = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.soldCount = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.expRatePercentile = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.expRateTopDisplay = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.rateDisplayStyle = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.showRateNotApplicable = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUser_EcommerceEntrance_ShopEntranceInfo_StoreLabel(): User_EcommerceEntrance_ShopEntranceInfo_StoreLabel {
  return { officialLabel: undefined, isBytemall: false };
}

export const User_EcommerceEntrance_ShopEntranceInfo_StoreLabelDecoder: MessageFns<User_EcommerceEntrance_ShopEntranceInfo_StoreLabel> = {
  encode(
    message: User_EcommerceEntrance_ShopEntranceInfo_StoreLabel,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.officialLabel !== undefined) {
      User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabelDecoder.encode(
        message.officialLabel,
        writer.uint32(10).fork(),
      ).join();
    }
    if (message.isBytemall !== false) {
      writer.uint32(16).bool(message.isBytemall);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User_EcommerceEntrance_ShopEntranceInfo_StoreLabel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser_EcommerceEntrance_ShopEntranceInfo_StoreLabel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.officialLabel = User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabelDecoder.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isBytemall = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUser_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel(): User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel {
  return { labelImageLight: undefined, labelImageDark: undefined, labelType: "0", labelTypeStr: "" };
}

export const User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabelDecoder: MessageFns<User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel> = {
  encode(
    message: User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.labelImageLight !== undefined) {
      User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel_ShopLabelImageDecoder.encode(
        message.labelImageLight,
        writer.uint32(10).fork(),
      ).join();
    }
    if (message.labelImageDark !== undefined) {
      User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel_ShopLabelImageDecoder.encode(
        message.labelImageDark,
        writer.uint32(18).fork(),
      ).join();
    }
    if (message.labelType !== "0") {
      writer.uint32(24).int64(message.labelType);
    }
    if (message.labelTypeStr !== "") {
      writer.uint32(34).string(message.labelTypeStr);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.labelImageLight = User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel_ShopLabelImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.labelImageDark = User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel_ShopLabelImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.labelType = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.labelTypeStr = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUser_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel_ShopLabelImage(): User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel_ShopLabelImage {
  return { height: 0, width: 0, minetype: "", thumbUri: "", thumbUriList: [], uri: "", urlList: [], color: "" };
}

export const User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel_ShopLabelImageDecoder: MessageFns<User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel_ShopLabelImage> = {
  encode(
    message: User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel_ShopLabelImage,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.height !== 0) {
      writer.uint32(8).int32(message.height);
    }
    if (message.width !== 0) {
      writer.uint32(16).int32(message.width);
    }
    if (message.minetype !== "") {
      writer.uint32(26).string(message.minetype);
    }
    if (message.thumbUri !== "") {
      writer.uint32(34).string(message.thumbUri);
    }
    for (const v of message.thumbUriList) {
      writer.uint32(42).string(v!);
    }
    if (message.uri !== "") {
      writer.uint32(50).string(message.uri);
    }
    for (const v of message.urlList) {
      writer.uint32(58).string(v!);
    }
    if (message.color !== "") {
      writer.uint32(66).string(message.color);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel_ShopLabelImage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel_ShopLabelImage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.height = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.width = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.minetype = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.thumbUri = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.thumbUriList.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.uri = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.urlList.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.color = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUser_EcommerceEntrance_ShowcaseEntranceInfo(): User_EcommerceEntrance_ShowcaseEntranceInfo {
  return { formatSoldCount: "", soldCount: "0" };
}

export const User_EcommerceEntrance_ShowcaseEntranceInfoDecoder: MessageFns<User_EcommerceEntrance_ShowcaseEntranceInfo> = {
  encode(
    message: User_EcommerceEntrance_ShowcaseEntranceInfo,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.formatSoldCount !== "") {
      writer.uint32(10).string(message.formatSoldCount);
    }
    if (message.soldCount !== "0") {
      writer.uint32(16).int64(message.soldCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User_EcommerceEntrance_ShowcaseEntranceInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser_EcommerceEntrance_ShowcaseEntranceInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.formatSoldCount = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.soldCount = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUser_FansClub(): User_FansClub {
  return { data: undefined };
}

export const User_FansClubDecoder: MessageFns<User_FansClub> = {
  encode(message: User_FansClub, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data !== undefined) {
      User_FansClub_FansClubDataDecoder.encode(message.data, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User_FansClub {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser_FansClub();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data = User_FansClub_FansClubDataDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUser_FansClub_FansClubData(): User_FansClub_FansClubData {
  return { clubName: "", level: 0, userFansClubStatus: 0, availableGiftIdsList: [], anchorId: "0" };
}

export const User_FansClub_FansClubDataDecoder: MessageFns<User_FansClub_FansClubData> = {
  encode(message: User_FansClub_FansClubData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clubName !== "") {
      writer.uint32(10).string(message.clubName);
    }
    if (message.level !== 0) {
      writer.uint32(16).int32(message.level);
    }
    if (message.userFansClubStatus !== 0) {
      writer.uint32(24).int32(message.userFansClubStatus);
    }
    writer.uint32(42).fork();
    for (const v of message.availableGiftIdsList) {
      writer.int64(v);
    }
    writer.join();
    if (message.anchorId !== "0") {
      writer.uint32(48).int64(message.anchorId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User_FansClub_FansClubData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser_FansClub_FansClubData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clubName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.level = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.userFansClubStatus = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag === 40) {
            message.availableGiftIdsList.push(reader.int64().toString());

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.availableGiftIdsList.push(reader.int64().toString());
            }

            continue;
          }

          break;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.anchorId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUser_FansClubInfo(): User_FansClubInfo {
  return { isSleeping: false, fansLevel: "0", fansScore: "0", badge: undefined, fansCount: "0", fansClubName: "" };
}

export const User_FansClubInfoDecoder: MessageFns<User_FansClubInfo> = {
  encode(message: User_FansClubInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isSleeping !== false) {
      writer.uint32(8).bool(message.isSleeping);
    }
    if (message.fansLevel !== "0") {
      writer.uint32(16).int64(message.fansLevel);
    }
    if (message.fansScore !== "0") {
      writer.uint32(24).int64(message.fansScore);
    }
    if (message.badge !== undefined) {
      ImageDecoder.encode(message.badge, writer.uint32(34).fork()).join();
    }
    if (message.fansCount !== "0") {
      writer.uint32(40).int64(message.fansCount);
    }
    if (message.fansClubName !== "") {
      writer.uint32(50).string(message.fansClubName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User_FansClubInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser_FansClubInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isSleeping = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.fansLevel = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.fansScore = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.badge = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.fansCount = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.fansClubName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUser_FollowInfo(): User_FollowInfo {
  return { followingCount: "0", followerCount: "0", followStatus: "0", pushStatus: "0" };
}

export const User_FollowInfoDecoder: MessageFns<User_FollowInfo> = {
  encode(message: User_FollowInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.followingCount !== "0") {
      writer.uint32(8).int64(message.followingCount);
    }
    if (message.followerCount !== "0") {
      writer.uint32(16).int64(message.followerCount);
    }
    if (message.followStatus !== "0") {
      writer.uint32(24).int64(message.followStatus);
    }
    if (message.pushStatus !== "0") {
      writer.uint32(32).int64(message.pushStatus);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User_FollowInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser_FollowInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.followingCount = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.followerCount = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.followStatus = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.pushStatus = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUser_OwnRoom(): User_OwnRoom {
  return { roomIdsList: [], roomIdsStrList: [] };
}

export const User_OwnRoomDecoder: MessageFns<User_OwnRoom> = {
  encode(message: User_OwnRoom, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.roomIdsList) {
      writer.int64(v);
    }
    writer.join();
    for (const v of message.roomIdsStrList) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User_OwnRoom {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser_OwnRoom();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.roomIdsList.push(reader.int64().toString());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.roomIdsList.push(reader.int64().toString());
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.roomIdsStrList.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUser_PayGrade(): User_PayGrade {
  return {
    diamondIcon: undefined,
    name: "",
    icon: undefined,
    nextName: "",
    level: "0",
    nextIcon: undefined,
    gradeDescribe: "",
    gradeIconList: [],
    screenChatType: "0",
    imIcon: undefined,
    imIconWithLevel: undefined,
    liveIcon: undefined,
    newImIconWithLevel: undefined,
    newLiveIcon: undefined,
    upgradeNeedConsume: "0",
    nextPrivileges: "",
    background: undefined,
    backgroundBack: undefined,
    score: "0",
    gradeBanner: "",
    profileDialogBg: undefined,
    profileDialogBgBack: undefined,
  };
}

export const User_PayGradeDecoder: MessageFns<User_PayGrade> = {
  encode(message: User_PayGrade, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.diamondIcon !== undefined) {
      ImageDecoder.encode(message.diamondIcon, writer.uint32(18).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.icon !== undefined) {
      ImageDecoder.encode(message.icon, writer.uint32(34).fork()).join();
    }
    if (message.nextName !== "") {
      writer.uint32(42).string(message.nextName);
    }
    if (message.level !== "0") {
      writer.uint32(48).int64(message.level);
    }
    if (message.nextIcon !== undefined) {
      ImageDecoder.encode(message.nextIcon, writer.uint32(58).fork()).join();
    }
    if (message.gradeDescribe !== "") {
      writer.uint32(106).string(message.gradeDescribe);
    }
    for (const v of message.gradeIconList) {
      GradeIconDecoder.encode(v!, writer.uint32(114).fork()).join();
    }
    if (message.screenChatType !== "0") {
      writer.uint32(120).int64(message.screenChatType);
    }
    if (message.imIcon !== undefined) {
      ImageDecoder.encode(message.imIcon, writer.uint32(130).fork()).join();
    }
    if (message.imIconWithLevel !== undefined) {
      ImageDecoder.encode(message.imIconWithLevel, writer.uint32(138).fork()).join();
    }
    if (message.liveIcon !== undefined) {
      ImageDecoder.encode(message.liveIcon, writer.uint32(146).fork()).join();
    }
    if (message.newImIconWithLevel !== undefined) {
      ImageDecoder.encode(message.newImIconWithLevel, writer.uint32(154).fork()).join();
    }
    if (message.newLiveIcon !== undefined) {
      ImageDecoder.encode(message.newLiveIcon, writer.uint32(162).fork()).join();
    }
    if (message.upgradeNeedConsume !== "0") {
      writer.uint32(168).int64(message.upgradeNeedConsume);
    }
    if (message.nextPrivileges !== "") {
      writer.uint32(178).string(message.nextPrivileges);
    }
    if (message.background !== undefined) {
      ImageDecoder.encode(message.background, writer.uint32(186).fork()).join();
    }
    if (message.backgroundBack !== undefined) {
      ImageDecoder.encode(message.backgroundBack, writer.uint32(194).fork()).join();
    }
    if (message.score !== "0") {
      writer.uint32(200).int64(message.score);
    }
    if (message.gradeBanner !== "") {
      writer.uint32(8010).string(message.gradeBanner);
    }
    if (message.profileDialogBg !== undefined) {
      ImageDecoder.encode(message.profileDialogBg, writer.uint32(8018).fork()).join();
    }
    if (message.profileDialogBgBack !== undefined) {
      ImageDecoder.encode(message.profileDialogBgBack, writer.uint32(8026).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User_PayGrade {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser_PayGrade();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.diamondIcon = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.icon = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.nextName = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.level = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.nextIcon = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.gradeDescribe = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.gradeIconList.push(GradeIconDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.screenChatType = reader.int64().toString();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.imIcon = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.imIconWithLevel = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.liveIcon = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.newImIconWithLevel = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.newLiveIcon = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.upgradeNeedConsume = reader.int64().toString();
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.nextPrivileges = reader.string();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.background = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.backgroundBack = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 25: {
          if (tag !== 200) {
            break;
          }

          message.score = reader.int64().toString();
          continue;
        }
        case 1001: {
          if (tag !== 8010) {
            break;
          }

          message.gradeBanner = reader.string();
          continue;
        }
        case 1002: {
          if (tag !== 8018) {
            break;
          }

          message.profileDialogBg = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 1003: {
          if (tag !== 8026) {
            break;
          }

          message.profileDialogBgBack = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUser_SubscribeBadge(): User_SubscribeBadge {
  return { originImg: undefined, previewImg: undefined };
}

export const User_SubscribeBadgeDecoder: MessageFns<User_SubscribeBadge> = {
  encode(message: User_SubscribeBadge, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.originImg !== undefined) {
      ImageDecoder.encode(message.originImg, writer.uint32(26).fork()).join();
    }
    if (message.previewImg !== undefined) {
      ImageDecoder.encode(message.previewImg, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User_SubscribeBadge {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser_SubscribeBadge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.originImg = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.previewImg = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUser_SubscribeInfo(): User_SubscribeInfo {
  return {
    qualification: false,
    isSubscribe: false,
    badge: undefined,
    enableSubscription: false,
    subscriberCount: "0",
    isInGracePeriod: false,
    isSubscribedToAnchor: false,
    userGiftSubAuth: false,
    anchorGiftSubAuth: false,
  };
}

export const User_SubscribeInfoDecoder: MessageFns<User_SubscribeInfo> = {
  encode(message: User_SubscribeInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.qualification !== false) {
      writer.uint32(8).bool(message.qualification);
    }
    if (message.isSubscribe !== false) {
      writer.uint32(16).bool(message.isSubscribe);
    }
    if (message.badge !== undefined) {
      User_SubscribeBadgeDecoder.encode(message.badge, writer.uint32(26).fork()).join();
    }
    if (message.enableSubscription !== false) {
      writer.uint32(32).bool(message.enableSubscription);
    }
    if (message.subscriberCount !== "0") {
      writer.uint32(40).int64(message.subscriberCount);
    }
    if (message.isInGracePeriod !== false) {
      writer.uint32(48).bool(message.isInGracePeriod);
    }
    if (message.isSubscribedToAnchor !== false) {
      writer.uint32(56).bool(message.isSubscribedToAnchor);
    }
    if (message.userGiftSubAuth !== false) {
      writer.uint32(72).bool(message.userGiftSubAuth);
    }
    if (message.anchorGiftSubAuth !== false) {
      writer.uint32(80).bool(message.anchorGiftSubAuth);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User_SubscribeInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser_SubscribeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.qualification = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isSubscribe = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.badge = User_SubscribeBadgeDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.enableSubscription = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.subscriberCount = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isInGracePeriod = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.isSubscribedToAnchor = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.userGiftSubAuth = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.anchorGiftSubAuth = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUser_UserAttr(): User_UserAttr {
  return { isMuted: false, isAdmin: false, isSuperAdmin: false, muteDuration: "0" };
}

export const User_UserAttrDecoder: MessageFns<User_UserAttr> = {
  encode(message: User_UserAttr, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isMuted !== false) {
      writer.uint32(8).bool(message.isMuted);
    }
    if (message.isAdmin !== false) {
      writer.uint32(16).bool(message.isAdmin);
    }
    if (message.isSuperAdmin !== false) {
      writer.uint32(24).bool(message.isSuperAdmin);
    }
    if (message.muteDuration !== "0") {
      writer.uint32(32).int64(message.muteDuration);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User_UserAttr {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser_UserAttr();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isMuted = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isAdmin = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isSuperAdmin = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.muteDuration = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUser_UserStats(): User_UserStats {
  return {
    id: "0",
    idStr: "",
    followingCount: "0",
    followerCount: "0",
    recordCount: "0",
    totalDuration: "0",
    dailyFanTicketCount: "0",
    dailyIncome: "0",
    itemCount: "0",
    favoriteItemCount: "0",
    diamondConsumedCount: "0",
    tuwenItemCount: "0",
  };
}

export const User_UserStatsDecoder: MessageFns<User_UserStats> = {
  encode(message: User_UserStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "0") {
      writer.uint32(8).int64(message.id);
    }
    if (message.idStr !== "") {
      writer.uint32(18).string(message.idStr);
    }
    if (message.followingCount !== "0") {
      writer.uint32(24).int64(message.followingCount);
    }
    if (message.followerCount !== "0") {
      writer.uint32(32).int64(message.followerCount);
    }
    if (message.recordCount !== "0") {
      writer.uint32(40).int64(message.recordCount);
    }
    if (message.totalDuration !== "0") {
      writer.uint32(48).int64(message.totalDuration);
    }
    if (message.dailyFanTicketCount !== "0") {
      writer.uint32(56).int64(message.dailyFanTicketCount);
    }
    if (message.dailyIncome !== "0") {
      writer.uint32(64).int64(message.dailyIncome);
    }
    if (message.itemCount !== "0") {
      writer.uint32(72).int64(message.itemCount);
    }
    if (message.favoriteItemCount !== "0") {
      writer.uint32(80).int64(message.favoriteItemCount);
    }
    if (message.diamondConsumedCount !== "0") {
      writer.uint32(96).int64(message.diamondConsumedCount);
    }
    if (message.tuwenItemCount !== "0") {
      writer.uint32(104).int64(message.tuwenItemCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User_UserStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser_UserStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.idStr = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.followingCount = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.followerCount = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.recordCount = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.totalDuration = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.dailyFanTicketCount = reader.int64().toString();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.dailyIncome = reader.int64().toString();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.itemCount = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.favoriteItemCount = reader.int64().toString();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.diamondConsumedCount = reader.int64().toString();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.tuwenItemCount = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseEmote(): Emote {
  return {
    emoteId: "",
    image: undefined,
    auditStatus: 0,
    uuid: "",
    emoteType: 0,
    contentSource: 0,
    emotePrivateType: 0,
    packageId: "",
    auditInfo: undefined,
    rewardCondition: 0,
    emoteUploadInfo: undefined,
    createTime: "0",
    emoteScene: 0,
  };
}

export const EmoteDecoder: MessageFns<Emote> = {
  encode(message: Emote, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.emoteId !== "") {
      writer.uint32(10).string(message.emoteId);
    }
    if (message.image !== undefined) {
      ImageDecoder.encode(message.image, writer.uint32(18).fork()).join();
    }
    if (message.auditStatus !== 0) {
      writer.uint32(24).int32(message.auditStatus);
    }
    if (message.uuid !== "") {
      writer.uint32(34).string(message.uuid);
    }
    if (message.emoteType !== 0) {
      writer.uint32(40).int32(message.emoteType);
    }
    if (message.contentSource !== 0) {
      writer.uint32(48).int32(message.contentSource);
    }
    if (message.emotePrivateType !== 0) {
      writer.uint32(56).int32(message.emotePrivateType);
    }
    if (message.packageId !== "") {
      writer.uint32(66).string(message.packageId);
    }
    if (message.auditInfo !== undefined) {
      Emote_AuditInfoDecoder.encode(message.auditInfo, writer.uint32(74).fork()).join();
    }
    if (message.rewardCondition !== 0) {
      writer.uint32(80).int32(message.rewardCondition);
    }
    if (message.emoteUploadInfo !== undefined) {
      Emote_EmoteUploadInfoDecoder.encode(message.emoteUploadInfo, writer.uint32(90).fork()).join();
    }
    if (message.createTime !== "0") {
      writer.uint32(96).int64(message.createTime);
    }
    if (message.emoteScene !== 0) {
      writer.uint32(104).int32(message.emoteScene);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Emote {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmote();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.emoteId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.image = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.auditStatus = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.uuid = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.emoteType = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.contentSource = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.emotePrivateType = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.packageId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.auditInfo = Emote_AuditInfoDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.rewardCondition = reader.int32() as any;
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.emoteUploadInfo = Emote_EmoteUploadInfoDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.createTime = reader.int64().toString();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.emoteScene = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseEmote_AuditInfo(): Emote_AuditInfo {
  return { violationId: "0", taskType: 0 };
}

export const Emote_AuditInfoDecoder: MessageFns<Emote_AuditInfo> = {
  encode(message: Emote_AuditInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.violationId !== "0") {
      writer.uint32(8).int64(message.violationId);
    }
    if (message.taskType !== 0) {
      writer.uint32(16).int32(message.taskType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Emote_AuditInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmote_AuditInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.violationId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.taskType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseEmote_EmoteUploadInfo(): Emote_EmoteUploadInfo {
  return { userId: "0", emoteUploadSource: 0, userInfo: undefined, userIdStr: "" };
}

export const Emote_EmoteUploadInfoDecoder: MessageFns<Emote_EmoteUploadInfo> = {
  encode(message: Emote_EmoteUploadInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "0") {
      writer.uint32(8).int64(message.userId);
    }
    if (message.emoteUploadSource !== 0) {
      writer.uint32(16).int32(message.emoteUploadSource);
    }
    if (message.userInfo !== undefined) {
      UserDecoder.encode(message.userInfo, writer.uint32(26).fork()).join();
    }
    if (message.userIdStr !== "") {
      writer.uint32(34).string(message.userIdStr);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Emote_EmoteUploadInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmote_EmoteUploadInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.emoteUploadSource = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userInfo = UserDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userIdStr = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePunishEventInfo(): PunishEventInfo {
  return {
    punishType: "",
    punishReason: "",
    punishId: "",
    violationUid: "0",
    punishTypeId: 0,
    duration: "0",
    punishPerceptionCode: "",
    violationUidStr: "",
    showReason: "",
  };
}

export const PunishEventInfoDecoder: MessageFns<PunishEventInfo> = {
  encode(message: PunishEventInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.punishType !== "") {
      writer.uint32(10).string(message.punishType);
    }
    if (message.punishReason !== "") {
      writer.uint32(18).string(message.punishReason);
    }
    if (message.punishId !== "") {
      writer.uint32(26).string(message.punishId);
    }
    if (message.violationUid !== "0") {
      writer.uint32(32).int64(message.violationUid);
    }
    if (message.punishTypeId !== 0) {
      writer.uint32(40).int32(message.punishTypeId);
    }
    if (message.duration !== "0") {
      writer.uint32(48).int64(message.duration);
    }
    if (message.punishPerceptionCode !== "") {
      writer.uint32(58).string(message.punishPerceptionCode);
    }
    if (message.violationUidStr !== "") {
      writer.uint32(74).string(message.violationUidStr);
    }
    if (message.showReason !== "") {
      writer.uint32(82).string(message.showReason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PunishEventInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePunishEventInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.punishType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.punishReason = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.punishId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.violationUid = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.punishTypeId = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.duration = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.punishPerceptionCode = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.violationUidStr = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.showReason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseMsgFilter(): MsgFilter {
  return { isGifter: false, isSubscribedToAnchor: false };
}

export const MsgFilterDecoder: MessageFns<MsgFilter> = {
  encode(message: MsgFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isGifter !== false) {
      writer.uint32(8).bool(message.isGifter);
    }
    if (message.isSubscribedToAnchor !== false) {
      writer.uint32(16).bool(message.isSubscribedToAnchor);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isGifter = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isSubscribedToAnchor = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUserIdentity(): UserIdentity {
  return {
    isGiftGiverOfAnchor: false,
    isSubscriberOfAnchor: false,
    isMutualFollowingWithAnchor: false,
    isFollowerOfAnchor: false,
    isModeratorOfAnchor: false,
    isAnchor: false,
  };
}

export const UserIdentityDecoder: MessageFns<UserIdentity> = {
  encode(message: UserIdentity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isGiftGiverOfAnchor !== false) {
      writer.uint32(8).bool(message.isGiftGiverOfAnchor);
    }
    if (message.isSubscriberOfAnchor !== false) {
      writer.uint32(16).bool(message.isSubscriberOfAnchor);
    }
    if (message.isMutualFollowingWithAnchor !== false) {
      writer.uint32(24).bool(message.isMutualFollowingWithAnchor);
    }
    if (message.isFollowerOfAnchor !== false) {
      writer.uint32(32).bool(message.isFollowerOfAnchor);
    }
    if (message.isModeratorOfAnchor !== false) {
      writer.uint32(40).bool(message.isModeratorOfAnchor);
    }
    if (message.isAnchor !== false) {
      writer.uint32(48).bool(message.isAnchor);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserIdentity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserIdentity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isGiftGiverOfAnchor = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isSubscriberOfAnchor = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isMutualFollowingWithAnchor = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isFollowerOfAnchor = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isModeratorOfAnchor = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isAnchor = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLiveStreamGoal(): LiveStreamGoal {
  return {
    id: "0",
    type: 0,
    status: 0,
    subGoals: [],
    description: "",
    auditStatus: 0,
    cycleType: 0,
    startTime: "0",
    expireTime: "0",
    realFinishTime: "0",
    contributors: [],
    contributorsLength: 0,
    idStr: "",
    auditDescription: "",
    stats: undefined,
    goalExtraInfo: "",
    mode: 0,
    auditInfo: undefined,
    challengeType: "",
    isUneditable: false,
  };
}

export const LiveStreamGoalDecoder: MessageFns<LiveStreamGoal> = {
  encode(message: LiveStreamGoal, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "0") {
      writer.uint32(8).int64(message.id);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    for (const v of message.subGoals) {
      LiveStreamGoal_LiveStreamSubGoalDecoder.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.auditStatus !== 0) {
      writer.uint32(48).int32(message.auditStatus);
    }
    if (message.cycleType !== 0) {
      writer.uint32(56).int32(message.cycleType);
    }
    if (message.startTime !== "0") {
      writer.uint32(64).int64(message.startTime);
    }
    if (message.expireTime !== "0") {
      writer.uint32(72).int64(message.expireTime);
    }
    if (message.realFinishTime !== "0") {
      writer.uint32(80).int64(message.realFinishTime);
    }
    for (const v of message.contributors) {
      LiveStreamGoal_LiveStreamGoalContributorDecoder.encode(v!, writer.uint32(90).fork()).join();
    }
    if (message.contributorsLength !== 0) {
      writer.uint32(96).int32(message.contributorsLength);
    }
    if (message.idStr !== "") {
      writer.uint32(106).string(message.idStr);
    }
    if (message.auditDescription !== "") {
      writer.uint32(114).string(message.auditDescription);
    }
    if (message.stats !== undefined) {
      LiveStreamGoal_GoalStatsDecoder.encode(message.stats, writer.uint32(122).fork()).join();
    }
    if (message.goalExtraInfo !== "") {
      writer.uint32(130).string(message.goalExtraInfo);
    }
    if (message.mode !== 0) {
      writer.uint32(136).int32(message.mode);
    }
    if (message.auditInfo !== undefined) {
      LiveStreamGoal_AuditInfoDecoder.encode(message.auditInfo, writer.uint32(146).fork()).join();
    }
    if (message.challengeType !== "") {
      writer.uint32(162).string(message.challengeType);
    }
    if (message.isUneditable !== false) {
      writer.uint32(168).bool(message.isUneditable);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LiveStreamGoal {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLiveStreamGoal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.status = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.subGoals.push(LiveStreamGoal_LiveStreamSubGoalDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.auditStatus = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.cycleType = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.startTime = reader.int64().toString();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.expireTime = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.realFinishTime = reader.int64().toString();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.contributors.push(LiveStreamGoal_LiveStreamGoalContributorDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.contributorsLength = reader.int32();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.idStr = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.auditDescription = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.stats = LiveStreamGoal_GoalStatsDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.goalExtraInfo = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.mode = reader.int32();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.auditInfo = LiveStreamGoal_AuditInfoDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.challengeType = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.isUneditable = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLiveStreamGoal_AuditInfo(): LiveStreamGoal_AuditInfo {
  return { violationId: "0", taskType: 0 };
}

export const LiveStreamGoal_AuditInfoDecoder: MessageFns<LiveStreamGoal_AuditInfo> = {
  encode(message: LiveStreamGoal_AuditInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.violationId !== "0") {
      writer.uint32(8).int64(message.violationId);
    }
    if (message.taskType !== 0) {
      writer.uint32(16).int32(message.taskType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LiveStreamGoal_AuditInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLiveStreamGoal_AuditInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.violationId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.taskType = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLiveStreamGoal_LiveStreamSubGoal(): LiveStreamGoal_LiveStreamSubGoal {
  return {
    type: 0,
    id: "0",
    progress: "0",
    target: "0",
    gift: undefined,
    idStr: "",
    pinInfo: undefined,
    source: 0,
    recommendedText: "",
    recommendedHeader: "",
  };
}

export const LiveStreamGoal_LiveStreamSubGoalDecoder: MessageFns<LiveStreamGoal_LiveStreamSubGoal> = {
  encode(message: LiveStreamGoal_LiveStreamSubGoal, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.id !== "0") {
      writer.uint32(16).int64(message.id);
    }
    if (message.progress !== "0") {
      writer.uint32(24).int64(message.progress);
    }
    if (message.target !== "0") {
      writer.uint32(32).int64(message.target);
    }
    if (message.gift !== undefined) {
      LiveStreamGoal_LiveStreamSubGoalGiftDecoder.encode(message.gift, writer.uint32(42).fork()).join();
    }
    if (message.idStr !== "") {
      writer.uint32(50).string(message.idStr);
    }
    if (message.pinInfo !== undefined) {
      LiveStreamGoal_LiveStreamSubGoal_SubGoalPinInfoDecoder.encode(message.pinInfo, writer.uint32(58).fork()).join();
    }
    if (message.source !== 0) {
      writer.uint32(64).int32(message.source);
    }
    if (message.recommendedText !== "") {
      writer.uint32(74).string(message.recommendedText);
    }
    if (message.recommendedHeader !== "") {
      writer.uint32(82).string(message.recommendedHeader);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LiveStreamGoal_LiveStreamSubGoal {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLiveStreamGoal_LiveStreamSubGoal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.id = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.progress = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.target = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.gift = LiveStreamGoal_LiveStreamSubGoalGiftDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.idStr = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.pinInfo = LiveStreamGoal_LiveStreamSubGoal_SubGoalPinInfoDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.source = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.recommendedText = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.recommendedHeader = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLiveStreamGoal_LiveStreamSubGoal_SubGoalPinInfo(): LiveStreamGoal_LiveStreamSubGoal_SubGoalPinInfo {
  return { pinStartTime: "0", pinEndTime: "0", pinReadyTime: "0" };
}

export const LiveStreamGoal_LiveStreamSubGoal_SubGoalPinInfoDecoder: MessageFns<LiveStreamGoal_LiveStreamSubGoal_SubGoalPinInfo> = {
  encode(
    message: LiveStreamGoal_LiveStreamSubGoal_SubGoalPinInfo,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.pinStartTime !== "0") {
      writer.uint32(8).int64(message.pinStartTime);
    }
    if (message.pinEndTime !== "0") {
      writer.uint32(16).int64(message.pinEndTime);
    }
    if (message.pinReadyTime !== "0") {
      writer.uint32(24).int64(message.pinReadyTime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LiveStreamGoal_LiveStreamSubGoal_SubGoalPinInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLiveStreamGoal_LiveStreamSubGoal_SubGoalPinInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.pinStartTime = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pinEndTime = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pinReadyTime = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLiveStreamGoal_LiveStreamSubGoalGift(): LiveStreamGoal_LiveStreamSubGoalGift {
  return { name: "", icon: undefined, diamondCount: "0", type: 0 };
}

export const LiveStreamGoal_LiveStreamSubGoalGiftDecoder: MessageFns<LiveStreamGoal_LiveStreamSubGoalGift> = {
  encode(message: LiveStreamGoal_LiveStreamSubGoalGift, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.icon !== undefined) {
      ImageDecoder.encode(message.icon, writer.uint32(18).fork()).join();
    }
    if (message.diamondCount !== "0") {
      writer.uint32(24).int64(message.diamondCount);
    }
    if (message.type !== 0) {
      writer.uint32(32).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LiveStreamGoal_LiveStreamSubGoalGift {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLiveStreamGoal_LiveStreamSubGoalGift();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.icon = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.diamondCount = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.type = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLiveStreamGoal_LiveStreamGoalContributor(): LiveStreamGoal_LiveStreamGoalContributor {
  return {
    userId: "0",
    avatar: undefined,
    displayId: "",
    score: "0",
    userIdStr: "",
    inRoom: false,
    isFriend: false,
    followByOwner: false,
    isFistContribute: false,
    subGoalContributions: [],
  };
}

export const LiveStreamGoal_LiveStreamGoalContributorDecoder: MessageFns<LiveStreamGoal_LiveStreamGoalContributor> = {
  encode(message: LiveStreamGoal_LiveStreamGoalContributor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "0") {
      writer.uint32(8).int64(message.userId);
    }
    if (message.avatar !== undefined) {
      ImageDecoder.encode(message.avatar, writer.uint32(18).fork()).join();
    }
    if (message.displayId !== "") {
      writer.uint32(26).string(message.displayId);
    }
    if (message.score !== "0") {
      writer.uint32(32).int64(message.score);
    }
    if (message.userIdStr !== "") {
      writer.uint32(42).string(message.userIdStr);
    }
    if (message.inRoom !== false) {
      writer.uint32(48).bool(message.inRoom);
    }
    if (message.isFriend !== false) {
      writer.uint32(56).bool(message.isFriend);
    }
    if (message.followByOwner !== false) {
      writer.uint32(72).bool(message.followByOwner);
    }
    if (message.isFistContribute !== false) {
      writer.uint32(80).bool(message.isFistContribute);
    }
    for (const v of message.subGoalContributions) {
      LiveStreamGoal_LiveStreamGoalContributor_SubGoalContributionDecoder.encode(v!, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LiveStreamGoal_LiveStreamGoalContributor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLiveStreamGoal_LiveStreamGoalContributor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.avatar = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.displayId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.score = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.userIdStr = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.inRoom = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.isFriend = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.followByOwner = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.isFistContribute = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.subGoalContributions.push(
            LiveStreamGoal_LiveStreamGoalContributor_SubGoalContributionDecoder.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLiveStreamGoal_LiveStreamGoalContributor_SubGoalContribution(): LiveStreamGoal_LiveStreamGoalContributor_SubGoalContribution {
  return { id: "", contributionCount: "0" };
}

export const LiveStreamGoal_LiveStreamGoalContributor_SubGoalContributionDecoder: MessageFns<LiveStreamGoal_LiveStreamGoalContributor_SubGoalContribution> = {
  encode(
    message: LiveStreamGoal_LiveStreamGoalContributor_SubGoalContribution,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.contributionCount !== "0") {
      writer.uint32(16).int64(message.contributionCount);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): LiveStreamGoal_LiveStreamGoalContributor_SubGoalContribution {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLiveStreamGoal_LiveStreamGoalContributor_SubGoalContribution();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.contributionCount = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLiveStreamGoal_GoalStats(): LiveStreamGoal_GoalStats {
  return { totalCoins: "0", totalContributor: "0", comparison: undefined, totalNewFans: "0" };
}

export const LiveStreamGoal_GoalStatsDecoder: MessageFns<LiveStreamGoal_GoalStats> = {
  encode(message: LiveStreamGoal_GoalStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalCoins !== "0") {
      writer.uint32(8).int64(message.totalCoins);
    }
    if (message.totalContributor !== "0") {
      writer.uint32(16).int64(message.totalContributor);
    }
    if (message.comparison !== undefined) {
      LiveStreamGoal_GoalStats_GoalComparisonDecoder.encode(message.comparison, writer.uint32(26).fork()).join();
    }
    if (message.totalNewFans !== "0") {
      writer.uint32(32).int64(message.totalNewFans);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LiveStreamGoal_GoalStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLiveStreamGoal_GoalStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.totalCoins = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalContributor = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.comparison = LiveStreamGoal_GoalStats_GoalComparisonDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalNewFans = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLiveStreamGoal_GoalStats_GoalComparison(): LiveStreamGoal_GoalStats_GoalComparison {
  return { coinsIncr: "0", contributorIncr: "0" };
}

export const LiveStreamGoal_GoalStats_GoalComparisonDecoder: MessageFns<LiveStreamGoal_GoalStats_GoalComparison> = {
  encode(message: LiveStreamGoal_GoalStats_GoalComparison, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.coinsIncr !== "0") {
      writer.uint32(8).int64(message.coinsIncr);
    }
    if (message.contributorIncr !== "0") {
      writer.uint32(16).int64(message.contributorIncr);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LiveStreamGoal_GoalStats_GoalComparison {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLiveStreamGoal_GoalStats_GoalComparison();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.coinsIncr = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.contributorIncr = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLiveStreamGoalIndicator(): LiveStreamGoalIndicator {
  return { key: "", op: 0 };
}

export const LiveStreamGoalIndicatorDecoder: MessageFns<LiveStreamGoalIndicator> = {
  encode(message: LiveStreamGoalIndicator, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.op !== 0) {
      writer.uint32(16).int32(message.op);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LiveStreamGoalIndicator {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLiveStreamGoalIndicator();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.op = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRanking(): Ranking {
  return { type: "", label: "", color: undefined, details: [] };
}

export const RankingDecoder: MessageFns<Ranking> = {
  encode(message: Ranking, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.label !== "") {
      writer.uint32(18).string(message.label);
    }
    if (message.color !== undefined) {
      TikTokColorDecoder.encode(message.color, writer.uint32(26).fork()).join();
    }
    for (const v of message.details) {
      ValueLabelDecoder.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Ranking {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRanking();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.color = TikTokColorDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.details.push(ValueLabelDecoder.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseTikTokColor(): TikTokColor {
  return { color: "", id: "0", data1: 0 };
}

export const TikTokColorDecoder: MessageFns<TikTokColor> = {
  encode(message: TikTokColor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.color !== "") {
      writer.uint32(10).string(message.color);
    }
    if (message.id !== "0") {
      writer.uint32(32).uint64(message.id);
    }
    if (message.data1 !== 0) {
      writer.uint32(48).uint32(message.data1);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TikTokColor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTikTokColor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.color = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.id = reader.uint64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.data1 = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseValueLabel(): ValueLabel {
  return { data: 0, label: "", label2: "", label3: "" };
}

export const ValueLabelDecoder: MessageFns<ValueLabel> = {
  encode(message: ValueLabel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data !== 0) {
      writer.uint32(8).uint32(message.data);
    }
    if (message.label !== "") {
      writer.uint32(18).string(message.label);
    }
    if (message.label2 !== "") {
      writer.uint32(26).string(message.label2);
    }
    if (message.label3 !== "") {
      writer.uint32(90).string(message.label3);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValueLabel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValueLabel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.data = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.label2 = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.label3 = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseTimeStampContainer(): TimeStampContainer {
  return { timestamp1: "0", timestamp2: "0", timestamp3: "0" };
}

export const TimeStampContainerDecoder: MessageFns<TimeStampContainer> = {
  encode(message: TimeStampContainer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timestamp1 !== "0") {
      writer.uint32(8).uint64(message.timestamp1);
    }
    if (message.timestamp2 !== "0") {
      writer.uint32(16).uint64(message.timestamp2);
    }
    if (message.timestamp3 !== "0") {
      writer.uint32(24).uint64(message.timestamp3);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimeStampContainer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimeStampContainer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.timestamp1 = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.timestamp2 = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.timestamp3 = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePollStartContent(): PollStartContent {
  return { StartTime: "0", EndTime: "0", OptionList: [], Title: "", Operator: undefined };
}

export const PollStartContentDecoder: MessageFns<PollStartContent> = {
  encode(message: PollStartContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.StartTime !== "0") {
      writer.uint32(8).int64(message.StartTime);
    }
    if (message.EndTime !== "0") {
      writer.uint32(16).int64(message.EndTime);
    }
    for (const v of message.OptionList) {
      PollOptionInfoDecoder.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.Title !== "") {
      writer.uint32(34).string(message.Title);
    }
    if (message.Operator !== undefined) {
      UserDecoder.encode(message.Operator, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PollStartContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePollStartContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.StartTime = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.EndTime = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.OptionList.push(PollOptionInfoDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.Title = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.Operator = UserDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePollEndContent(): PollEndContent {
  return { EndType: 0, OptionList: [], Operator: undefined };
}

export const PollEndContentDecoder: MessageFns<PollEndContent> = {
  encode(message: PollEndContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.EndType !== 0) {
      writer.uint32(8).int32(message.EndType);
    }
    for (const v of message.OptionList) {
      PollOptionInfoDecoder.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.Operator !== undefined) {
      UserDecoder.encode(message.Operator, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PollEndContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePollEndContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.EndType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.OptionList.push(PollOptionInfoDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.Operator = UserDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePollOptionInfo(): PollOptionInfo {
  return { Votes: 0, DisplayContent: "", OptionIdx: 0, VoteUserList: [] };
}

export const PollOptionInfoDecoder: MessageFns<PollOptionInfo> = {
  encode(message: PollOptionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.Votes !== 0) {
      writer.uint32(8).int32(message.Votes);
    }
    if (message.DisplayContent !== "") {
      writer.uint32(18).string(message.DisplayContent);
    }
    if (message.OptionIdx !== 0) {
      writer.uint32(24).int32(message.OptionIdx);
    }
    for (const v of message.VoteUserList) {
      VoteUserDecoder.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PollOptionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePollOptionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.Votes = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.DisplayContent = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.OptionIdx = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.VoteUserList.push(VoteUserDecoder.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseVoteUser(): VoteUser {
  return { UserId: "0", NickName: "", AvatarThumb: undefined };
}

export const VoteUserDecoder: MessageFns<VoteUser> = {
  encode(message: VoteUser, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.UserId !== "0") {
      writer.uint32(8).int64(message.UserId);
    }
    if (message.NickName !== "") {
      writer.uint32(18).string(message.NickName);
    }
    if (message.AvatarThumb !== undefined) {
      ImageDecoder.encode(message.AvatarThumb, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VoteUser {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVoteUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.UserId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.NickName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.AvatarThumb = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePollUpdateVotesContent(): PollUpdateVotesContent {
  return { OptionList: [] };
}

export const PollUpdateVotesContentDecoder: MessageFns<PollUpdateVotesContent> = {
  encode(message: PollUpdateVotesContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.OptionList) {
      PollOptionInfoDecoder.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PollUpdateVotesContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePollUpdateVotesContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.OptionList.push(PollOptionInfoDecoder.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUserFanTicket(): UserFanTicket {
  return { UserId: "0", FanTicket: "0", MatchTotalScore: "0", MatchRank: 0 };
}

export const UserFanTicketDecoder: MessageFns<UserFanTicket> = {
  encode(message: UserFanTicket, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.UserId !== "0") {
      writer.uint32(8).int64(message.UserId);
    }
    if (message.FanTicket !== "0") {
      writer.uint32(16).int64(message.FanTicket);
    }
    if (message.MatchTotalScore !== "0") {
      writer.uint32(24).int64(message.MatchTotalScore);
    }
    if (message.MatchRank !== 0) {
      writer.uint32(32).int32(message.MatchRank);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserFanTicket {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserFanTicket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.UserId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.FanTicket = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.MatchTotalScore = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.MatchRank = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseFanTicketRoomNoticeContent(): FanTicketRoomNoticeContent {
  return {
    UserFanTicketList: [],
    TotalLinkMicFanTicket: "0",
    MatchId: "0",
    EventTime: "0",
    FanTicketIconUrl: "",
    playId: "0",
    playScene: 0,
  };
}

export const FanTicketRoomNoticeContentDecoder: MessageFns<FanTicketRoomNoticeContent> = {
  encode(message: FanTicketRoomNoticeContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.UserFanTicketList) {
      UserFanTicketDecoder.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.TotalLinkMicFanTicket !== "0") {
      writer.uint32(16).int64(message.TotalLinkMicFanTicket);
    }
    if (message.MatchId !== "0") {
      writer.uint32(24).int64(message.MatchId);
    }
    if (message.EventTime !== "0") {
      writer.uint32(32).int64(message.EventTime);
    }
    if (message.FanTicketIconUrl !== "") {
      writer.uint32(42).string(message.FanTicketIconUrl);
    }
    if (message.playId !== "0") {
      writer.uint32(48).int64(message.playId);
    }
    if (message.playScene !== 0) {
      writer.uint32(56).int32(message.playScene);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FanTicketRoomNoticeContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFanTicketRoomNoticeContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.UserFanTicketList.push(UserFanTicketDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.TotalLinkMicFanTicket = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.MatchId = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.EventTime = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.FanTicketIconUrl = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.playId = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.playScene = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLinkerAcceptNoticeContent(): LinkerAcceptNoticeContent {
  return { fromUserId: "0", fromRoomId: "0", toUserId: "0" };
}

export const LinkerAcceptNoticeContentDecoder: MessageFns<LinkerAcceptNoticeContent> = {
  encode(message: LinkerAcceptNoticeContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fromUserId !== "0") {
      writer.uint32(8).int64(message.fromUserId);
    }
    if (message.fromRoomId !== "0") {
      writer.uint32(16).int64(message.fromRoomId);
    }
    if (message.toUserId !== "0") {
      writer.uint32(24).int64(message.toUserId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerAcceptNoticeContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerAcceptNoticeContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.fromUserId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.fromRoomId = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.toUserId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLinkerCancelContent(): LinkerCancelContent {
  return { fromUserId: "0", toUserId: "0", cancelType: "0", actionId: "0" };
}

export const LinkerCancelContentDecoder: MessageFns<LinkerCancelContent> = {
  encode(message: LinkerCancelContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fromUserId !== "0") {
      writer.uint32(8).int64(message.fromUserId);
    }
    if (message.toUserId !== "0") {
      writer.uint32(16).int64(message.toUserId);
    }
    if (message.cancelType !== "0") {
      writer.uint32(24).int64(message.cancelType);
    }
    if (message.actionId !== "0") {
      writer.uint32(32).int64(message.actionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerCancelContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerCancelContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.fromUserId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.toUserId = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.cancelType = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.actionId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListUser(): ListUser {
  return {
    user: undefined,
    linkmicId: "0",
    linkmicIdStr: "",
    linkStatus: 0,
    linkType: 0,
    userPosition: 0,
    silenceStatus: 0,
    modifyTime: "0",
    linkerId: "0",
    roleType: 0,
  };
}

export const ListUserDecoder: MessageFns<ListUser> = {
  encode(message: ListUser, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      UserDecoder.encode(message.user, writer.uint32(10).fork()).join();
    }
    if (message.linkmicId !== "0") {
      writer.uint32(16).int64(message.linkmicId);
    }
    if (message.linkmicIdStr !== "") {
      writer.uint32(26).string(message.linkmicIdStr);
    }
    if (message.linkStatus !== 0) {
      writer.uint32(32).int32(message.linkStatus);
    }
    if (message.linkType !== 0) {
      writer.uint32(40).int32(message.linkType);
    }
    if (message.userPosition !== 0) {
      writer.uint32(48).int32(message.userPosition);
    }
    if (message.silenceStatus !== 0) {
      writer.uint32(56).int32(message.silenceStatus);
    }
    if (message.modifyTime !== "0") {
      writer.uint32(64).int64(message.modifyTime);
    }
    if (message.linkerId !== "0") {
      writer.uint32(72).int64(message.linkerId);
    }
    if (message.roleType !== 0) {
      writer.uint32(80).int32(message.roleType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListUser {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = UserDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.linkmicId = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.linkmicIdStr = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.linkStatus = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.linkType = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.userPosition = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.silenceStatus = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.modifyTime = reader.int64().toString();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.linkerId = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.roleType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLinkerCloseContent(): LinkerCloseContent {
  return {};
}

export const LinkerCloseContentDecoder: MessageFns<LinkerCloseContent> = {
  encode(_: LinkerCloseContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerCloseContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerCloseContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLinkerCreateContent(): LinkerCreateContent {
  return { ownerId: "0", ownerRoomId: "0", linkType: "0" };
}

export const LinkerCreateContentDecoder: MessageFns<LinkerCreateContent> = {
  encode(message: LinkerCreateContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ownerId !== "0") {
      writer.uint32(8).int64(message.ownerId);
    }
    if (message.ownerRoomId !== "0") {
      writer.uint32(16).int64(message.ownerRoomId);
    }
    if (message.linkType !== "0") {
      writer.uint32(24).int64(message.linkType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerCreateContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerCreateContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.ownerId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.ownerRoomId = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.linkType = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLinkerEnterContent(): LinkerEnterContent {
  return { linkedUsersList: [], anchorMultiLiveEnum: 0, anchorSettingInfo: undefined };
}

export const LinkerEnterContentDecoder: MessageFns<LinkerEnterContent> = {
  encode(message: LinkerEnterContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.linkedUsersList) {
      ListUserDecoder.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.anchorMultiLiveEnum !== 0) {
      writer.uint32(16).int32(message.anchorMultiLiveEnum);
    }
    if (message.anchorSettingInfo !== undefined) {
      MultiLiveAnchorPanelSettingsDecoder.encode(message.anchorSettingInfo, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerEnterContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerEnterContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.linkedUsersList.push(ListUserDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.anchorMultiLiveEnum = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.anchorSettingInfo = MultiLiveAnchorPanelSettingsDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLinkerInviteContent(): LinkerInviteContent {
  return {
    fromUserId: "0",
    fromRoomId: "0",
    toRtcExtInfo: "",
    rtcJoinChannel: false,
    vendor: "0",
    secFromUserId: "",
    toLinkmicIdStr: "",
    fromUser: undefined,
    requiredMicIdx: "0",
    rtcExtInfoMap: {},
    multiLiveLayoutEnable: 0,
    multiLiveSetting: undefined,
    fromLinkmicIdStr: "",
    fromTopHostInfo: undefined,
    actionId: "0",
    linkedUsers: [],
    dialogInfo: undefined,
    punishEventInfo: undefined,
    fromRoomAgeRestricted: 0,
    abTestSetting: [],
    linkerInviteMsgExtra: undefined,
  };
}

export const LinkerInviteContentDecoder: MessageFns<LinkerInviteContent> = {
  encode(message: LinkerInviteContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fromUserId !== "0") {
      writer.uint32(8).int64(message.fromUserId);
    }
    if (message.fromRoomId !== "0") {
      writer.uint32(16).int64(message.fromRoomId);
    }
    if (message.toRtcExtInfo !== "") {
      writer.uint32(26).string(message.toRtcExtInfo);
    }
    if (message.rtcJoinChannel !== false) {
      writer.uint32(32).bool(message.rtcJoinChannel);
    }
    if (message.vendor !== "0") {
      writer.uint32(40).int64(message.vendor);
    }
    if (message.secFromUserId !== "") {
      writer.uint32(50).string(message.secFromUserId);
    }
    if (message.toLinkmicIdStr !== "") {
      writer.uint32(58).string(message.toLinkmicIdStr);
    }
    if (message.fromUser !== undefined) {
      UserDecoder.encode(message.fromUser, writer.uint32(66).fork()).join();
    }
    if (message.requiredMicIdx !== "0") {
      writer.uint32(72).int64(message.requiredMicIdx);
    }
    Object.entries(message.rtcExtInfoMap).forEach(([key, value]) => {
      LinkerInviteContent_RtcExtInfoMapEntryDecoder.encode({ key: key as any, value }, writer.uint32(82).fork()).join();
    });
    if (message.multiLiveLayoutEnable !== 0) {
      writer.uint32(88).int32(message.multiLiveLayoutEnable);
    }
    if (message.multiLiveSetting !== undefined) {
      MultiLiveAnchorPanelSettingsDecoder.encode(message.multiLiveSetting, writer.uint32(98).fork()).join();
    }
    if (message.fromLinkmicIdStr !== "") {
      writer.uint32(106).string(message.fromLinkmicIdStr);
    }
    if (message.fromTopHostInfo !== undefined) {
      LinkerInviteContent_InviteTopHostInfoDecoder.encode(message.fromTopHostInfo, writer.uint32(130).fork()).join();
    }
    if (message.actionId !== "0") {
      writer.uint32(136).int64(message.actionId);
    }
    for (const v of message.linkedUsers) {
      LinkerInviteContent_LinkmicUserInfoDecoder.encode(v!, writer.uint32(146).fork()).join();
    }
    if (message.dialogInfo !== undefined) {
      LinkerInviteContent_PerceptionDialogInfoDecoder.encode(message.dialogInfo, writer.uint32(154).fork()).join();
    }
    if (message.punishEventInfo !== undefined) {
      PunishEventInfoDecoder.encode(message.punishEventInfo, writer.uint32(162).fork()).join();
    }
    if (message.fromRoomAgeRestricted !== 0) {
      writer.uint32(168).int32(message.fromRoomAgeRestricted);
    }
    for (const v of message.abTestSetting) {
      LinkerInviteContent_CohostABTestSettingDecoder.encode(v!, writer.uint32(186).fork()).join();
    }
    if (message.linkerInviteMsgExtra !== undefined) {
      LinkerInviteContent_LinkerInviteMessageExtraDecoder.encode(message.linkerInviteMsgExtra, writer.uint32(810).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerInviteContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerInviteContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.fromUserId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.fromRoomId = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.toRtcExtInfo = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.rtcJoinChannel = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.vendor = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.secFromUserId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.toLinkmicIdStr = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.fromUser = UserDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.requiredMicIdx = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          const entry10 = LinkerInviteContent_RtcExtInfoMapEntryDecoder.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.rtcExtInfoMap[entry10.key] = entry10.value;
          }
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.multiLiveLayoutEnable = reader.int32() as any;
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.multiLiveSetting = MultiLiveAnchorPanelSettingsDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.fromLinkmicIdStr = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.fromTopHostInfo = LinkerInviteContent_InviteTopHostInfoDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.actionId = reader.int64().toString();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.linkedUsers.push(LinkerInviteContent_LinkmicUserInfoDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.dialogInfo = LinkerInviteContent_PerceptionDialogInfoDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.punishEventInfo = PunishEventInfoDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.fromRoomAgeRestricted = reader.int32();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.abTestSetting.push(LinkerInviteContent_CohostABTestSettingDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 101: {
          if (tag !== 810) {
            break;
          }

          message.linkerInviteMsgExtra = LinkerInviteContent_LinkerInviteMessageExtraDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLinkerInviteContent_RtcExtInfoMapEntry(): LinkerInviteContent_RtcExtInfoMapEntry {
  return { key: "0", value: "" };
}

export const LinkerInviteContent_RtcExtInfoMapEntryDecoder: MessageFns<LinkerInviteContent_RtcExtInfoMapEntry> = {
  encode(message: LinkerInviteContent_RtcExtInfoMapEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "0") {
      writer.uint32(8).int64(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerInviteContent_RtcExtInfoMapEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerInviteContent_RtcExtInfoMapEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLinkerInviteContent_InviteTopHostInfo(): LinkerInviteContent_InviteTopHostInfo {
  return { rankType: "", topIndex: "0" };
}

export const LinkerInviteContent_InviteTopHostInfoDecoder: MessageFns<LinkerInviteContent_InviteTopHostInfo> = {
  encode(message: LinkerInviteContent_InviteTopHostInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rankType !== "") {
      writer.uint32(10).string(message.rankType);
    }
    if (message.topIndex !== "0") {
      writer.uint32(16).int64(message.topIndex);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerInviteContent_InviteTopHostInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerInviteContent_InviteTopHostInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rankType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.topIndex = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLinkerInviteContent_LinkmicUserInfo(): LinkerInviteContent_LinkmicUserInfo {
  return { userId: "0", linkmicIdStr: "", roomId: "0", linkedTime: "0" };
}

export const LinkerInviteContent_LinkmicUserInfoDecoder: MessageFns<LinkerInviteContent_LinkmicUserInfo> = {
  encode(message: LinkerInviteContent_LinkmicUserInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "0") {
      writer.uint32(8).int64(message.userId);
    }
    if (message.linkmicIdStr !== "") {
      writer.uint32(18).string(message.linkmicIdStr);
    }
    if (message.roomId !== "0") {
      writer.uint32(24).int64(message.roomId);
    }
    if (message.linkedTime !== "0") {
      writer.uint32(32).int64(message.linkedTime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerInviteContent_LinkmicUserInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerInviteContent_LinkmicUserInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.linkmicIdStr = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.roomId = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.linkedTime = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLinkerInviteContent_PerceptionDialogInfo(): LinkerInviteContent_PerceptionDialogInfo {
  return {
    iconType: 0,
    title: undefined,
    subTitle: undefined,
    adviceActionText: undefined,
    defaultActionText: undefined,
    violationDetailUrl: "",
    scene: 0,
    targetUserId: "0",
    targetRoomId: "0",
    countDownTime: "0",
    showFeedback: false,
    feedbackOptions: [],
    policyTip: "0",
    appealPopup: 0,
  };
}

export const LinkerInviteContent_PerceptionDialogInfoDecoder: MessageFns<LinkerInviteContent_PerceptionDialogInfo> = {
  encode(message: LinkerInviteContent_PerceptionDialogInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.iconType !== 0) {
      writer.uint32(8).int32(message.iconType);
    }
    if (message.title !== undefined) {
      TextDecoder.encode(message.title, writer.uint32(18).fork()).join();
    }
    if (message.subTitle !== undefined) {
      TextDecoder.encode(message.subTitle, writer.uint32(26).fork()).join();
    }
    if (message.adviceActionText !== undefined) {
      TextDecoder.encode(message.adviceActionText, writer.uint32(34).fork()).join();
    }
    if (message.defaultActionText !== undefined) {
      TextDecoder.encode(message.defaultActionText, writer.uint32(42).fork()).join();
    }
    if (message.violationDetailUrl !== "") {
      writer.uint32(50).string(message.violationDetailUrl);
    }
    if (message.scene !== 0) {
      writer.uint32(56).int32(message.scene);
    }
    if (message.targetUserId !== "0") {
      writer.uint32(64).int64(message.targetUserId);
    }
    if (message.targetRoomId !== "0") {
      writer.uint32(72).int64(message.targetRoomId);
    }
    if (message.countDownTime !== "0") {
      writer.uint32(80).int64(message.countDownTime);
    }
    if (message.showFeedback !== false) {
      writer.uint32(88).bool(message.showFeedback);
    }
    for (const v of message.feedbackOptions) {
      LinkerInviteContent_PerceptionDialogInfo_PerceptionFeedbackOptionDecoder.encode(v!, writer.uint32(98).fork()).join();
    }
    if (message.policyTip !== "0") {
      writer.uint32(104).int64(message.policyTip);
    }
    if (message.appealPopup !== 0) {
      writer.uint32(112).int32(message.appealPopup);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerInviteContent_PerceptionDialogInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerInviteContent_PerceptionDialogInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.iconType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = TextDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.subTitle = TextDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.adviceActionText = TextDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.defaultActionText = TextDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.violationDetailUrl = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.scene = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.targetUserId = reader.int64().toString();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.targetRoomId = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.countDownTime = reader.int64().toString();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.showFeedback = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.feedbackOptions.push(
            LinkerInviteContent_PerceptionDialogInfo_PerceptionFeedbackOptionDecoder.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.policyTip = reader.int64().toString();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.appealPopup = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLinkerInviteContent_PerceptionDialogInfo_PerceptionFeedbackOption(): LinkerInviteContent_PerceptionDialogInfo_PerceptionFeedbackOption {
  return { id: "0", contentKey: "" };
}

export const LinkerInviteContent_PerceptionDialogInfo_PerceptionFeedbackOptionDecoder: MessageFns<LinkerInviteContent_PerceptionDialogInfo_PerceptionFeedbackOption> = {
  encode(
    message: LinkerInviteContent_PerceptionDialogInfo_PerceptionFeedbackOption,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== "0") {
      writer.uint32(8).int64(message.id);
    }
    if (message.contentKey !== "") {
      writer.uint32(18).string(message.contentKey);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): LinkerInviteContent_PerceptionDialogInfo_PerceptionFeedbackOption {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerInviteContent_PerceptionDialogInfo_PerceptionFeedbackOption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contentKey = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLinkerInviteContent_CohostABTestSetting(): LinkerInviteContent_CohostABTestSetting {
  return { key: "0", value: undefined };
}

export const LinkerInviteContent_CohostABTestSettingDecoder: MessageFns<LinkerInviteContent_CohostABTestSetting> = {
  encode(message: LinkerInviteContent_CohostABTestSetting, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "0") {
      writer.uint32(8).int64(message.key);
    }
    if (message.value !== undefined) {
      LinkerInviteContent_CohostABTestSetting_CohostABTestListDecoder.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerInviteContent_CohostABTestSetting {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerInviteContent_CohostABTestSetting();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = LinkerInviteContent_CohostABTestSetting_CohostABTestListDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLinkerInviteContent_CohostABTestSetting_CohostABTestList(): LinkerInviteContent_CohostABTestSetting_CohostABTestList {
  return { abTestList: [] };
}

export const LinkerInviteContent_CohostABTestSetting_CohostABTestListDecoder: MessageFns<LinkerInviteContent_CohostABTestSetting_CohostABTestList> = {
  encode(
    message: LinkerInviteContent_CohostABTestSetting_CohostABTestList,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.abTestList) {
      LinkerInviteContent_CohostABTestSetting_CohostABTestList_CohostABTestDecoder.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerInviteContent_CohostABTestSetting_CohostABTestList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerInviteContent_CohostABTestSetting_CohostABTestList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.abTestList.push(
            LinkerInviteContent_CohostABTestSetting_CohostABTestList_CohostABTestDecoder.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLinkerInviteContent_CohostABTestSetting_CohostABTestList_CohostABTest(): LinkerInviteContent_CohostABTestSetting_CohostABTestList_CohostABTest {
  return { abTestType: 0, group: "0" };
}

export const LinkerInviteContent_CohostABTestSetting_CohostABTestList_CohostABTestDecoder: MessageFns<LinkerInviteContent_CohostABTestSetting_CohostABTestList_CohostABTest> = {
  encode(
    message: LinkerInviteContent_CohostABTestSetting_CohostABTestList_CohostABTest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.abTestType !== 0) {
      writer.uint32(8).int32(message.abTestType);
    }
    if (message.group !== "0") {
      writer.uint32(16).int64(message.group);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): LinkerInviteContent_CohostABTestSetting_CohostABTestList_CohostABTest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerInviteContent_CohostABTestSetting_CohostABTestList_CohostABTest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.abTestType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.group = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLinkerInviteContent_LinkerInviteMessageExtra(): LinkerInviteContent_LinkerInviteMessageExtra {
  return {
    matchType: 0,
    inviteType: 0,
    subType: 0,
    theme: "",
    duration: 0,
    layout: 0,
    tips: "",
    inviterRivalExtra: undefined,
    otherRivalExtra: [],
    topicInfo: undefined,
    algoRequestId: "",
  };
}

export const LinkerInviteContent_LinkerInviteMessageExtraDecoder: MessageFns<LinkerInviteContent_LinkerInviteMessageExtra> = {
  encode(
    message: LinkerInviteContent_LinkerInviteMessageExtra,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.matchType !== 0) {
      writer.uint32(8).int32(message.matchType);
    }
    if (message.inviteType !== 0) {
      writer.uint32(16).int32(message.inviteType);
    }
    if (message.subType !== 0) {
      writer.uint32(24).int32(message.subType);
    }
    if (message.theme !== "") {
      writer.uint32(34).string(message.theme);
    }
    if (message.duration !== 0) {
      writer.uint32(40).int32(message.duration);
    }
    if (message.layout !== 0) {
      writer.uint32(48).int32(message.layout);
    }
    if (message.tips !== "") {
      writer.uint32(58).string(message.tips);
    }
    if (message.inviterRivalExtra !== undefined) {
      LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtraDecoder.encode(
        message.inviterRivalExtra,
        writer.uint32(66).fork(),
      ).join();
    }
    for (const v of message.otherRivalExtra) {
      LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtraDecoder.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.topicInfo !== undefined) {
      CohostTopicDecoder.encode(message.topicInfo, writer.uint32(82).fork()).join();
    }
    if (message.algoRequestId !== "") {
      writer.uint32(90).string(message.algoRequestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerInviteContent_LinkerInviteMessageExtra {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerInviteContent_LinkerInviteMessageExtra();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.matchType = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.inviteType = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.subType = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.theme = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.duration = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.layout = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.tips = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.inviterRivalExtra = LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtraDecoder.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.otherRivalExtra.push(
            LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtraDecoder.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.topicInfo = CohostTopicDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.algoRequestId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra(): LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra {
  return {
    textType: 0,
    text: "",
    label: "",
    userCount: 0,
    avatarThumb: undefined,
    displayId: "",
    authenticationInfo: undefined,
    nickname: "",
    followStatus: "0",
    mHashtag: undefined,
    userId: "0",
    isBestTeammate: false,
    optPairInfo: undefined,
    followerCount: "0",
  };
}

export const LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtraDecoder: MessageFns<LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra> = {
  encode(
    message: LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.textType !== 0) {
      writer.uint32(8).int32(message.textType);
    }
    if (message.text !== "") {
      writer.uint32(18).string(message.text);
    }
    if (message.label !== "") {
      writer.uint32(26).string(message.label);
    }
    if (message.userCount !== 0) {
      writer.uint32(32).int32(message.userCount);
    }
    if (message.avatarThumb !== undefined) {
      ImageDecoder.encode(message.avatarThumb, writer.uint32(42).fork()).join();
    }
    if (message.displayId !== "") {
      writer.uint32(50).string(message.displayId);
    }
    if (message.authenticationInfo !== undefined) {
      LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_AuthenticationInfoDecoder.encode(
        message.authenticationInfo,
        writer.uint32(58).fork(),
      ).join();
    }
    if (message.nickname !== "") {
      writer.uint32(66).string(message.nickname);
    }
    if (message.followStatus !== "0") {
      writer.uint32(72).int64(message.followStatus);
    }
    if (message.mHashtag !== undefined) {
      LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_HashtagDecoder.encode(
        message.mHashtag,
        writer.uint32(82).fork(),
      ).join();
    }
    if (message.userId !== "0") {
      writer.uint32(96).int64(message.userId);
    }
    if (message.isBestTeammate !== false) {
      writer.uint32(104).bool(message.isBestTeammate);
    }
    if (message.optPairInfo !== undefined) {
      LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfoDecoder.encode(
        message.optPairInfo,
        writer.uint32(114).fork(),
      ).join();
    }
    if (message.followerCount !== "0") {
      writer.uint32(120).int64(message.followerCount);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.textType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.text = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.userCount = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.avatarThumb = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.displayId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.authenticationInfo = LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_AuthenticationInfoDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.nickname = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.followStatus = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.mHashtag = LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_HashtagDecoder.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.userId = reader.int64().toString();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.isBestTeammate = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.optPairInfo = LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfoDecoder.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.followerCount = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_AuthenticationInfo(): LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_AuthenticationInfo {
  return { customVerify: "", enterpriseVerifyReason: "", authenticationBadge: undefined };
}

export const LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_AuthenticationInfoDecoder: MessageFns<LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_AuthenticationInfo> = {
  encode(
    message: LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_AuthenticationInfo,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.customVerify !== "") {
      writer.uint32(10).string(message.customVerify);
    }
    if (message.enterpriseVerifyReason !== "") {
      writer.uint32(18).string(message.enterpriseVerifyReason);
    }
    if (message.authenticationBadge !== undefined) {
      ImageDecoder.encode(message.authenticationBadge, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_AuthenticationInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_AuthenticationInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.customVerify = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.enterpriseVerifyReason = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.authenticationBadge = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_Hashtag(): LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_Hashtag {
  return { id: "0", title: "", image: undefined, namespace: 0 };
}

export const LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_HashtagDecoder: MessageFns<LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_Hashtag> = {
  encode(
    message: LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_Hashtag,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== "0") {
      writer.uint32(8).int64(message.id);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.image !== undefined) {
      ImageDecoder.encode(message.image, writer.uint32(26).fork()).join();
    }
    if (message.namespace !== 0) {
      writer.uint32(32).int32(message.namespace);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_Hashtag {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_Hashtag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.image = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.namespace = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo(): LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo {
  return { mappingId: "0", displayUserList: [], buttonNoticeType: 0, expectedTimeSec: "0", optPairType: "0" };
}

export const LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfoDecoder: MessageFns<LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo> = {
  encode(
    message: LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.mappingId !== "0") {
      writer.uint32(8).int64(message.mappingId);
    }
    for (const v of message.displayUserList) {
      LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo_OptPairUserDecoder.encode(
        v!,
        writer.uint32(18).fork(),
      ).join();
    }
    if (message.buttonNoticeType !== 0) {
      writer.uint32(24).int32(message.buttonNoticeType);
    }
    if (message.expectedTimeSec !== "0") {
      writer.uint32(32).int64(message.expectedTimeSec);
    }
    if (message.optPairType !== "0") {
      writer.uint32(40).int64(message.optPairType);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.mappingId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.displayUserList.push(
            LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo_OptPairUserDecoder.decode(
              reader,
              reader.uint32(),
            ),
          );
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.buttonNoticeType = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.expectedTimeSec = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.optPairType = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo_OptPairUser(): LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo_OptPairUser {
  return { user: undefined, roomId: "0" };
}

export const LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo_OptPairUserDecoder: MessageFns<LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo_OptPairUser> = {
  encode(
    message: LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo_OptPairUser,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.user !== undefined) {
      UserDecoder.encode(message.user, writer.uint32(10).fork()).join();
    }
    if (message.roomId !== "0") {
      writer.uint32(16).int64(message.roomId);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo_OptPairUser {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo_OptPairUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = UserDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.roomId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCohostTopic(): CohostTopic {
  return { id: "0", titleKey: "", titleText: "", liked: false, totalHeat: "0", totalRivals: "0", rivalsAvatar: [] };
}

export const CohostTopicDecoder: MessageFns<CohostTopic> = {
  encode(message: CohostTopic, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "0") {
      writer.uint32(8).int64(message.id);
    }
    if (message.titleKey !== "") {
      writer.uint32(18).string(message.titleKey);
    }
    if (message.titleText !== "") {
      writer.uint32(26).string(message.titleText);
    }
    if (message.liked !== false) {
      writer.uint32(168).bool(message.liked);
    }
    if (message.totalHeat !== "0") {
      writer.uint32(176).int64(message.totalHeat);
    }
    if (message.totalRivals !== "0") {
      writer.uint32(184).int64(message.totalRivals);
    }
    for (const v of message.rivalsAvatar) {
      ImageDecoder.encode(v!, writer.uint32(194).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CohostTopic {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCohostTopic();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.titleKey = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.titleText = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.liked = reader.bool();
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.totalHeat = reader.int64().toString();
          continue;
        }
        case 23: {
          if (tag !== 184) {
            break;
          }

          message.totalRivals = reader.int64().toString();
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.rivalsAvatar.push(ImageDecoder.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLinkerKickOutContent(): LinkerKickOutContent {
  return { fromUserId: "0", kickoutReason: 0 };
}

export const LinkerKickOutContentDecoder: MessageFns<LinkerKickOutContent> = {
  encode(message: LinkerKickOutContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fromUserId !== "0") {
      writer.uint32(8).int64(message.fromUserId);
    }
    if (message.kickoutReason !== 0) {
      writer.uint32(16).int32(message.kickoutReason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerKickOutContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerKickOutContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.fromUserId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.kickoutReason = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLinkerLeaveContent(): LinkerLeaveContent {
  return { userId: "0", linkmicIdStr: "", sendLeaveUid: "0", leaveReason: "0" };
}

export const LinkerLeaveContentDecoder: MessageFns<LinkerLeaveContent> = {
  encode(message: LinkerLeaveContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "0") {
      writer.uint32(8).int64(message.userId);
    }
    if (message.linkmicIdStr !== "") {
      writer.uint32(18).string(message.linkmicIdStr);
    }
    if (message.sendLeaveUid !== "0") {
      writer.uint32(24).int64(message.sendLeaveUid);
    }
    if (message.leaveReason !== "0") {
      writer.uint32(32).int64(message.leaveReason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerLeaveContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerLeaveContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.linkmicIdStr = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.sendLeaveUid = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.leaveReason = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLinkerLinkedListChangeContent(): LinkerLinkedListChangeContent {
  return {};
}

export const LinkerLinkedListChangeContentDecoder: MessageFns<LinkerLinkedListChangeContent> = {
  encode(_: LinkerLinkedListChangeContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerLinkedListChangeContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerLinkedListChangeContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCohostListChangeContent(): CohostListChangeContent {
  return {};
}

export const CohostListChangeContentDecoder: MessageFns<CohostListChangeContent> = {
  encode(_: CohostListChangeContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CohostListChangeContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCohostListChangeContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLinkerListChangeContent(): LinkerListChangeContent {
  return { linkedUsers: [], appliedUsers: [], connectingUsers: [] };
}

export const LinkerListChangeContentDecoder: MessageFns<LinkerListChangeContent> = {
  encode(message: LinkerListChangeContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.linkedUsers) {
      ListUserDecoder.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.appliedUsers) {
      ListUserDecoder.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.connectingUsers) {
      ListUserDecoder.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerListChangeContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerListChangeContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.linkedUsers.push(ListUserDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.appliedUsers.push(ListUserDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.connectingUsers.push(ListUserDecoder.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLinkerMediaChangeContent(): LinkerMediaChangeContent {
  return { op: 0, toUserId: "0", anchorId: "0", roomId: "0", changeScene: 0, operatorInfo: undefined };
}

export const LinkerMediaChangeContentDecoder: MessageFns<LinkerMediaChangeContent> = {
  encode(message: LinkerMediaChangeContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.op !== 0) {
      writer.uint32(8).int32(message.op);
    }
    if (message.toUserId !== "0") {
      writer.uint32(16).int64(message.toUserId);
    }
    if (message.anchorId !== "0") {
      writer.uint32(24).int64(message.anchorId);
    }
    if (message.roomId !== "0") {
      writer.uint32(32).int64(message.roomId);
    }
    if (message.changeScene !== 0) {
      writer.uint32(40).int32(message.changeScene);
    }
    if (message.operatorInfo !== undefined) {
      LinkerMediaChangeContent_LinkerMediaChangeOperatorDecoder.encode(message.operatorInfo, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerMediaChangeContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerMediaChangeContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.op = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.toUserId = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.anchorId = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.roomId = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.changeScene = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.operatorInfo = LinkerMediaChangeContent_LinkerMediaChangeOperatorDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLinkerMediaChangeContent_LinkerMediaChangeOperator(): LinkerMediaChangeContent_LinkerMediaChangeOperator {
  return { userId: "0", operatorType: 0, nickName: "", displayId: "" };
}

export const LinkerMediaChangeContent_LinkerMediaChangeOperatorDecoder: MessageFns<LinkerMediaChangeContent_LinkerMediaChangeOperator> = {
  encode(
    message: LinkerMediaChangeContent_LinkerMediaChangeOperator,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.userId !== "0") {
      writer.uint32(8).int64(message.userId);
    }
    if (message.operatorType !== 0) {
      writer.uint32(16).int32(message.operatorType);
    }
    if (message.nickName !== "") {
      writer.uint32(26).string(message.nickName);
    }
    if (message.displayId !== "") {
      writer.uint32(34).string(message.displayId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerMediaChangeContent_LinkerMediaChangeOperator {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerMediaChangeContent_LinkerMediaChangeOperator();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.operatorType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nickName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.displayId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLinkerMicIdxUpdateContent(): LinkerMicIdxUpdateContent {
  return {};
}

export const LinkerMicIdxUpdateContentDecoder: MessageFns<LinkerMicIdxUpdateContent> = {
  encode(_: LinkerMicIdxUpdateContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerMicIdxUpdateContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerMicIdxUpdateContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLinkerMuteContent(): LinkerMuteContent {
  return { userId: "0", status: 0 };
}

export const LinkerMuteContentDecoder: MessageFns<LinkerMuteContent> = {
  encode(message: LinkerMuteContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "0") {
      writer.uint32(8).int64(message.userId);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerMuteContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerMuteContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLinkerRandomMatchContent(): LinkerRandomMatchContent {
  return { user: undefined, roomId: "0", inviteType: "0", matchId: "", innerChannelId: "0" };
}

export const LinkerRandomMatchContentDecoder: MessageFns<LinkerRandomMatchContent> = {
  encode(message: LinkerRandomMatchContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      UserDecoder.encode(message.user, writer.uint32(10).fork()).join();
    }
    if (message.roomId !== "0") {
      writer.uint32(16).int64(message.roomId);
    }
    if (message.inviteType !== "0") {
      writer.uint32(24).int64(message.inviteType);
    }
    if (message.matchId !== "") {
      writer.uint32(34).string(message.matchId);
    }
    if (message.innerChannelId !== "0") {
      writer.uint32(40).int64(message.innerChannelId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerRandomMatchContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerRandomMatchContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = UserDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.roomId = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.inviteType = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.matchId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.innerChannelId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLinkerReplyContent(): LinkerReplyContent {
  return {
    fromUserId: "0",
    fromRoomId: "0",
    fromUserLinkmicInfo: undefined,
    toUserId: "0",
    toUserLinkmicInfo: undefined,
    linkType: "0",
    replyStatus: "0",
    linkerSetting: undefined,
    fromUser: undefined,
    toUser: undefined,
  };
}

export const LinkerReplyContentDecoder: MessageFns<LinkerReplyContent> = {
  encode(message: LinkerReplyContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fromUserId !== "0") {
      writer.uint32(8).int64(message.fromUserId);
    }
    if (message.fromRoomId !== "0") {
      writer.uint32(16).int64(message.fromRoomId);
    }
    if (message.fromUserLinkmicInfo !== undefined) {
      LinkerReplyContent_LinkmicInfoDecoder.encode(message.fromUserLinkmicInfo, writer.uint32(26).fork()).join();
    }
    if (message.toUserId !== "0") {
      writer.uint32(32).int64(message.toUserId);
    }
    if (message.toUserLinkmicInfo !== undefined) {
      LinkerReplyContent_LinkmicInfoDecoder.encode(message.toUserLinkmicInfo, writer.uint32(42).fork()).join();
    }
    if (message.linkType !== "0") {
      writer.uint32(48).int64(message.linkType);
    }
    if (message.replyStatus !== "0") {
      writer.uint32(56).int64(message.replyStatus);
    }
    if (message.linkerSetting !== undefined) {
      LinkerSettingDecoder.encode(message.linkerSetting, writer.uint32(66).fork()).join();
    }
    if (message.fromUser !== undefined) {
      UserDecoder.encode(message.fromUser, writer.uint32(74).fork()).join();
    }
    if (message.toUser !== undefined) {
      UserDecoder.encode(message.toUser, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerReplyContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerReplyContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.fromUserId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.fromRoomId = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fromUserLinkmicInfo = LinkerReplyContent_LinkmicInfoDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.toUserId = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.toUserLinkmicInfo = LinkerReplyContent_LinkmicInfoDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.linkType = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.replyStatus = reader.int64().toString();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.linkerSetting = LinkerSettingDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.fromUser = UserDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.toUser = UserDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLinkerReplyContent_LinkmicInfo(): LinkerReplyContent_LinkmicInfo {
  return {
    accessKey: "",
    linkMicId: "0",
    joinable: false,
    confluenceType: 0,
    rtcExtInfo: "",
    rtcAppId: "",
    rtcAppSign: "",
    linkmicIdStr: "",
    vendor: "0",
  };
}

export const LinkerReplyContent_LinkmicInfoDecoder: MessageFns<LinkerReplyContent_LinkmicInfo> = {
  encode(message: LinkerReplyContent_LinkmicInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessKey !== "") {
      writer.uint32(10).string(message.accessKey);
    }
    if (message.linkMicId !== "0") {
      writer.uint32(16).int64(message.linkMicId);
    }
    if (message.joinable !== false) {
      writer.uint32(24).bool(message.joinable);
    }
    if (message.confluenceType !== 0) {
      writer.uint32(32).int32(message.confluenceType);
    }
    if (message.rtcExtInfo !== "") {
      writer.uint32(42).string(message.rtcExtInfo);
    }
    if (message.rtcAppId !== "") {
      writer.uint32(50).string(message.rtcAppId);
    }
    if (message.rtcAppSign !== "") {
      writer.uint32(58).string(message.rtcAppSign);
    }
    if (message.linkmicIdStr !== "") {
      writer.uint32(66).string(message.linkmicIdStr);
    }
    if (message.vendor !== "0") {
      writer.uint32(72).int64(message.vendor);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerReplyContent_LinkmicInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerReplyContent_LinkmicInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accessKey = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.linkMicId = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.joinable = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.confluenceType = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.rtcExtInfo = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.rtcAppId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.rtcAppSign = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.linkmicIdStr = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.vendor = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLinkerSetting(): LinkerSetting {
  return { MaxMemberLimit: "0", LinkType: "0", Scene: 0, OwnerUserId: "0", OwnerRoomId: "0", Vendor: "0" };
}

export const LinkerSettingDecoder: MessageFns<LinkerSetting> = {
  encode(message: LinkerSetting, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.MaxMemberLimit !== "0") {
      writer.uint32(8).int64(message.MaxMemberLimit);
    }
    if (message.LinkType !== "0") {
      writer.uint32(16).int64(message.LinkType);
    }
    if (message.Scene !== 0) {
      writer.uint32(24).int32(message.Scene);
    }
    if (message.OwnerUserId !== "0") {
      writer.uint32(32).int64(message.OwnerUserId);
    }
    if (message.OwnerRoomId !== "0") {
      writer.uint32(40).int64(message.OwnerRoomId);
    }
    if (message.Vendor !== "0") {
      writer.uint32(48).int64(message.Vendor);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerSetting {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerSetting();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.MaxMemberLimit = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.LinkType = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.Scene = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.OwnerUserId = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.OwnerRoomId = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.Vendor = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLinkerSysKickOutContent(): LinkerSysKickOutContent {
  return { userId: "0", linkmicIdStr: "" };
}

export const LinkerSysKickOutContentDecoder: MessageFns<LinkerSysKickOutContent> = {
  encode(message: LinkerSysKickOutContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "0") {
      writer.uint32(8).int64(message.userId);
    }
    if (message.linkmicIdStr !== "") {
      writer.uint32(18).string(message.linkmicIdStr);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerSysKickOutContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerSysKickOutContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.linkmicIdStr = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLinkmicUserToastContent(): LinkmicUserToastContent {
  return { userId: "0", roomId: "0", displayText: undefined, leavedUserId: "0" };
}

export const LinkmicUserToastContentDecoder: MessageFns<LinkmicUserToastContent> = {
  encode(message: LinkmicUserToastContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "0") {
      writer.uint32(8).int64(message.userId);
    }
    if (message.roomId !== "0") {
      writer.uint32(16).int64(message.roomId);
    }
    if (message.displayText !== undefined) {
      TextDecoder.encode(message.displayText, writer.uint32(26).fork()).join();
    }
    if (message.leavedUserId !== "0") {
      writer.uint32(32).int64(message.leavedUserId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkmicUserToastContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkmicUserToastContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.roomId = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.displayText = TextDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.leavedUserId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLinkerUpdateUserContent(): LinkerUpdateUserContent {
  return { fromUserId: "0", toUserId: "0", updateInfo: {} };
}

export const LinkerUpdateUserContentDecoder: MessageFns<LinkerUpdateUserContent> = {
  encode(message: LinkerUpdateUserContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fromUserId !== "0") {
      writer.uint32(8).int64(message.fromUserId);
    }
    if (message.toUserId !== "0") {
      writer.uint32(16).int64(message.toUserId);
    }
    Object.entries(message.updateInfo).forEach(([key, value]) => {
      LinkerUpdateUserContent_UpdateInfoEntryDecoder.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerUpdateUserContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerUpdateUserContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.fromUserId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.toUserId = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = LinkerUpdateUserContent_UpdateInfoEntryDecoder.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.updateInfo[entry3.key] = entry3.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLinkerUpdateUserContent_UpdateInfoEntry(): LinkerUpdateUserContent_UpdateInfoEntry {
  return { key: "", value: "" };
}

export const LinkerUpdateUserContent_UpdateInfoEntryDecoder: MessageFns<LinkerUpdateUserContent_UpdateInfoEntry> = {
  encode(message: LinkerUpdateUserContent_UpdateInfoEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerUpdateUserContent_UpdateInfoEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerUpdateUserContent_UpdateInfoEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLinkerUpdateUserSettingContent(): LinkerUpdateUserSettingContent {
  return { multiLiveAnchorPanelSettings: undefined };
}

export const LinkerUpdateUserSettingContentDecoder: MessageFns<LinkerUpdateUserSettingContent> = {
  encode(message: LinkerUpdateUserSettingContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.multiLiveAnchorPanelSettings !== undefined) {
      MultiLiveAnchorPanelSettingsDecoder.encode(message.multiLiveAnchorPanelSettings, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerUpdateUserSettingContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerUpdateUserSettingContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.multiLiveAnchorPanelSettings = MultiLiveAnchorPanelSettingsDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLinkerWaitingListChangeContent(): LinkerWaitingListChangeContent {
  return {};
}

export const LinkerWaitingListChangeContentDecoder: MessageFns<LinkerWaitingListChangeContent> = {
  encode(_: LinkerWaitingListChangeContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerWaitingListChangeContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerWaitingListChangeContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseMultiLiveAnchorPanelSettings(): MultiLiveAnchorPanelSettings {
  return {
    userId: "0",
    layout: "0",
    fixMicNum: "0",
    allowRequestFromUser: "0",
    allowRequestFromFollowerOnly: "0",
    applierSortSetting: 0,
    applierSortGiftScoreThreshold: "0",
    allowRequestFromFriends: 0,
    allowRequestFromFollowers: 0,
    allowRequestFromOthers: 0,
    enableShowMultiGuestLayout: 0,
  };
}

export const MultiLiveAnchorPanelSettingsDecoder: MessageFns<MultiLiveAnchorPanelSettings> = {
  encode(message: MultiLiveAnchorPanelSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "0") {
      writer.uint32(8).int64(message.userId);
    }
    if (message.layout !== "0") {
      writer.uint32(16).int64(message.layout);
    }
    if (message.fixMicNum !== "0") {
      writer.uint32(24).int64(message.fixMicNum);
    }
    if (message.allowRequestFromUser !== "0") {
      writer.uint32(32).int64(message.allowRequestFromUser);
    }
    if (message.allowRequestFromFollowerOnly !== "0") {
      writer.uint32(40).int64(message.allowRequestFromFollowerOnly);
    }
    if (message.applierSortSetting !== 0) {
      writer.uint32(56).int32(message.applierSortSetting);
    }
    if (message.applierSortGiftScoreThreshold !== "0") {
      writer.uint32(64).int64(message.applierSortGiftScoreThreshold);
    }
    if (message.allowRequestFromFriends !== 0) {
      writer.uint32(72).int32(message.allowRequestFromFriends);
    }
    if (message.allowRequestFromFollowers !== 0) {
      writer.uint32(80).int32(message.allowRequestFromFollowers);
    }
    if (message.allowRequestFromOthers !== 0) {
      writer.uint32(88).int32(message.allowRequestFromOthers);
    }
    if (message.enableShowMultiGuestLayout !== 0) {
      writer.uint32(96).int32(message.enableShowMultiGuestLayout);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiLiveAnchorPanelSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiLiveAnchorPanelSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.layout = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.fixMicNum = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.allowRequestFromUser = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.allowRequestFromFollowerOnly = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.applierSortSetting = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.applierSortGiftScoreThreshold = reader.int64().toString();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.allowRequestFromFriends = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.allowRequestFromFollowers = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.allowRequestFromOthers = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.enableShowMultiGuestLayout = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePlayer(): Player {
  return { roomId: "0", userId: "0" };
}

export const PlayerDecoder: MessageFns<Player> = {
  encode(message: Player, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.roomId !== "0") {
      writer.uint32(8).int64(message.roomId);
    }
    if (message.userId !== "0") {
      writer.uint32(16).int64(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Player {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.roomId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.userId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseAllListUser(): AllListUser {
  return { linkedList: [], appliedList: [], invitedList: [], readyList: [] };
}

export const AllListUserDecoder: MessageFns<AllListUser> = {
  encode(message: AllListUser, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.linkedList) {
      LinkLayerListUserDecoder.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.appliedList) {
      LinkLayerListUserDecoder.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.invitedList) {
      LinkLayerListUserDecoder.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.readyList) {
      LinkLayerListUserDecoder.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AllListUser {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllListUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.linkedList.push(LinkLayerListUserDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.appliedList.push(LinkLayerListUserDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.invitedList.push(LinkLayerListUserDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.readyList.push(LinkLayerListUserDecoder.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLinkLayerListUser(): LinkLayerListUser {
  return { user: undefined, linkmicId: "0", pos: undefined, linkedTimeNano: "0", appVersion: "", magicNumber1: "0" };
}

export const LinkLayerListUserDecoder: MessageFns<LinkLayerListUser> = {
  encode(message: LinkLayerListUser, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      UserDecoder.encode(message.user, writer.uint32(10).fork()).join();
    }
    if (message.linkmicId !== "0") {
      writer.uint32(16).int64(message.linkmicId);
    }
    if (message.pos !== undefined) {
      PositionDecoder.encode(message.pos, writer.uint32(26).fork()).join();
    }
    if (message.linkedTimeNano !== "0") {
      writer.uint32(32).int64(message.linkedTimeNano);
    }
    if (message.appVersion !== "") {
      writer.uint32(42).string(message.appVersion);
    }
    if (message.magicNumber1 !== "0") {
      writer.uint32(56).int64(message.magicNumber1);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkLayerListUser {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkLayerListUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = UserDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.linkmicId = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pos = PositionDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.linkedTimeNano = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.appVersion = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.magicNumber1 = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePosition(): Position {
  return { type: 0, link: undefined };
}

export const PositionDecoder: MessageFns<Position> = {
  encode(message: Position, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.link !== undefined) {
      LinkPositionDecoder.encode(message.link, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Position {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePosition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.link = LinkPositionDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLinkPosition(): LinkPosition {
  return { position: 0, opt: 0 };
}

export const LinkPositionDecoder: MessageFns<LinkPosition> = {
  encode(message: LinkPosition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.position !== 0) {
      writer.uint32(8).int32(message.position);
    }
    if (message.opt !== 0) {
      writer.uint32(16).int32(message.opt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkPosition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkPosition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.position = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.opt = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGroupPlayer(): GroupPlayer {
  return { channelId: "0", user: undefined };
}

export const GroupPlayerDecoder: MessageFns<GroupPlayer> = {
  encode(message: GroupPlayer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.channelId !== "0") {
      writer.uint32(8).int64(message.channelId);
    }
    if (message.user !== undefined) {
      UserDecoder.encode(message.user, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupPlayer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupPlayer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.channelId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.user = UserDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDSLConfig(): DSLConfig {
  return { sceneVersion: 0, layoutId: "" };
}

export const DSLConfigDecoder: MessageFns<DSLConfig> = {
  encode(message: DSLConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sceneVersion !== 0) {
      writer.uint32(8).int32(message.sceneVersion);
    }
    if (message.layoutId !== "") {
      writer.uint32(18).string(message.layoutId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DSLConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDSLConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.sceneVersion = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.layoutId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGroupChannelAllUser(): GroupChannelAllUser {
  return { groupChannelId: "0", userList: [], contentVersion: "0" };
}

export const GroupChannelAllUserDecoder: MessageFns<GroupChannelAllUser> = {
  encode(message: GroupChannelAllUser, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupChannelId !== "0") {
      writer.uint32(8).int64(message.groupChannelId);
    }
    for (const v of message.userList) {
      GroupChannelUserDecoder.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.contentVersion !== "0") {
      writer.uint32(24).int64(message.contentVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupChannelAllUser {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupChannelAllUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.groupChannelId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userList.push(GroupChannelUserDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.contentVersion = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGroupChannelUser(): GroupChannelUser {
  return {
    channelId: "0",
    status: 0,
    type: 0,
    allUser: undefined,
    joinTime: "0",
    linkedTime: "0",
    ownerUser: undefined,
    groupLinkmicId: "",
  };
}

export const GroupChannelUserDecoder: MessageFns<GroupChannelUser> = {
  encode(message: GroupChannelUser, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.channelId !== "0") {
      writer.uint32(8).int64(message.channelId);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (message.allUser !== undefined) {
      AllListUserDecoder.encode(message.allUser, writer.uint32(34).fork()).join();
    }
    if (message.joinTime !== "0") {
      writer.uint32(40).int64(message.joinTime);
    }
    if (message.linkedTime !== "0") {
      writer.uint32(48).int64(message.linkedTime);
    }
    if (message.ownerUser !== undefined) {
      GroupPlayerDecoder.encode(message.ownerUser, writer.uint32(58).fork()).join();
    }
    if (message.groupLinkmicId !== "") {
      writer.uint32(66).string(message.groupLinkmicId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupChannelUser {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupChannelUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.channelId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.allUser = AllListUserDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.joinTime = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.linkedTime = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.ownerUser = GroupPlayerDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.groupLinkmicId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRTCExtraInfo(): RTCExtraInfo {
  return {
    liveRtcEngineConfig: undefined,
    liveRtcVideoParamList: [],
    rtcBitrateMap: undefined,
    rtcFps: 0,
    rtcMixBase: undefined,
    byteRtcExtInfo: undefined,
    rtcInfoExtra: undefined,
    rtcBusinessId: "",
    rtcOther: undefined,
    interactClientType: 0,
  };
}

export const RTCExtraInfoDecoder: MessageFns<RTCExtraInfo> = {
  encode(message: RTCExtraInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.liveRtcEngineConfig !== undefined) {
      RTCExtraInfo_RTCEngineConfigDecoder.encode(message.liveRtcEngineConfig, writer.uint32(10).fork()).join();
    }
    for (const v of message.liveRtcVideoParamList) {
      RTCExtraInfo_RTCLiveVideoParamDecoder.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.rtcBitrateMap !== undefined) {
      RTCExtraInfo_RTCBitrateMapDecoder.encode(message.rtcBitrateMap, writer.uint32(26).fork()).join();
    }
    if (message.rtcFps !== 0) {
      writer.uint32(32).int32(message.rtcFps);
    }
    if (message.rtcMixBase !== undefined) {
      RTCExtraInfo_RTCMixBaseDecoder.encode(message.rtcMixBase, writer.uint32(42).fork()).join();
    }
    if (message.byteRtcExtInfo !== undefined) {
      RTCExtraInfo_ByteRTCExtInfoDecoder.encode(message.byteRtcExtInfo, writer.uint32(50).fork()).join();
    }
    if (message.rtcInfoExtra !== undefined) {
      RTCExtraInfo_RTCInfoExtraDecoder.encode(message.rtcInfoExtra, writer.uint32(58).fork()).join();
    }
    if (message.rtcBusinessId !== "") {
      writer.uint32(66).string(message.rtcBusinessId);
    }
    if (message.rtcOther !== undefined) {
      RTCExtraInfo_RTCOtherDecoder.encode(message.rtcOther, writer.uint32(74).fork()).join();
    }
    if (message.interactClientType !== 0) {
      writer.uint32(80).int32(message.interactClientType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RTCExtraInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRTCExtraInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.liveRtcEngineConfig = RTCExtraInfo_RTCEngineConfigDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.liveRtcVideoParamList.push(RTCExtraInfo_RTCLiveVideoParamDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rtcBitrateMap = RTCExtraInfo_RTCBitrateMapDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.rtcFps = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.rtcMixBase = RTCExtraInfo_RTCMixBaseDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.byteRtcExtInfo = RTCExtraInfo_ByteRTCExtInfoDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.rtcInfoExtra = RTCExtraInfo_RTCInfoExtraDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.rtcBusinessId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.rtcOther = RTCExtraInfo_RTCOtherDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.interactClientType = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRTCExtraInfo_RTCMixBase(): RTCExtraInfo_RTCMixBase {
  return { bitrate: 0 };
}

export const RTCExtraInfo_RTCMixBaseDecoder: MessageFns<RTCExtraInfo_RTCMixBase> = {
  encode(message: RTCExtraInfo_RTCMixBase, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bitrate !== 0) {
      writer.uint32(8).int32(message.bitrate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RTCExtraInfo_RTCMixBase {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRTCExtraInfo_RTCMixBase();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.bitrate = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRTCExtraInfo_ByteRTCExtInfo(): RTCExtraInfo_ByteRTCExtInfo {
  return { defaultSignaling: 0 };
}

export const RTCExtraInfo_ByteRTCExtInfoDecoder: MessageFns<RTCExtraInfo_ByteRTCExtInfo> = {
  encode(message: RTCExtraInfo_ByteRTCExtInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.defaultSignaling !== 0) {
      writer.uint32(8).int32(message.defaultSignaling);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RTCExtraInfo_ByteRTCExtInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRTCExtraInfo_ByteRTCExtInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.defaultSignaling = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRTCExtraInfo_RTCInfoExtra(): RTCExtraInfo_RTCInfoExtra {
  return { version: "" };
}

export const RTCExtraInfo_RTCInfoExtraDecoder: MessageFns<RTCExtraInfo_RTCInfoExtra> = {
  encode(message: RTCExtraInfo_RTCInfoExtra, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RTCExtraInfo_RTCInfoExtra {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRTCExtraInfo_RTCInfoExtra();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRTCExtraInfo_RTCOther(): RTCExtraInfo_RTCOther {
  return { transCodingSecond: 0 };
}

export const RTCExtraInfo_RTCOtherDecoder: MessageFns<RTCExtraInfo_RTCOther> = {
  encode(message: RTCExtraInfo_RTCOther, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transCodingSecond !== 0) {
      writer.uint32(8).int32(message.transCodingSecond);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RTCExtraInfo_RTCOther {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRTCExtraInfo_RTCOther();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.transCodingSecond = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRTCExtraInfo_RTCEngineConfig(): RTCExtraInfo_RTCEngineConfig {
  return { rtcAppId: "", rtcUserId: "", rtcToken: "", rtcChannelId: "0" };
}

export const RTCExtraInfo_RTCEngineConfigDecoder: MessageFns<RTCExtraInfo_RTCEngineConfig> = {
  encode(message: RTCExtraInfo_RTCEngineConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rtcAppId !== "") {
      writer.uint32(10).string(message.rtcAppId);
    }
    if (message.rtcUserId !== "") {
      writer.uint32(18).string(message.rtcUserId);
    }
    if (message.rtcToken !== "") {
      writer.uint32(26).string(message.rtcToken);
    }
    if (message.rtcChannelId !== "0") {
      writer.uint32(32).int64(message.rtcChannelId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RTCExtraInfo_RTCEngineConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRTCExtraInfo_RTCEngineConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rtcAppId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rtcUserId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rtcToken = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.rtcChannelId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRTCExtraInfo_RTCLiveVideoParam(): RTCExtraInfo_RTCLiveVideoParam {
  return { strategyId: 0, params: undefined };
}

export const RTCExtraInfo_RTCLiveVideoParamDecoder: MessageFns<RTCExtraInfo_RTCLiveVideoParam> = {
  encode(message: RTCExtraInfo_RTCLiveVideoParam, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.strategyId !== 0) {
      writer.uint32(8).int32(message.strategyId);
    }
    if (message.params !== undefined) {
      RTCExtraInfo_RTCVideoParamDecoder.encode(message.params, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RTCExtraInfo_RTCLiveVideoParam {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRTCExtraInfo_RTCLiveVideoParam();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.strategyId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.params = RTCExtraInfo_RTCVideoParamDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRTCExtraInfo_RTCVideoParam(): RTCExtraInfo_RTCVideoParam {
  return { width: 0, height: 0, fps: 0, bitrateKbps: 0 };
}

export const RTCExtraInfo_RTCVideoParamDecoder: MessageFns<RTCExtraInfo_RTCVideoParam> = {
  encode(message: RTCExtraInfo_RTCVideoParam, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.width !== 0) {
      writer.uint32(8).int32(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(16).int32(message.height);
    }
    if (message.fps !== 0) {
      writer.uint32(24).int32(message.fps);
    }
    if (message.bitrateKbps !== 0) {
      writer.uint32(32).int32(message.bitrateKbps);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RTCExtraInfo_RTCVideoParam {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRTCExtraInfo_RTCVideoParam();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.width = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.height = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.fps = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.bitrateKbps = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRTCExtraInfo_RTCBitrateMap(): RTCExtraInfo_RTCBitrateMap {
  return { xx1: 0, xx2: 0, xx3: 0, xx4: 0 };
}

export const RTCExtraInfo_RTCBitrateMapDecoder: MessageFns<RTCExtraInfo_RTCBitrateMap> = {
  encode(message: RTCExtraInfo_RTCBitrateMap, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.xx1 !== 0) {
      writer.uint32(8).int32(message.xx1);
    }
    if (message.xx2 !== 0) {
      writer.uint32(16).int32(message.xx2);
    }
    if (message.xx3 !== 0) {
      writer.uint32(24).int32(message.xx3);
    }
    if (message.xx4 !== 0) {
      writer.uint32(32).int32(message.xx4);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RTCExtraInfo_RTCBitrateMap {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRTCExtraInfo_RTCBitrateMap();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.xx1 = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.xx2 = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.xx3 = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.xx4 = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateChannelContent(): CreateChannelContent {
  return { owner: undefined, ownerLinkMicId: "" };
}

export const CreateChannelContentDecoder: MessageFns<CreateChannelContent> = {
  encode(message: CreateChannelContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.owner !== undefined) {
      PlayerDecoder.encode(message.owner, writer.uint32(10).fork()).join();
    }
    if (message.ownerLinkMicId !== "") {
      writer.uint32(18).string(message.ownerLinkMicId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateChannelContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateChannelContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.owner = PlayerDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ownerLinkMicId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListChangeContent(): ListChangeContent {
  return { listChangeType: 0, userList: undefined, linkedUserUiPositions: [], contentPos: [] };
}

export const ListChangeContentDecoder: MessageFns<ListChangeContent> = {
  encode(message: ListChangeContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.listChangeType !== 0) {
      writer.uint32(8).int32(message.listChangeType);
    }
    if (message.userList !== undefined) {
      AllListUserDecoder.encode(message.userList, writer.uint32(18).fork()).join();
    }
    for (const v of message.linkedUserUiPositions) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.contentPos) {
      ContentPositionDecoder.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListChangeContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListChangeContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.listChangeType = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userList = AllListUserDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.linkedUserUiPositions.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.contentPos.push(ContentPositionDecoder.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseContentPosition(): ContentPosition {
  return { contentID: "", contentType: 0, pos: undefined, contentLinkmicID: "", startTimeNano: "0" };
}

export const ContentPositionDecoder: MessageFns<ContentPosition> = {
  encode(message: ContentPosition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.contentID !== "") {
      writer.uint32(10).string(message.contentID);
    }
    if (message.contentType !== 0) {
      writer.uint32(16).int32(message.contentType);
    }
    if (message.pos !== undefined) {
      MicPositionDataDecoder.encode(message.pos, writer.uint32(26).fork()).join();
    }
    if (message.contentLinkmicID !== "") {
      writer.uint32(34).string(message.contentLinkmicID);
    }
    if (message.startTimeNano !== "0") {
      writer.uint32(40).int64(message.startTimeNano);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContentPosition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContentPosition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contentID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.contentType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pos = MicPositionDataDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.contentLinkmicID = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.startTimeNano = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseMicPositionData(): MicPositionData {
  return { type: 0, linkPosition: undefined };
}

export const MicPositionDataDecoder: MessageFns<MicPositionData> = {
  encode(message: MicPositionData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.linkPosition !== undefined) {
      LinkPositionDecoder.encode(message.linkPosition, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MicPositionData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMicPositionData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.linkPosition = LinkPositionDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseMultiLiveContent(): MultiLiveContent {
  return {
    applyBizContent: undefined,
    inviteBizContent: undefined,
    replyBizContent: undefined,
    permitBizContent: undefined,
    joinDirectBizContent: undefined,
    kickOutBizContent: undefined,
  };
}

export const MultiLiveContentDecoder: MessageFns<MultiLiveContent> = {
  encode(message: MultiLiveContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.applyBizContent !== undefined) {
      MultiLiveContent_ApplyBizContentDecoder.encode(message.applyBizContent, writer.uint32(10).fork()).join();
    }
    if (message.inviteBizContent !== undefined) {
      MultiLiveContent_InviteBizContentDecoder.encode(message.inviteBizContent, writer.uint32(18).fork()).join();
    }
    if (message.replyBizContent !== undefined) {
      MultiLiveContent_ReplyBizContentDecoder.encode(message.replyBizContent, writer.uint32(26).fork()).join();
    }
    if (message.permitBizContent !== undefined) {
      MultiLiveContent_PermitBizContentDecoder.encode(message.permitBizContent, writer.uint32(34).fork()).join();
    }
    if (message.joinDirectBizContent !== undefined) {
      MultiLiveContent_JoinDirectBizContentDecoder.encode(message.joinDirectBizContent, writer.uint32(42).fork()).join();
    }
    if (message.kickOutBizContent !== undefined) {
      MultiLiveContent_KickOutBizContentDecoder.encode(message.kickOutBizContent, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiLiveContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiLiveContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.applyBizContent = MultiLiveContent_ApplyBizContentDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.inviteBizContent = MultiLiveContent_InviteBizContentDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.replyBizContent = MultiLiveContent_ReplyBizContentDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.permitBizContent = MultiLiveContent_PermitBizContentDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.joinDirectBizContent = MultiLiveContent_JoinDirectBizContentDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.kickOutBizContent = MultiLiveContent_KickOutBizContentDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseMultiLiveContent_ApplyBizContent(): MultiLiveContent_ApplyBizContent {
  return { user: undefined };
}

export const MultiLiveContent_ApplyBizContentDecoder: MessageFns<MultiLiveContent_ApplyBizContent> = {
  encode(message: MultiLiveContent_ApplyBizContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      UserDecoder.encode(message.user, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiLiveContent_ApplyBizContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiLiveContent_ApplyBizContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = UserDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseMultiLiveContent_JoinDirectBizContent(): MultiLiveContent_JoinDirectBizContent {
  return { replyImMsgId: "0", outsideRoomInviteSource: 0 };
}

export const MultiLiveContent_JoinDirectBizContentDecoder: MessageFns<MultiLiveContent_JoinDirectBizContent> = {
  encode(message: MultiLiveContent_JoinDirectBizContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.replyImMsgId !== "0") {
      writer.uint32(8).int64(message.replyImMsgId);
    }
    if (message.outsideRoomInviteSource !== 0) {
      writer.uint32(16).int32(message.outsideRoomInviteSource);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiLiveContent_JoinDirectBizContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiLiveContent_JoinDirectBizContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.replyImMsgId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.outsideRoomInviteSource = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseMultiLiveContent_InviteBizContent(): MultiLiveContent_InviteBizContent {
  return {
    anchorSettingInfo: undefined,
    inviteSource: 0,
    operatorUserInfo: undefined,
    operatorLinkAdminType: 0,
    inviteeUserInfo: undefined,
    shareRevenueSetting: 0,
  };
}

export const MultiLiveContent_InviteBizContentDecoder: MessageFns<MultiLiveContent_InviteBizContent> = {
  encode(message: MultiLiveContent_InviteBizContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.anchorSettingInfo !== undefined) {
      MultiLiveAnchorPanelSettingsDecoder.encode(message.anchorSettingInfo, writer.uint32(10).fork()).join();
    }
    if (message.inviteSource !== 0) {
      writer.uint32(16).int32(message.inviteSource);
    }
    if (message.operatorUserInfo !== undefined) {
      UserDecoder.encode(message.operatorUserInfo, writer.uint32(26).fork()).join();
    }
    if (message.operatorLinkAdminType !== 0) {
      writer.uint32(32).int32(message.operatorLinkAdminType);
    }
    if (message.inviteeUserInfo !== undefined) {
      UserDecoder.encode(message.inviteeUserInfo, writer.uint32(42).fork()).join();
    }
    if (message.shareRevenueSetting !== 0) {
      writer.uint32(48).int32(message.shareRevenueSetting);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiLiveContent_InviteBizContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiLiveContent_InviteBizContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.anchorSettingInfo = MultiLiveAnchorPanelSettingsDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.inviteSource = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.operatorUserInfo = UserDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.operatorLinkAdminType = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.inviteeUserInfo = UserDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.shareRevenueSetting = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseMultiLiveContent_ReplyBizContent(): MultiLiveContent_ReplyBizContent {
  return { linkType: 0, isTurnOffInvitation: 0, replyUserInfo: undefined };
}

export const MultiLiveContent_ReplyBizContentDecoder: MessageFns<MultiLiveContent_ReplyBizContent> = {
  encode(message: MultiLiveContent_ReplyBizContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.linkType !== 0) {
      writer.uint32(8).int32(message.linkType);
    }
    if (message.isTurnOffInvitation !== 0) {
      writer.uint32(16).int32(message.isTurnOffInvitation);
    }
    if (message.replyUserInfo !== undefined) {
      UserDecoder.encode(message.replyUserInfo, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiLiveContent_ReplyBizContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiLiveContent_ReplyBizContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.linkType = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isTurnOffInvitation = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.replyUserInfo = UserDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseMultiLiveContent_PermitBizContent(): MultiLiveContent_PermitBizContent {
  return {
    anchorSettingInfo: undefined,
    expireTimestamp: "0",
    operatorUserInfo: undefined,
    operatorLinkAdminType: 0,
    linkUserType: 0,
  };
}

export const MultiLiveContent_PermitBizContentDecoder: MessageFns<MultiLiveContent_PermitBizContent> = {
  encode(message: MultiLiveContent_PermitBizContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.anchorSettingInfo !== undefined) {
      MultiLiveAnchorPanelSettingsDecoder.encode(message.anchorSettingInfo, writer.uint32(10).fork()).join();
    }
    if (message.expireTimestamp !== "0") {
      writer.uint32(16).int64(message.expireTimestamp);
    }
    if (message.operatorUserInfo !== undefined) {
      UserDecoder.encode(message.operatorUserInfo, writer.uint32(26).fork()).join();
    }
    if (message.operatorLinkAdminType !== 0) {
      writer.uint32(32).int32(message.operatorLinkAdminType);
    }
    if (message.linkUserType !== 0) {
      writer.uint32(40).int32(message.linkUserType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiLiveContent_PermitBizContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiLiveContent_PermitBizContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.anchorSettingInfo = MultiLiveAnchorPanelSettingsDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.expireTimestamp = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.operatorUserInfo = UserDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.operatorLinkAdminType = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.linkUserType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseMultiLiveContent_KickOutBizContent(): MultiLiveContent_KickOutBizContent {
  return { operatorUserInfo: undefined, operatorLinkAdminType: 0, kickPlayerUserInfo: undefined };
}

export const MultiLiveContent_KickOutBizContentDecoder: MessageFns<MultiLiveContent_KickOutBizContent> = {
  encode(message: MultiLiveContent_KickOutBizContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operatorUserInfo !== undefined) {
      UserDecoder.encode(message.operatorUserInfo, writer.uint32(10).fork()).join();
    }
    if (message.operatorLinkAdminType !== 0) {
      writer.uint32(16).int32(message.operatorLinkAdminType);
    }
    if (message.kickPlayerUserInfo !== undefined) {
      UserDecoder.encode(message.kickPlayerUserInfo, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiLiveContent_KickOutBizContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiLiveContent_KickOutBizContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.operatorUserInfo = UserDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.operatorLinkAdminType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.kickPlayerUserInfo = UserDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseInviteContent(): InviteContent {
  return {
    invitor: undefined,
    inviteeRtcExtInfo: undefined,
    invitorLinkMicId: "",
    inviteeLinkMicId: "",
    isOwner: false,
    pos: undefined,
    dsl: undefined,
    invitee: undefined,
    operator: undefined,
  };
}

export const InviteContentDecoder: MessageFns<InviteContent> = {
  encode(message: InviteContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.invitor !== undefined) {
      PlayerDecoder.encode(message.invitor, writer.uint32(10).fork()).join();
    }
    if (message.inviteeRtcExtInfo !== undefined) {
      RTCExtraInfoDecoder.encode(message.inviteeRtcExtInfo, writer.uint32(18).fork()).join();
    }
    if (message.invitorLinkMicId !== "") {
      writer.uint32(26).string(message.invitorLinkMicId);
    }
    if (message.inviteeLinkMicId !== "") {
      writer.uint32(34).string(message.inviteeLinkMicId);
    }
    if (message.isOwner !== false) {
      writer.uint32(40).bool(message.isOwner);
    }
    if (message.pos !== undefined) {
      PositionDecoder.encode(message.pos, writer.uint32(50).fork()).join();
    }
    if (message.dsl !== undefined) {
      DSLConfigDecoder.encode(message.dsl, writer.uint32(58).fork()).join();
    }
    if (message.invitee !== undefined) {
      UserDecoder.encode(message.invitee, writer.uint32(66).fork()).join();
    }
    if (message.operator !== undefined) {
      UserDecoder.encode(message.operator, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InviteContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInviteContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.invitor = PlayerDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.inviteeRtcExtInfo = RTCExtraInfoDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.invitorLinkMicId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.inviteeLinkMicId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isOwner = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.pos = PositionDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.dsl = DSLConfigDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.invitee = UserDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.operator = UserDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseApplyContent(): ApplyContent {
  return { applier: undefined, applierLinkMicId: "" };
}

export const ApplyContentDecoder: MessageFns<ApplyContent> = {
  encode(message: ApplyContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.applier !== undefined) {
      PlayerDecoder.encode(message.applier, writer.uint32(10).fork()).join();
    }
    if (message.applierLinkMicId !== "") {
      writer.uint32(18).string(message.applierLinkMicId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApplyContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApplyContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.applier = PlayerDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.applierLinkMicId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePermitApplyContent(): PermitApplyContent {
  return {
    permiter: undefined,
    permiterLinkMicId: "",
    applierPos: undefined,
    replyStatus: 0,
    dsl: undefined,
    applier: undefined,
    operator: undefined,
    applierLinkMicId: "",
  };
}

export const PermitApplyContentDecoder: MessageFns<PermitApplyContent> = {
  encode(message: PermitApplyContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.permiter !== undefined) {
      PlayerDecoder.encode(message.permiter, writer.uint32(10).fork()).join();
    }
    if (message.permiterLinkMicId !== "") {
      writer.uint32(18).string(message.permiterLinkMicId);
    }
    if (message.applierPos !== undefined) {
      PositionDecoder.encode(message.applierPos, writer.uint32(26).fork()).join();
    }
    if (message.replyStatus !== 0) {
      writer.uint32(32).int32(message.replyStatus);
    }
    if (message.dsl !== undefined) {
      DSLConfigDecoder.encode(message.dsl, writer.uint32(42).fork()).join();
    }
    if (message.applier !== undefined) {
      UserDecoder.encode(message.applier, writer.uint32(50).fork()).join();
    }
    if (message.operator !== undefined) {
      UserDecoder.encode(message.operator, writer.uint32(58).fork()).join();
    }
    if (message.applierLinkMicId !== "") {
      writer.uint32(66).string(message.applierLinkMicId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PermitApplyContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePermitApplyContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.permiter = PlayerDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.permiterLinkMicId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.applierPos = PositionDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.replyStatus = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.dsl = DSLConfigDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.applier = UserDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.operator = UserDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.applierLinkMicId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseReplyInviteContent(): ReplyInviteContent {
  return {
    invitee: undefined,
    replyStatus: 0,
    inviteeLinkMicId: "",
    inviteePos: undefined,
    inviteOperatorUser: undefined,
    linkedUserUiPositions: [],
    uiPos: [],
  };
}

export const ReplyInviteContentDecoder: MessageFns<ReplyInviteContent> = {
  encode(message: ReplyInviteContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.invitee !== undefined) {
      PlayerDecoder.encode(message.invitee, writer.uint32(10).fork()).join();
    }
    if (message.replyStatus !== 0) {
      writer.uint32(16).int32(message.replyStatus);
    }
    if (message.inviteeLinkMicId !== "") {
      writer.uint32(26).string(message.inviteeLinkMicId);
    }
    if (message.inviteePos !== undefined) {
      PositionDecoder.encode(message.inviteePos, writer.uint32(34).fork()).join();
    }
    if (message.inviteOperatorUser !== undefined) {
      PlayerDecoder.encode(message.inviteOperatorUser, writer.uint32(42).fork()).join();
    }
    for (const v of message.linkedUserUiPositions) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.uiPos) {
      PosIdentityDecoder.encode(v!, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReplyInviteContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReplyInviteContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.invitee = PlayerDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.replyStatus = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.inviteeLinkMicId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.inviteePos = PositionDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.inviteOperatorUser = PlayerDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.linkedUserUiPositions.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.uiPos.push(PosIdentityDecoder.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseKickOutContent(): KickOutContent {
  return { offliner: undefined, kickoutReason: 0, linkedUserUiPositions: [], uiPos: [] };
}

export const KickOutContentDecoder: MessageFns<KickOutContent> = {
  encode(message: KickOutContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.offliner !== undefined) {
      PlayerDecoder.encode(message.offliner, writer.uint32(10).fork()).join();
    }
    if (message.kickoutReason !== 0) {
      writer.uint32(16).int32(message.kickoutReason);
    }
    for (const v of message.linkedUserUiPositions) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.uiPos) {
      PosIdentityDecoder.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KickOutContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKickOutContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.offliner = PlayerDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.kickoutReason = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.linkedUserUiPositions.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.uiPos.push(PosIdentityDecoder.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePosIdentity(): PosIdentity {
  return { type: 0, value: "" };
}

export const PosIdentityDecoder: MessageFns<PosIdentity> = {
  encode(message: PosIdentity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PosIdentity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePosIdentity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCancelApplyContent(): CancelApplyContent {
  return { applier: undefined, applierLinkMicId: "" };
}

export const CancelApplyContentDecoder: MessageFns<CancelApplyContent> = {
  encode(message: CancelApplyContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.applier !== undefined) {
      PlayerDecoder.encode(message.applier, writer.uint32(10).fork()).join();
    }
    if (message.applierLinkMicId !== "") {
      writer.uint32(18).string(message.applierLinkMicId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelApplyContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelApplyContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.applier = PlayerDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.applierLinkMicId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCancelInviteContent(): CancelInviteContent {
  return { invitor: undefined, invitorLinkMicId: "", inviteeLinkMicId: "", inviteSeqId: "0", invitee: undefined };
}

export const CancelInviteContentDecoder: MessageFns<CancelInviteContent> = {
  encode(message: CancelInviteContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.invitor !== undefined) {
      PlayerDecoder.encode(message.invitor, writer.uint32(10).fork()).join();
    }
    if (message.invitorLinkMicId !== "") {
      writer.uint32(18).string(message.invitorLinkMicId);
    }
    if (message.inviteeLinkMicId !== "") {
      writer.uint32(26).string(message.inviteeLinkMicId);
    }
    if (message.inviteSeqId !== "0") {
      writer.uint32(32).int64(message.inviteSeqId);
    }
    if (message.invitee !== undefined) {
      PlayerDecoder.encode(message.invitee, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelInviteContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelInviteContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.invitor = PlayerDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.invitorLinkMicId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.inviteeLinkMicId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.inviteSeqId = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.invitee = PlayerDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLeaveContent(): LeaveContent {
  return { leaver: undefined, leaveReason: "0", linkedUserUiPositions: [], uiPos: [] };
}

export const LeaveContentDecoder: MessageFns<LeaveContent> = {
  encode(message: LeaveContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.leaver !== undefined) {
      PlayerDecoder.encode(message.leaver, writer.uint32(10).fork()).join();
    }
    if (message.leaveReason !== "0") {
      writer.uint32(16).int64(message.leaveReason);
    }
    for (const v of message.linkedUserUiPositions) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.uiPos) {
      PosIdentityDecoder.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LeaveContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLeaveContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.leaver = PlayerDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.leaveReason = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.linkedUserUiPositions.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.uiPos.push(PosIdentityDecoder.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseFinishChannelContent(): FinishChannelContent {
  return { owner: undefined, finishReason: "0" };
}

export const FinishChannelContentDecoder: MessageFns<FinishChannelContent> = {
  encode(message: FinishChannelContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.owner !== undefined) {
      PlayerDecoder.encode(message.owner, writer.uint32(10).fork()).join();
    }
    if (message.finishReason !== "0") {
      writer.uint32(16).int64(message.finishReason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FinishChannelContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinishChannelContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.owner = PlayerDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.finishReason = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseJoinDirectContent(): JoinDirectContent {
  return { joiner: undefined, allUsers: undefined };
}

export const JoinDirectContentDecoder: MessageFns<JoinDirectContent> = {
  encode(message: JoinDirectContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.joiner !== undefined) {
      LinkLayerListUserDecoder.encode(message.joiner, writer.uint32(10).fork()).join();
    }
    if (message.allUsers !== undefined) {
      AllListUserDecoder.encode(message.allUsers, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JoinDirectContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJoinDirectContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.joiner = LinkLayerListUserDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.allUsers = AllListUserDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLeaveJoinGroupContent(): LeaveJoinGroupContent {
  return { operator: undefined, groupChannelId: "0", leaveSource: "", linkedUserUiPositions: [] };
}

export const LeaveJoinGroupContentDecoder: MessageFns<LeaveJoinGroupContent> = {
  encode(message: LeaveJoinGroupContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operator !== undefined) {
      GroupPlayerDecoder.encode(message.operator, writer.uint32(10).fork()).join();
    }
    if (message.groupChannelId !== "0") {
      writer.uint32(16).int64(message.groupChannelId);
    }
    if (message.leaveSource !== "") {
      writer.uint32(26).string(message.leaveSource);
    }
    for (const v of message.linkedUserUiPositions) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LeaveJoinGroupContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLeaveJoinGroupContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.operator = GroupPlayerDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.groupChannelId = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.leaveSource = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.linkedUserUiPositions.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePermitJoinGroupContent(): PermitJoinGroupContent {
  return {
    approver: undefined,
    agreeStatus: 0,
    type: 0,
    groupExtInfoList: [],
    groupUser: undefined,
    migrationDetails: undefined,
    linkedUserUiPositions: [],
  };
}

export const PermitJoinGroupContentDecoder: MessageFns<PermitJoinGroupContent> = {
  encode(message: PermitJoinGroupContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.approver !== undefined) {
      GroupPlayerDecoder.encode(message.approver, writer.uint32(10).fork()).join();
    }
    if (message.agreeStatus !== 0) {
      writer.uint32(16).int32(message.agreeStatus);
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    for (const v of message.groupExtInfoList) {
      RTCExtraInfoDecoder.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.groupUser !== undefined) {
      GroupChannelAllUserDecoder.encode(message.groupUser, writer.uint32(42).fork()).join();
    }
    if (message.migrationDetails !== undefined) {
      MigrationDetailsDecoder.encode(message.migrationDetails, writer.uint32(50).fork()).join();
    }
    for (const v of message.linkedUserUiPositions) {
      writer.uint32(58).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PermitJoinGroupContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePermitJoinGroupContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.approver = GroupPlayerDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.agreeStatus = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.groupExtInfoList.push(RTCExtraInfoDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.groupUser = GroupChannelAllUserDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.migrationDetails = MigrationDetailsDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.linkedUserUiPositions.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseMigrationDetails(): MigrationDetails {
  return { isMigrate: false, sourceGroupChannelId: "0", targetGroupChannelId: "0" };
}

export const MigrationDetailsDecoder: MessageFns<MigrationDetails> = {
  encode(message: MigrationDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isMigrate !== false) {
      writer.uint32(8).bool(message.isMigrate);
    }
    if (message.sourceGroupChannelId !== "0") {
      writer.uint32(16).int64(message.sourceGroupChannelId);
    }
    if (message.targetGroupChannelId !== "0") {
      writer.uint32(24).int64(message.targetGroupChannelId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MigrationDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMigrationDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isMigrate = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.sourceGroupChannelId = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.targetGroupChannelId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCancelJoinGroupContent(): CancelJoinGroupContent {
  return { leaverList: [], operator: undefined, type: 0, groupUser: undefined };
}

export const CancelJoinGroupContentDecoder: MessageFns<CancelJoinGroupContent> = {
  encode(message: CancelJoinGroupContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.leaverList) {
      GroupPlayerDecoder.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.operator !== undefined) {
      GroupPlayerDecoder.encode(message.operator, writer.uint32(18).fork()).join();
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (message.groupUser !== undefined) {
      GroupChannelAllUserDecoder.encode(message.groupUser, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelJoinGroupContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelJoinGroupContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.leaverList.push(GroupPlayerDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.operator = GroupPlayerDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.groupUser = GroupChannelAllUserDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseP2PGroupChangeContent(): P2PGroupChangeContent {
  return { groupExtInfoList: [], groupUser: undefined, migrationDetails: undefined, contentPos: [] };
}

export const P2PGroupChangeContentDecoder: MessageFns<P2PGroupChangeContent> = {
  encode(message: P2PGroupChangeContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.groupExtInfoList) {
      RTCExtraInfoDecoder.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.groupUser !== undefined) {
      GroupChannelAllUserDecoder.encode(message.groupUser, writer.uint32(18).fork()).join();
    }
    if (message.migrationDetails !== undefined) {
      MigrationDetailsDecoder.encode(message.migrationDetails, writer.uint32(26).fork()).join();
    }
    for (const v of message.contentPos) {
      ContentPositionDecoder.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): P2PGroupChangeContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseP2PGroupChangeContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.groupExtInfoList.push(RTCExtraInfoDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.groupUser = GroupChannelAllUserDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.migrationDetails = MigrationDetailsDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.contentPos.push(ContentPositionDecoder.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGroupChangeContent(): GroupChangeContent {
  return { groupUser: undefined, linkedUserUiPositions: [] };
}

export const GroupChangeContentDecoder: MessageFns<GroupChangeContent> = {
  encode(message: GroupChangeContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupUser !== undefined) {
      GroupChannelAllUserDecoder.encode(message.groupUser, writer.uint32(10).fork()).join();
    }
    for (const v of message.linkedUserUiPositions) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupChangeContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupChangeContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.groupUser = GroupChannelAllUserDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.linkedUserUiPositions.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBusinessContent(): BusinessContent {
  return { overLength: "0", multiLiveContent: undefined, cohostContent: undefined };
}

export const BusinessContentDecoder: MessageFns<BusinessContent> = {
  encode(message: BusinessContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.overLength !== "0") {
      writer.uint32(8).int64(message.overLength);
    }
    if (message.multiLiveContent !== undefined) {
      MultiLiveContentDecoder.encode(message.multiLiveContent, writer.uint32(802).fork()).join();
    }
    if (message.cohostContent !== undefined) {
      BusinessContent_CohostContentDecoder.encode(message.cohostContent, writer.uint32(1602).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BusinessContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBusinessContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.overLength = reader.int64().toString();
          continue;
        }
        case 100: {
          if (tag !== 802) {
            break;
          }

          message.multiLiveContent = MultiLiveContentDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 200: {
          if (tag !== 1602) {
            break;
          }

          message.cohostContent = BusinessContent_CohostContentDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBusinessContent_CohostContent(): BusinessContent_CohostContent {
  return { joinGroupBizContent: undefined, permitJoinGroupBizContent: undefined, listChangeBizContent: undefined };
}

export const BusinessContent_CohostContentDecoder: MessageFns<BusinessContent_CohostContent> = {
  encode(message: BusinessContent_CohostContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.joinGroupBizContent !== undefined) {
      BusinessContent_JoinGroupBizContentDecoder.encode(message.joinGroupBizContent, writer.uint32(10).fork()).join();
    }
    if (message.permitJoinGroupBizContent !== undefined) {
      BusinessContent_PermitJoinGroupBizContentDecoder.encode(message.permitJoinGroupBizContent, writer.uint32(18).fork())
        .join();
    }
    if (message.listChangeBizContent !== undefined) {
      BusinessContent_ListChangeBizContentDecoder.encode(message.listChangeBizContent, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BusinessContent_CohostContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBusinessContent_CohostContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.joinGroupBizContent = BusinessContent_JoinGroupBizContentDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.permitJoinGroupBizContent = BusinessContent_PermitJoinGroupBizContentDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.listChangeBizContent = BusinessContent_ListChangeBizContentDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBusinessContent_PermitJoinGroupBizContent(): BusinessContent_PermitJoinGroupBizContent {
  return { replyStatus: 0, sourceType: 0 };
}

export const BusinessContent_PermitJoinGroupBizContentDecoder: MessageFns<BusinessContent_PermitJoinGroupBizContent> = {
  encode(message: BusinessContent_PermitJoinGroupBizContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.replyStatus !== 0) {
      writer.uint32(8).int32(message.replyStatus);
    }
    if (message.sourceType !== 0) {
      writer.uint32(16).int32(message.sourceType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BusinessContent_PermitJoinGroupBizContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBusinessContent_PermitJoinGroupBizContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.replyStatus = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.sourceType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBusinessContent_ListChangeBizContent(): BusinessContent_ListChangeBizContent {
  return { userInfos: {}, waitingUsers: [] };
}

export const BusinessContent_ListChangeBizContentDecoder: MessageFns<BusinessContent_ListChangeBizContent> = {
  encode(message: BusinessContent_ListChangeBizContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.userInfos).forEach(([key, value]) => {
      BusinessContent_ListChangeBizContent_UserInfosEntryDecoder.encode({ key: key as any, value }, writer.uint32(10).fork())
        .join();
    });
    for (const v of message.waitingUsers) {
      BusinessContent_ListChangeBizContent_VirtualWaitingUserDecoder.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BusinessContent_ListChangeBizContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBusinessContent_ListChangeBizContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = BusinessContent_ListChangeBizContent_UserInfosEntryDecoder.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.userInfos[entry1.key] = entry1.value;
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.waitingUsers.push(
            BusinessContent_ListChangeBizContent_VirtualWaitingUserDecoder.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBusinessContent_ListChangeBizContent_UserInfosEntry(): BusinessContent_ListChangeBizContent_UserInfosEntry {
  return { key: "0", value: undefined };
}

export const BusinessContent_ListChangeBizContent_UserInfosEntryDecoder: MessageFns<BusinessContent_ListChangeBizContent_UserInfosEntry> = {
  encode(
    message: BusinessContent_ListChangeBizContent_UserInfosEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "0") {
      writer.uint32(8).int64(message.key);
    }
    if (message.value !== undefined) {
      BusinessContent_CohostUserInfoDecoder.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BusinessContent_ListChangeBizContent_UserInfosEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBusinessContent_ListChangeBizContent_UserInfosEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = BusinessContent_CohostUserInfoDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBusinessContent_ListChangeBizContent_VirtualWaitingUser(): BusinessContent_ListChangeBizContent_VirtualWaitingUser {
  return { userId: "0", timestamp: "0", avatars: [] };
}

export const BusinessContent_ListChangeBizContent_VirtualWaitingUserDecoder: MessageFns<BusinessContent_ListChangeBizContent_VirtualWaitingUser> = {
  encode(
    message: BusinessContent_ListChangeBizContent_VirtualWaitingUser,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.userId !== "0") {
      writer.uint32(8).int64(message.userId);
    }
    if (message.timestamp !== "0") {
      writer.uint32(16).int64(message.timestamp);
    }
    for (const v of message.avatars) {
      ImageDecoder.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BusinessContent_ListChangeBizContent_VirtualWaitingUser {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBusinessContent_ListChangeBizContent_VirtualWaitingUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.timestamp = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.avatars.push(ImageDecoder.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBusinessContent_CohostUserInfo(): BusinessContent_CohostUserInfo {
  return {
    permissionType: "0",
    sourceType: 0,
    isLowVersion: false,
    bestTeammateUid: "0",
    hasTopicPerm: false,
    streamConfig: undefined,
    inDifferentInviteTypeControlGroup: false,
    nickname: "",
    displayId: "",
    avatarThumb: undefined,
    followStatus: "0",
    userIdStr: "",
  };
}

export const BusinessContent_CohostUserInfoDecoder: MessageFns<BusinessContent_CohostUserInfo> = {
  encode(message: BusinessContent_CohostUserInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.permissionType !== "0") {
      writer.uint32(8).int64(message.permissionType);
    }
    if (message.sourceType !== 0) {
      writer.uint32(16).int32(message.sourceType);
    }
    if (message.isLowVersion !== false) {
      writer.uint32(24).bool(message.isLowVersion);
    }
    if (message.bestTeammateUid !== "0") {
      writer.uint32(32).int64(message.bestTeammateUid);
    }
    if (message.hasTopicPerm !== false) {
      writer.uint32(40).bool(message.hasTopicPerm);
    }
    if (message.streamConfig !== undefined) {
      BusinessContent_CohostUserInfo_CohostStreamConfigDecoder.encode(message.streamConfig, writer.uint32(50).fork()).join();
    }
    if (message.inDifferentInviteTypeControlGroup !== false) {
      writer.uint32(56).bool(message.inDifferentInviteTypeControlGroup);
    }
    if (message.nickname !== "") {
      writer.uint32(90).string(message.nickname);
    }
    if (message.displayId !== "") {
      writer.uint32(98).string(message.displayId);
    }
    if (message.avatarThumb !== undefined) {
      ImageDecoder.encode(message.avatarThumb, writer.uint32(106).fork()).join();
    }
    if (message.followStatus !== "0") {
      writer.uint32(112).int64(message.followStatus);
    }
    if (message.userIdStr !== "") {
      writer.uint32(122).string(message.userIdStr);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BusinessContent_CohostUserInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBusinessContent_CohostUserInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.permissionType = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.sourceType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isLowVersion = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.bestTeammateUid = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.hasTopicPerm = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.streamConfig = BusinessContent_CohostUserInfo_CohostStreamConfigDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.inDifferentInviteTypeControlGroup = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.nickname = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.displayId = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.avatarThumb = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.followStatus = reader.int64().toString();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.userIdStr = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBusinessContent_CohostUserInfo_CohostStreamConfig(): BusinessContent_CohostUserInfo_CohostStreamConfig {
  return { screenShareStreamId: "" };
}

export const BusinessContent_CohostUserInfo_CohostStreamConfigDecoder: MessageFns<BusinessContent_CohostUserInfo_CohostStreamConfig> = {
  encode(
    message: BusinessContent_CohostUserInfo_CohostStreamConfig,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.screenShareStreamId !== "") {
      writer.uint32(10).string(message.screenShareStreamId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BusinessContent_CohostUserInfo_CohostStreamConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBusinessContent_CohostUserInfo_CohostStreamConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.screenShareStreamId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBusinessContent_JoinGroupBizContent(): BusinessContent_JoinGroupBizContent {
  return {
    fromRoomAgeRestricted: 0,
    fromTag: undefined,
    dialog: undefined,
    punishInfo: undefined,
    topicInfo: undefined,
    algoRequestId: "",
    cohostLayoutMode: 0,
    tag: undefined,
    gameTag: undefined,
    newUserEducation: "",
    joinGroupMsgExtra: undefined,
  };
}

export const BusinessContent_JoinGroupBizContentDecoder: MessageFns<BusinessContent_JoinGroupBizContent> = {
  encode(message: BusinessContent_JoinGroupBizContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fromRoomAgeRestricted !== 0) {
      writer.uint32(8).int32(message.fromRoomAgeRestricted);
    }
    if (message.fromTag !== undefined) {
      BusinessContent_TagDecoder.encode(message.fromTag, writer.uint32(18).fork()).join();
    }
    if (message.dialog !== undefined) {
      BusinessContent_PerceptionDialogInfoDecoder.encode(message.dialog, writer.uint32(26).fork()).join();
    }
    if (message.punishInfo !== undefined) {
      PunishEventInfoDecoder.encode(message.punishInfo, writer.uint32(34).fork()).join();
    }
    if (message.topicInfo !== undefined) {
      CohostTopicDecoder.encode(message.topicInfo, writer.uint32(42).fork()).join();
    }
    if (message.algoRequestId !== "") {
      writer.uint32(50).string(message.algoRequestId);
    }
    if (message.cohostLayoutMode !== 0) {
      writer.uint32(56).int32(message.cohostLayoutMode);
    }
    if (message.tag !== undefined) {
      BusinessContent_JoinGroupBizContent_TagV2Decoder.encode(message.tag, writer.uint32(66).fork()).join();
    }
    if (message.gameTag !== undefined) {
      BusinessContent_JoinGroupBizContent_RivalsGameTagDecoder.encode(message.gameTag, writer.uint32(74).fork()).join();
    }
    if (message.newUserEducation !== "") {
      writer.uint32(90).string(message.newUserEducation);
    }
    if (message.joinGroupMsgExtra !== undefined) {
      BusinessContent_JoinGroupMessageExtraDecoder.encode(message.joinGroupMsgExtra, writer.uint32(810).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BusinessContent_JoinGroupBizContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBusinessContent_JoinGroupBizContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.fromRoomAgeRestricted = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fromTag = BusinessContent_TagDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.dialog = BusinessContent_PerceptionDialogInfoDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.punishInfo = PunishEventInfoDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.topicInfo = CohostTopicDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.algoRequestId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.cohostLayoutMode = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.tag = BusinessContent_JoinGroupBizContent_TagV2Decoder.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.gameTag = BusinessContent_JoinGroupBizContent_RivalsGameTagDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.newUserEducation = reader.string();
          continue;
        }
        case 101: {
          if (tag !== 810) {
            break;
          }

          message.joinGroupMsgExtra = BusinessContent_JoinGroupMessageExtraDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBusinessContent_JoinGroupBizContent_RivalsGameTag(): BusinessContent_JoinGroupBizContent_RivalsGameTag {
  return { tagId: "0", tagDisplayText: "" };
}

export const BusinessContent_JoinGroupBizContent_RivalsGameTagDecoder: MessageFns<BusinessContent_JoinGroupBizContent_RivalsGameTag> = {
  encode(
    message: BusinessContent_JoinGroupBizContent_RivalsGameTag,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.tagId !== "0") {
      writer.uint32(8).int64(message.tagId);
    }
    if (message.tagDisplayText !== "") {
      writer.uint32(18).string(message.tagDisplayText);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BusinessContent_JoinGroupBizContent_RivalsGameTag {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBusinessContent_JoinGroupBizContent_RivalsGameTag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.tagId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tagDisplayText = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBusinessContent_JoinGroupBizContent_TagV2(): BusinessContent_JoinGroupBizContent_TagV2 {
  return {
    tagClassification: 0,
    tagType: 0,
    tagValue: "",
    starlingKey: "",
    secondDegreeRelationContent: undefined,
    cohostHistoryDay: "0",
    similarInterestContent: undefined,
  };
}

export const BusinessContent_JoinGroupBizContent_TagV2Decoder: MessageFns<BusinessContent_JoinGroupBizContent_TagV2> = {
  encode(message: BusinessContent_JoinGroupBizContent_TagV2, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tagClassification !== 0) {
      writer.uint32(8).int32(message.tagClassification);
    }
    if (message.tagType !== 0) {
      writer.uint32(16).int32(message.tagType);
    }
    if (message.tagValue !== "") {
      writer.uint32(26).string(message.tagValue);
    }
    if (message.starlingKey !== "") {
      writer.uint32(34).string(message.starlingKey);
    }
    if (message.secondDegreeRelationContent !== undefined) {
      BusinessContent_JoinGroupBizContent_TagV2_SecondDegreeRelationContentDecoder.encode(
        message.secondDegreeRelationContent,
        writer.uint32(82).fork(),
      ).join();
    }
    if (message.cohostHistoryDay !== "0") {
      writer.uint32(88).int64(message.cohostHistoryDay);
    }
    if (message.similarInterestContent !== undefined) {
      BusinessContent_JoinGroupBizContent_TagV2_SimilarInterestContentDecoder.encode(
        message.similarInterestContent,
        writer.uint32(98).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BusinessContent_JoinGroupBizContent_TagV2 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBusinessContent_JoinGroupBizContent_TagV2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.tagClassification = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.tagType = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tagValue = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.starlingKey = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.secondDegreeRelationContent = BusinessContent_JoinGroupBizContent_TagV2_SecondDegreeRelationContentDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.cohostHistoryDay = reader.int64().toString();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.similarInterestContent = BusinessContent_JoinGroupBizContent_TagV2_SimilarInterestContentDecoder.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBusinessContent_JoinGroupBizContent_TagV2_UserInfo(): BusinessContent_JoinGroupBizContent_TagV2_UserInfo {
  return { userId: "0", nickName: "", avatarThumb: undefined };
}

export const BusinessContent_JoinGroupBizContent_TagV2_UserInfoDecoder: MessageFns<BusinessContent_JoinGroupBizContent_TagV2_UserInfo> = {
  encode(
    message: BusinessContent_JoinGroupBizContent_TagV2_UserInfo,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.userId !== "0") {
      writer.uint32(8).int64(message.userId);
    }
    if (message.nickName !== "") {
      writer.uint32(18).string(message.nickName);
    }
    if (message.avatarThumb !== undefined) {
      ImageDecoder.encode(message.avatarThumb, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BusinessContent_JoinGroupBizContent_TagV2_UserInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBusinessContent_JoinGroupBizContent_TagV2_UserInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nickName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.avatarThumb = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBusinessContent_JoinGroupBizContent_TagV2_SecondDegreeRelationContent(): BusinessContent_JoinGroupBizContent_TagV2_SecondDegreeRelationContent {
  return { relatedUsers: [], totalRelatedUserCnt: "0" };
}

export const BusinessContent_JoinGroupBizContent_TagV2_SecondDegreeRelationContentDecoder: MessageFns<BusinessContent_JoinGroupBizContent_TagV2_SecondDegreeRelationContent> = {
  encode(
    message: BusinessContent_JoinGroupBizContent_TagV2_SecondDegreeRelationContent,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.relatedUsers) {
      BusinessContent_JoinGroupBizContent_TagV2_UserInfoDecoder.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalRelatedUserCnt !== "0") {
      writer.uint32(16).int64(message.totalRelatedUserCnt);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): BusinessContent_JoinGroupBizContent_TagV2_SecondDegreeRelationContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBusinessContent_JoinGroupBizContent_TagV2_SecondDegreeRelationContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.relatedUsers.push(BusinessContent_JoinGroupBizContent_TagV2_UserInfoDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalRelatedUserCnt = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBusinessContent_JoinGroupBizContent_TagV2_SimilarInterestContent(): BusinessContent_JoinGroupBizContent_TagV2_SimilarInterestContent {
  return { contentId: "0", displayText: "" };
}

export const BusinessContent_JoinGroupBizContent_TagV2_SimilarInterestContentDecoder: MessageFns<BusinessContent_JoinGroupBizContent_TagV2_SimilarInterestContent> = {
  encode(
    message: BusinessContent_JoinGroupBizContent_TagV2_SimilarInterestContent,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.contentId !== "0") {
      writer.uint32(8).int64(message.contentId);
    }
    if (message.displayText !== "") {
      writer.uint32(18).string(message.displayText);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): BusinessContent_JoinGroupBizContent_TagV2_SimilarInterestContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBusinessContent_JoinGroupBizContent_TagV2_SimilarInterestContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.contentId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.displayText = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBusinessContent_Tag(): BusinessContent_Tag {
  return { tagType: 0, tagValue: "", tagText: "" };
}

export const BusinessContent_TagDecoder: MessageFns<BusinessContent_Tag> = {
  encode(message: BusinessContent_Tag, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tagType !== 0) {
      writer.uint32(8).int32(message.tagType);
    }
    if (message.tagValue !== "") {
      writer.uint32(18).string(message.tagValue);
    }
    if (message.tagText !== "") {
      writer.uint32(26).string(message.tagText);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BusinessContent_Tag {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBusinessContent_Tag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.tagType = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tagValue = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tagText = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBusinessContent_PerceptionDialogInfo(): BusinessContent_PerceptionDialogInfo {
  return {
    iconType: "0",
    title: undefined,
    subTitle: undefined,
    adviceActionText: undefined,
    defaultActionText: undefined,
    violationDetailUrl: "",
    scene: 0,
    targetUserId: "0",
    targetRoomId: "0",
    countDownTime: "0",
    showFeedback: false,
    feedbackOptionsList: [],
    policyTip: "0",
  };
}

export const BusinessContent_PerceptionDialogInfoDecoder: MessageFns<BusinessContent_PerceptionDialogInfo> = {
  encode(message: BusinessContent_PerceptionDialogInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.iconType !== "0") {
      writer.uint32(8).int64(message.iconType);
    }
    if (message.title !== undefined) {
      TextDecoder.encode(message.title, writer.uint32(18).fork()).join();
    }
    if (message.subTitle !== undefined) {
      TextDecoder.encode(message.subTitle, writer.uint32(26).fork()).join();
    }
    if (message.adviceActionText !== undefined) {
      TextDecoder.encode(message.adviceActionText, writer.uint32(34).fork()).join();
    }
    if (message.defaultActionText !== undefined) {
      TextDecoder.encode(message.defaultActionText, writer.uint32(42).fork()).join();
    }
    if (message.violationDetailUrl !== "") {
      writer.uint32(50).string(message.violationDetailUrl);
    }
    if (message.scene !== 0) {
      writer.uint32(56).int32(message.scene);
    }
    if (message.targetUserId !== "0") {
      writer.uint32(64).int64(message.targetUserId);
    }
    if (message.targetRoomId !== "0") {
      writer.uint32(72).int64(message.targetRoomId);
    }
    if (message.countDownTime !== "0") {
      writer.uint32(80).int64(message.countDownTime);
    }
    if (message.showFeedback !== false) {
      writer.uint32(88).bool(message.showFeedback);
    }
    for (const v of message.feedbackOptionsList) {
      BusinessContent_PerceptionFeedbackOptionDecoder.encode(v!, writer.uint32(98).fork()).join();
    }
    if (message.policyTip !== "0") {
      writer.uint32(104).int64(message.policyTip);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BusinessContent_PerceptionDialogInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBusinessContent_PerceptionDialogInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.iconType = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = TextDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.subTitle = TextDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.adviceActionText = TextDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.defaultActionText = TextDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.violationDetailUrl = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.scene = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.targetUserId = reader.int64().toString();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.targetRoomId = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.countDownTime = reader.int64().toString();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.showFeedback = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.feedbackOptionsList.push(BusinessContent_PerceptionFeedbackOptionDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.policyTip = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBusinessContent_PerceptionFeedbackOption(): BusinessContent_PerceptionFeedbackOption {
  return { id: "0", contentKey: "" };
}

export const BusinessContent_PerceptionFeedbackOptionDecoder: MessageFns<BusinessContent_PerceptionFeedbackOption> = {
  encode(message: BusinessContent_PerceptionFeedbackOption, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "0") {
      writer.uint32(8).int64(message.id);
    }
    if (message.contentKey !== "") {
      writer.uint32(18).string(message.contentKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BusinessContent_PerceptionFeedbackOption {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBusinessContent_PerceptionFeedbackOption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contentKey = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBusinessContent_JoinGroupMessageExtra(): BusinessContent_JoinGroupMessageExtra {
  return { sourceType: "0", extra: undefined, otherUsersList: [] };
}

export const BusinessContent_JoinGroupMessageExtraDecoder: MessageFns<BusinessContent_JoinGroupMessageExtra> = {
  encode(message: BusinessContent_JoinGroupMessageExtra, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sourceType !== "0") {
      writer.uint32(8).int64(message.sourceType);
    }
    if (message.extra !== undefined) {
      BusinessContent_JoinGroupMessageExtra_RivalExtraDecoder.encode(message.extra, writer.uint32(18).fork()).join();
    }
    for (const v of message.otherUsersList) {
      BusinessContent_JoinGroupMessageExtra_RivalExtraDecoder.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BusinessContent_JoinGroupMessageExtra {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBusinessContent_JoinGroupMessageExtra();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.sourceType = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.extra = BusinessContent_JoinGroupMessageExtra_RivalExtraDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.otherUsersList.push(BusinessContent_JoinGroupMessageExtra_RivalExtraDecoder.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBusinessContent_JoinGroupMessageExtra_RivalExtra(): BusinessContent_JoinGroupMessageExtra_RivalExtra {
  return {
    userCount: "0",
    avatarThumb: undefined,
    displayId: "",
    authenticationInfo: undefined,
    nickname: "",
    followStatus: "0",
    hashtag: undefined,
    topHostInfo: undefined,
    userId: "0",
    isBestTeammate: false,
  };
}

export const BusinessContent_JoinGroupMessageExtra_RivalExtraDecoder: MessageFns<BusinessContent_JoinGroupMessageExtra_RivalExtra> = {
  encode(
    message: BusinessContent_JoinGroupMessageExtra_RivalExtra,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.userCount !== "0") {
      writer.uint32(32).int64(message.userCount);
    }
    if (message.avatarThumb !== undefined) {
      ImageDecoder.encode(message.avatarThumb, writer.uint32(42).fork()).join();
    }
    if (message.displayId !== "") {
      writer.uint32(50).string(message.displayId);
    }
    if (message.authenticationInfo !== undefined) {
      BusinessContent_JoinGroupMessageExtra_RivalExtra_AuthenticationInfoDecoder.encode(
        message.authenticationInfo,
        writer.uint32(58).fork(),
      ).join();
    }
    if (message.nickname !== "") {
      writer.uint32(66).string(message.nickname);
    }
    if (message.followStatus !== "0") {
      writer.uint32(72).int64(message.followStatus);
    }
    if (message.hashtag !== undefined) {
      BusinessContent_HashtagDecoder.encode(message.hashtag, writer.uint32(82).fork()).join();
    }
    if (message.topHostInfo !== undefined) {
      BusinessContent_TopHostInfoDecoder.encode(message.topHostInfo, writer.uint32(90).fork()).join();
    }
    if (message.userId !== "0") {
      writer.uint32(96).int64(message.userId);
    }
    if (message.isBestTeammate !== false) {
      writer.uint32(104).bool(message.isBestTeammate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BusinessContent_JoinGroupMessageExtra_RivalExtra {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBusinessContent_JoinGroupMessageExtra_RivalExtra();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.userCount = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.avatarThumb = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.displayId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.authenticationInfo = BusinessContent_JoinGroupMessageExtra_RivalExtra_AuthenticationInfoDecoder.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.nickname = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.followStatus = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.hashtag = BusinessContent_HashtagDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.topHostInfo = BusinessContent_TopHostInfoDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.userId = reader.int64().toString();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.isBestTeammate = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBusinessContent_JoinGroupMessageExtra_RivalExtra_AuthenticationInfo(): BusinessContent_JoinGroupMessageExtra_RivalExtra_AuthenticationInfo {
  return { customVerify: "", enterpriseVerifyReason: "", authenticationBadge: undefined };
}

export const BusinessContent_JoinGroupMessageExtra_RivalExtra_AuthenticationInfoDecoder: MessageFns<BusinessContent_JoinGroupMessageExtra_RivalExtra_AuthenticationInfo> = {
  encode(
    message: BusinessContent_JoinGroupMessageExtra_RivalExtra_AuthenticationInfo,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.customVerify !== "") {
      writer.uint32(10).string(message.customVerify);
    }
    if (message.enterpriseVerifyReason !== "") {
      writer.uint32(18).string(message.enterpriseVerifyReason);
    }
    if (message.authenticationBadge !== undefined) {
      ImageDecoder.encode(message.authenticationBadge, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): BusinessContent_JoinGroupMessageExtra_RivalExtra_AuthenticationInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBusinessContent_JoinGroupMessageExtra_RivalExtra_AuthenticationInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.customVerify = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.enterpriseVerifyReason = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.authenticationBadge = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBusinessContent_Hashtag(): BusinessContent_Hashtag {
  return { id: "0", title: "", image: undefined, namespace: 0 };
}

export const BusinessContent_HashtagDecoder: MessageFns<BusinessContent_Hashtag> = {
  encode(message: BusinessContent_Hashtag, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "0") {
      writer.uint32(8).int64(message.id);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.image !== undefined) {
      ImageDecoder.encode(message.image, writer.uint32(26).fork()).join();
    }
    if (message.namespace !== 0) {
      writer.uint32(32).int32(message.namespace);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BusinessContent_Hashtag {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBusinessContent_Hashtag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.image = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.namespace = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBusinessContent_TopHostInfo(): BusinessContent_TopHostInfo {
  return { rankType: "", topIndex: "0" };
}

export const BusinessContent_TopHostInfoDecoder: MessageFns<BusinessContent_TopHostInfo> = {
  encode(message: BusinessContent_TopHostInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rankType !== "") {
      writer.uint32(10).string(message.rankType);
    }
    if (message.topIndex !== "0") {
      writer.uint32(16).int64(message.topIndex);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BusinessContent_TopHostInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBusinessContent_TopHostInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rankType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.topIndex = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseJoinGroupContent(): JoinGroupContent {
  return { groupUser: undefined, joinUser: undefined, type: 0, groupExtInfo: [] };
}

export const JoinGroupContentDecoder: MessageFns<JoinGroupContent> = {
  encode(message: JoinGroupContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupUser !== undefined) {
      GroupChannelAllUserDecoder.encode(message.groupUser, writer.uint32(10).fork()).join();
    }
    if (message.joinUser !== undefined) {
      GroupPlayerDecoder.encode(message.joinUser, writer.uint32(18).fork()).join();
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    for (const v of message.groupExtInfo) {
      RTCExtraInfoDecoder.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JoinGroupContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJoinGroupContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.groupUser = GroupChannelAllUserDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.joinUser = GroupPlayerDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.groupExtInfo.push(RTCExtraInfoDecoder.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePrivilegeLogExtra(): PrivilegeLogExtra {
  return { dataVersion: "", privilegeId: "", privilegeVersion: "", privilegeOrderId: "", level: "" };
}

export const PrivilegeLogExtraDecoder: MessageFns<PrivilegeLogExtra> = {
  encode(message: PrivilegeLogExtra, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dataVersion !== "") {
      writer.uint32(10).string(message.dataVersion);
    }
    if (message.privilegeId !== "") {
      writer.uint32(18).string(message.privilegeId);
    }
    if (message.privilegeVersion !== "") {
      writer.uint32(26).string(message.privilegeVersion);
    }
    if (message.privilegeOrderId !== "") {
      writer.uint32(34).string(message.privilegeOrderId);
    }
    if (message.level !== "") {
      writer.uint32(42).string(message.level);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PrivilegeLogExtra {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrivilegeLogExtra();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.dataVersion = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.privilegeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.privilegeVersion = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.privilegeOrderId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.level = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseFontStyle(): FontStyle {
  return { fontSize: 0, fontWidth: 0, fontColor: "", borderColor: "" };
}

export const FontStyleDecoder: MessageFns<FontStyle> = {
  encode(message: FontStyle, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fontSize !== 0) {
      writer.uint32(8).int32(message.fontSize);
    }
    if (message.fontWidth !== 0) {
      writer.uint32(16).int32(message.fontWidth);
    }
    if (message.fontColor !== "") {
      writer.uint32(26).string(message.fontColor);
    }
    if (message.borderColor !== "") {
      writer.uint32(34).string(message.borderColor);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FontStyle {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFontStyle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.fontSize = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.fontWidth = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fontColor = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.borderColor = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUserHonor(): UserHonor {
  return {
    totalDiamond: "0",
    diamondIcon: undefined,
    currentHonorName: "",
    currentHonorIcon: undefined,
    nextHonorName: "",
    level: 0,
    nextHonorIcon: undefined,
    currentDiamond: "0",
    thisGradeMinDiamond: "0",
    thisGradeMaxDiamond: "0",
    gradeDescribe: "",
    gradeIconList: [],
    screenChatType: "0",
    imIcon: undefined,
    imIconWithLevel: undefined,
    liveIcon: undefined,
    newImIconWithLevel: undefined,
    newLiveIcon: undefined,
    upgradeNeedConsume: "0",
    nextPrivileges: "",
    profileDialogBg: undefined,
    profileDialogBackBg: undefined,
    score: "0",
    gradeBanner: "",
  };
}

export const UserHonorDecoder: MessageFns<UserHonor> = {
  encode(message: UserHonor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalDiamond !== "0") {
      writer.uint32(8).int64(message.totalDiamond);
    }
    if (message.diamondIcon !== undefined) {
      ImageDecoder.encode(message.diamondIcon, writer.uint32(18).fork()).join();
    }
    if (message.currentHonorName !== "") {
      writer.uint32(26).string(message.currentHonorName);
    }
    if (message.currentHonorIcon !== undefined) {
      ImageDecoder.encode(message.currentHonorIcon, writer.uint32(34).fork()).join();
    }
    if (message.nextHonorName !== "") {
      writer.uint32(42).string(message.nextHonorName);
    }
    if (message.level !== 0) {
      writer.uint32(48).int32(message.level);
    }
    if (message.nextHonorIcon !== undefined) {
      ImageDecoder.encode(message.nextHonorIcon, writer.uint32(58).fork()).join();
    }
    if (message.currentDiamond !== "0") {
      writer.uint32(72).int64(message.currentDiamond);
    }
    if (message.thisGradeMinDiamond !== "0") {
      writer.uint32(80).int64(message.thisGradeMinDiamond);
    }
    if (message.thisGradeMaxDiamond !== "0") {
      writer.uint32(88).int64(message.thisGradeMaxDiamond);
    }
    if (message.gradeDescribe !== "") {
      writer.uint32(106).string(message.gradeDescribe);
    }
    for (const v of message.gradeIconList) {
      GradeIconDecoder.encode(v!, writer.uint32(114).fork()).join();
    }
    if (message.screenChatType !== "0") {
      writer.uint32(120).int64(message.screenChatType);
    }
    if (message.imIcon !== undefined) {
      ImageDecoder.encode(message.imIcon, writer.uint32(130).fork()).join();
    }
    if (message.imIconWithLevel !== undefined) {
      ImageDecoder.encode(message.imIconWithLevel, writer.uint32(138).fork()).join();
    }
    if (message.liveIcon !== undefined) {
      ImageDecoder.encode(message.liveIcon, writer.uint32(146).fork()).join();
    }
    if (message.newImIconWithLevel !== undefined) {
      ImageDecoder.encode(message.newImIconWithLevel, writer.uint32(154).fork()).join();
    }
    if (message.newLiveIcon !== undefined) {
      ImageDecoder.encode(message.newLiveIcon, writer.uint32(162).fork()).join();
    }
    if (message.upgradeNeedConsume !== "0") {
      writer.uint32(168).int64(message.upgradeNeedConsume);
    }
    if (message.nextPrivileges !== "") {
      writer.uint32(178).string(message.nextPrivileges);
    }
    if (message.profileDialogBg !== undefined) {
      ImageDecoder.encode(message.profileDialogBg, writer.uint32(186).fork()).join();
    }
    if (message.profileDialogBackBg !== undefined) {
      ImageDecoder.encode(message.profileDialogBackBg, writer.uint32(194).fork()).join();
    }
    if (message.score !== "0") {
      writer.uint32(200).int64(message.score);
    }
    if (message.gradeBanner !== "") {
      writer.uint32(8010).string(message.gradeBanner);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserHonor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserHonor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.totalDiamond = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.diamondIcon = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.currentHonorName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.currentHonorIcon = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.nextHonorName = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.level = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.nextHonorIcon = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.currentDiamond = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.thisGradeMinDiamond = reader.int64().toString();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.thisGradeMaxDiamond = reader.int64().toString();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.gradeDescribe = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.gradeIconList.push(GradeIconDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.screenChatType = reader.int64().toString();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.imIcon = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.imIconWithLevel = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.liveIcon = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.newImIconWithLevel = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.newLiveIcon = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.upgradeNeedConsume = reader.int64().toString();
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.nextPrivileges = reader.string();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.profileDialogBg = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.profileDialogBackBg = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 25: {
          if (tag !== 200) {
            break;
          }

          message.score = reader.int64().toString();
          continue;
        }
        case 1001: {
          if (tag !== 8010) {
            break;
          }

          message.gradeBanner = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGradeIcon(): GradeIcon {
  return { icon: undefined, iconDiamond: "0", level: "0", levelStr: "" };
}

export const GradeIconDecoder: MessageFns<GradeIcon> = {
  encode(message: GradeIcon, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.icon !== undefined) {
      ImageDecoder.encode(message.icon, writer.uint32(10).fork()).join();
    }
    if (message.iconDiamond !== "0") {
      writer.uint32(16).int64(message.iconDiamond);
    }
    if (message.level !== "0") {
      writer.uint32(24).int64(message.level);
    }
    if (message.levelStr !== "") {
      writer.uint32(34).string(message.levelStr);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GradeIcon {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGradeIcon();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.icon = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.iconDiamond = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.level = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.levelStr = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBorderInfo(): BorderInfo {
  return {
    icon: undefined,
    level: "0",
    source: "",
    profileDecorationRibbon: undefined,
    borderLogExtra: undefined,
    ribbonLogExtra: undefined,
    avatarBackgroundColor: "",
    avatarBackgroundBorderColor: "",
  };
}

export const BorderInfoDecoder: MessageFns<BorderInfo> = {
  encode(message: BorderInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.icon !== undefined) {
      ImageDecoder.encode(message.icon, writer.uint32(10).fork()).join();
    }
    if (message.level !== "0") {
      writer.uint32(16).int64(message.level);
    }
    if (message.source !== "") {
      writer.uint32(26).string(message.source);
    }
    if (message.profileDecorationRibbon !== undefined) {
      ImageDecoder.encode(message.profileDecorationRibbon, writer.uint32(34).fork()).join();
    }
    if (message.borderLogExtra !== undefined) {
      PrivilegeLogExtraDecoder.encode(message.borderLogExtra, writer.uint32(42).fork()).join();
    }
    if (message.ribbonLogExtra !== undefined) {
      PrivilegeLogExtraDecoder.encode(message.ribbonLogExtra, writer.uint32(50).fork()).join();
    }
    if (message.avatarBackgroundColor !== "") {
      writer.uint32(58).string(message.avatarBackgroundColor);
    }
    if (message.avatarBackgroundBorderColor !== "") {
      writer.uint32(66).string(message.avatarBackgroundBorderColor);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BorderInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBorderInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.icon = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.level = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.source = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.profileDecorationRibbon = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.borderLogExtra = PrivilegeLogExtraDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.ribbonLogExtra = PrivilegeLogExtraDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.avatarBackgroundColor = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.avatarBackgroundBorderColor = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseFansClubMember(): FansClubMember {
  return { data: undefined, preferData: {} };
}

export const FansClubMemberDecoder: MessageFns<FansClubMember> = {
  encode(message: FansClubMember, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data !== undefined) {
      FansClubDataDecoder.encode(message.data, writer.uint32(10).fork()).join();
    }
    Object.entries(message.preferData).forEach(([key, value]) => {
      FansClubMember_PreferDataEntryDecoder.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FansClubMember {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFansClubMember();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data = FansClubDataDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = FansClubMember_PreferDataEntryDecoder.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.preferData[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseFansClubMember_PreferDataEntry(): FansClubMember_PreferDataEntry {
  return { key: 0, value: undefined };
}

export const FansClubMember_PreferDataEntryDecoder: MessageFns<FansClubMember_PreferDataEntry> = {
  encode(message: FansClubMember_PreferDataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== 0) {
      writer.uint32(8).int32(message.key);
    }
    if (message.value !== undefined) {
      FansClubDataDecoder.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FansClubMember_PreferDataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFansClubMember_PreferDataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = FansClubDataDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseFansClubData(): FansClubData {
  return { clubName: "", level: 0, userFansClubStatus: 0, badge: undefined, availableGiftIds: [], anchorId: "0" };
}

export const FansClubDataDecoder: MessageFns<FansClubData> = {
  encode(message: FansClubData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clubName !== "") {
      writer.uint32(10).string(message.clubName);
    }
    if (message.level !== 0) {
      writer.uint32(16).int32(message.level);
    }
    if (message.userFansClubStatus !== 0) {
      writer.uint32(24).int32(message.userFansClubStatus);
    }
    if (message.badge !== undefined) {
      FansClubData_UserBadgeDecoder.encode(message.badge, writer.uint32(34).fork()).join();
    }
    writer.uint32(42).fork();
    for (const v of message.availableGiftIds) {
      writer.int64(v);
    }
    writer.join();
    if (message.anchorId !== "0") {
      writer.uint32(48).int64(message.anchorId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FansClubData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFansClubData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clubName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.level = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.userFansClubStatus = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.badge = FansClubData_UserBadgeDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag === 40) {
            message.availableGiftIds.push(reader.int64().toString());

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.availableGiftIds.push(reader.int64().toString());
            }

            continue;
          }

          break;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.anchorId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseFansClubData_UserBadge(): FansClubData_UserBadge {
  return { icons: {}, title: "" };
}

export const FansClubData_UserBadgeDecoder: MessageFns<FansClubData_UserBadge> = {
  encode(message: FansClubData_UserBadge, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.icons).forEach(([key, value]) => {
      FansClubData_UserBadge_IconsEntryDecoder.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FansClubData_UserBadge {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFansClubData_UserBadge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = FansClubData_UserBadge_IconsEntryDecoder.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.icons[entry1.key] = entry1.value;
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseFansClubData_UserBadge_IconsEntry(): FansClubData_UserBadge_IconsEntry {
  return { key: 0, value: undefined };
}

export const FansClubData_UserBadge_IconsEntryDecoder: MessageFns<FansClubData_UserBadge_IconsEntry> = {
  encode(message: FansClubData_UserBadge_IconsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== 0) {
      writer.uint32(8).int32(message.key);
    }
    if (message.value !== undefined) {
      ImageDecoder.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FansClubData_UserBadge_IconsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFansClubData_UserBadge_IconsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseAuthor(): Author {
  return { videoTotalCount: "0", videoTotalPlayCount: "0", videoTotalFavoriteCount: "0" };
}

export const AuthorDecoder: MessageFns<Author> = {
  encode(message: Author, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.videoTotalCount !== "0") {
      writer.uint32(8).int64(message.videoTotalCount);
    }
    if (message.videoTotalPlayCount !== "0") {
      writer.uint32(16).int64(message.videoTotalPlayCount);
    }
    if (message.videoTotalFavoriteCount !== "0") {
      writer.uint32(48).int64(message.videoTotalFavoriteCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Author {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.videoTotalCount = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.videoTotalPlayCount = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.videoTotalFavoriteCount = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePublicAreaCommon(): PublicAreaCommon {
  return { userLabel: undefined, userConsumeInRoom: "0" };
}

export const PublicAreaCommonDecoder: MessageFns<PublicAreaCommon> = {
  encode(message: PublicAreaCommon, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userLabel !== undefined) {
      ImageDecoder.encode(message.userLabel, writer.uint32(10).fork()).join();
    }
    if (message.userConsumeInRoom !== "0") {
      writer.uint32(16).int64(message.userConsumeInRoom);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublicAreaCommon {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublicAreaCommon();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userLabel = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.userConsumeInRoom = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePublicAreaMessageCommon(): PublicAreaMessageCommon {
  return {
    scrollGapCount: "0",
    anchorScrollGapCount: "0",
    releaseToScrollArea: false,
    anchorReleaseToScrollArea: false,
    isAnchorMarked: false,
    creatorSuccessInfo: undefined,
    portraitInfo: undefined,
    userInteractionInfo: undefined,
    adminFoldType: "0",
  };
}

export const PublicAreaMessageCommonDecoder: MessageFns<PublicAreaMessageCommon> = {
  encode(message: PublicAreaMessageCommon, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scrollGapCount !== "0") {
      writer.uint32(8).int64(message.scrollGapCount);
    }
    if (message.anchorScrollGapCount !== "0") {
      writer.uint32(16).int64(message.anchorScrollGapCount);
    }
    if (message.releaseToScrollArea !== false) {
      writer.uint32(24).bool(message.releaseToScrollArea);
    }
    if (message.anchorReleaseToScrollArea !== false) {
      writer.uint32(32).bool(message.anchorReleaseToScrollArea);
    }
    if (message.isAnchorMarked !== false) {
      writer.uint32(40).bool(message.isAnchorMarked);
    }
    if (message.creatorSuccessInfo !== undefined) {
      PublicAreaMessageCommon_CreatorSuccessInfoDecoder.encode(message.creatorSuccessInfo, writer.uint32(50).fork()).join();
    }
    if (message.portraitInfo !== undefined) {
      PublicAreaMessageCommon_PortraitInfoDecoder.encode(message.portraitInfo, writer.uint32(58).fork()).join();
    }
    if (message.userInteractionInfo !== undefined) {
      PublicAreaMessageCommon_UserInteractionInfoDecoder.encode(message.userInteractionInfo, writer.uint32(66).fork()).join();
    }
    if (message.adminFoldType !== "0") {
      writer.uint32(72).int64(message.adminFoldType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublicAreaMessageCommon {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublicAreaMessageCommon();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.scrollGapCount = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.anchorScrollGapCount = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.releaseToScrollArea = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.anchorReleaseToScrollArea = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isAnchorMarked = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.creatorSuccessInfo = PublicAreaMessageCommon_CreatorSuccessInfoDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.portraitInfo = PublicAreaMessageCommon_PortraitInfoDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.userInteractionInfo = PublicAreaMessageCommon_UserInteractionInfoDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.adminFoldType = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePublicAreaMessageCommon_TagItem(): PublicAreaMessageCommon_TagItem {
  return { tagType: 0, tagText: undefined };
}

export const PublicAreaMessageCommon_TagItemDecoder: MessageFns<PublicAreaMessageCommon_TagItem> = {
  encode(message: PublicAreaMessageCommon_TagItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tagType !== 0) {
      writer.uint32(8).int32(message.tagType);
    }
    if (message.tagText !== undefined) {
      TextDecoder.encode(message.tagText, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublicAreaMessageCommon_TagItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublicAreaMessageCommon_TagItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.tagType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tagText = TextDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePublicAreaMessageCommon_Topic(): PublicAreaMessageCommon_Topic {
  return { topicActionType: 0, topicText: undefined, topicTips: undefined };
}

export const PublicAreaMessageCommon_TopicDecoder: MessageFns<PublicAreaMessageCommon_Topic> = {
  encode(message: PublicAreaMessageCommon_Topic, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicActionType !== 0) {
      writer.uint32(8).int32(message.topicActionType);
    }
    if (message.topicText !== undefined) {
      TextDecoder.encode(message.topicText, writer.uint32(18).fork()).join();
    }
    if (message.topicTips !== undefined) {
      TextDecoder.encode(message.topicTips, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublicAreaMessageCommon_Topic {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublicAreaMessageCommon_Topic();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicActionType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.topicText = TextDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.topicTips = TextDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePublicAreaMessageCommon_CreatorSuccessInfo(): PublicAreaMessageCommon_CreatorSuccessInfo {
  return { tags: [], topic: undefined };
}

export const PublicAreaMessageCommon_CreatorSuccessInfoDecoder: MessageFns<PublicAreaMessageCommon_CreatorSuccessInfo> = {
  encode(message: PublicAreaMessageCommon_CreatorSuccessInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.tags) {
      PublicAreaMessageCommon_TagItemDecoder.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.topic !== undefined) {
      PublicAreaMessageCommon_TopicDecoder.encode(message.topic, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublicAreaMessageCommon_CreatorSuccessInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublicAreaMessageCommon_CreatorSuccessInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tags.push(PublicAreaMessageCommon_TagItemDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.topic = PublicAreaMessageCommon_TopicDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePublicAreaMessageCommon_UserMetrics(): PublicAreaMessageCommon_UserMetrics {
  return { type: 0, metricsValue: "" };
}

export const PublicAreaMessageCommon_UserMetricsDecoder: MessageFns<PublicAreaMessageCommon_UserMetrics> = {
  encode(message: PublicAreaMessageCommon_UserMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.metricsValue !== "") {
      writer.uint32(18).string(message.metricsValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublicAreaMessageCommon_UserMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublicAreaMessageCommon_UserMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.metricsValue = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePublicAreaMessageCommon_PortraitTag(): PublicAreaMessageCommon_PortraitTag {
  return { tagId: "", priority: "0", showValue: "", showArgs: "" };
}

export const PublicAreaMessageCommon_PortraitTagDecoder: MessageFns<PublicAreaMessageCommon_PortraitTag> = {
  encode(message: PublicAreaMessageCommon_PortraitTag, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tagId !== "") {
      writer.uint32(10).string(message.tagId);
    }
    if (message.priority !== "0") {
      writer.uint32(16).int64(message.priority);
    }
    if (message.showValue !== "") {
      writer.uint32(26).string(message.showValue);
    }
    if (message.showArgs !== "") {
      writer.uint32(34).string(message.showArgs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublicAreaMessageCommon_PortraitTag {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublicAreaMessageCommon_PortraitTag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tagId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.priority = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.showValue = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.showArgs = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePublicAreaMessageCommon_PortraitInfo(): PublicAreaMessageCommon_PortraitInfo {
  return { userMetrics: [], portraitTag: [] };
}

export const PublicAreaMessageCommon_PortraitInfoDecoder: MessageFns<PublicAreaMessageCommon_PortraitInfo> = {
  encode(message: PublicAreaMessageCommon_PortraitInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.userMetrics) {
      PublicAreaMessageCommon_UserMetricsDecoder.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.portraitTag) {
      PublicAreaMessageCommon_PortraitTagDecoder.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublicAreaMessageCommon_PortraitInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublicAreaMessageCommon_PortraitInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userMetrics.push(PublicAreaMessageCommon_UserMetricsDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.portraitTag.push(PublicAreaMessageCommon_PortraitTagDecoder.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePublicAreaMessageCommon_UserInteractionInfo(): PublicAreaMessageCommon_UserInteractionInfo {
  return { likeCnt: "0", commentCnt: "0", shareCnt: "0" };
}

export const PublicAreaMessageCommon_UserInteractionInfoDecoder: MessageFns<PublicAreaMessageCommon_UserInteractionInfo> = {
  encode(
    message: PublicAreaMessageCommon_UserInteractionInfo,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.likeCnt !== "0") {
      writer.uint32(8).int64(message.likeCnt);
    }
    if (message.commentCnt !== "0") {
      writer.uint32(16).int64(message.commentCnt);
    }
    if (message.shareCnt !== "0") {
      writer.uint32(24).int64(message.shareCnt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublicAreaMessageCommon_UserInteractionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublicAreaMessageCommon_UserInteractionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.likeCnt = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.commentCnt = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.shareCnt = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGiftModeMeta(): GiftModeMeta {
  return { giftId: "0", giftNameKey: "", giftIconImage: undefined, giftModeDesc: undefined };
}

export const GiftModeMetaDecoder: MessageFns<GiftModeMeta> = {
  encode(message: GiftModeMeta, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.giftId !== "0") {
      writer.uint32(8).int64(message.giftId);
    }
    if (message.giftNameKey !== "") {
      writer.uint32(18).string(message.giftNameKey);
    }
    if (message.giftIconImage !== undefined) {
      ImageDecoder.encode(message.giftIconImage, writer.uint32(26).fork()).join();
    }
    if (message.giftModeDesc !== undefined) {
      TextDecoder.encode(message.giftModeDesc, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GiftModeMeta {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGiftModeMeta();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.giftId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.giftNameKey = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.giftIconImage = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.giftModeDesc = TextDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBattleTeamUser(): BattleTeamUser {
  return { userId: "0", score: "0", userIdStr: "" };
}

export const BattleTeamUserDecoder: MessageFns<BattleTeamUser> = {
  encode(message: BattleTeamUser, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "0") {
      writer.uint32(8).int64(message.userId);
    }
    if (message.score !== "0") {
      writer.uint32(16).int64(message.score);
    }
    if (message.userIdStr !== "") {
      writer.uint32(26).string(message.userIdStr);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BattleTeamUser {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBattleTeamUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.score = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userIdStr = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBattleSetting(): BattleSetting {
  return {
    battleId: "0",
    startTimeMs: "0",
    duration: 0,
    channelId: "0",
    status: 0,
    inviteType: 0,
    giftModeMeta: undefined,
    battleType: 0,
    extraDurationSecond: "0",
    endTimeMs: "0",
  };
}

export const BattleSettingDecoder: MessageFns<BattleSetting> = {
  encode(message: BattleSetting, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.battleId !== "0") {
      writer.uint32(8).int64(message.battleId);
    }
    if (message.startTimeMs !== "0") {
      writer.uint32(16).int64(message.startTimeMs);
    }
    if (message.duration !== 0) {
      writer.uint32(24).int32(message.duration);
    }
    if (message.channelId !== "0") {
      writer.uint32(32).int64(message.channelId);
    }
    if (message.status !== 0) {
      writer.uint32(40).int32(message.status);
    }
    if (message.inviteType !== 0) {
      writer.uint32(48).int32(message.inviteType);
    }
    if (message.giftModeMeta !== undefined) {
      GiftModeMetaDecoder.encode(message.giftModeMeta, writer.uint32(58).fork()).join();
    }
    if (message.battleType !== 0) {
      writer.uint32(64).int32(message.battleType);
    }
    if (message.extraDurationSecond !== "0") {
      writer.uint32(72).int64(message.extraDurationSecond);
    }
    if (message.endTimeMs !== "0") {
      writer.uint32(80).int64(message.endTimeMs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BattleSetting {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBattleSetting();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.battleId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.startTimeMs = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.duration = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.channelId = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.status = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.inviteType = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.giftModeMeta = GiftModeMetaDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.battleType = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.extraDurationSecond = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.endTimeMs = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBattleTeamUserArmies(): BattleTeamUserArmies {
  return { teamId: "0", teamUsers: [], teamTotalScore: "0", userArmies: undefined, hostRank: "0" };
}

export const BattleTeamUserArmiesDecoder: MessageFns<BattleTeamUserArmies> = {
  encode(message: BattleTeamUserArmies, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.teamId !== "0") {
      writer.uint32(8).int64(message.teamId);
    }
    for (const v of message.teamUsers) {
      BattleTeamUserDecoder.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.teamTotalScore !== "0") {
      writer.uint32(24).int64(message.teamTotalScore);
    }
    if (message.userArmies !== undefined) {
      BattleUserArmiesDecoder.encode(message.userArmies, writer.uint32(34).fork()).join();
    }
    if (message.hostRank !== "0") {
      writer.uint32(40).int64(message.hostRank);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BattleTeamUserArmies {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBattleTeamUserArmies();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.teamId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.teamUsers.push(BattleTeamUserDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.teamTotalScore = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userArmies = BattleUserArmiesDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.hostRank = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBattleUserArmies(): BattleUserArmies {
  return { userArmy: [], hostScore: "0", anchorIdStr: "" };
}

export const BattleUserArmiesDecoder: MessageFns<BattleUserArmies> = {
  encode(message: BattleUserArmies, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.userArmy) {
      BattleUserArmyDecoder.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.hostScore !== "0") {
      writer.uint32(16).int64(message.hostScore);
    }
    if (message.anchorIdStr !== "") {
      writer.uint32(26).string(message.anchorIdStr);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BattleUserArmies {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBattleUserArmies();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userArmy.push(BattleUserArmyDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.hostScore = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.anchorIdStr = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBattleUserArmy(): BattleUserArmy {
  return { userId: "0", score: "0", nickname: "", avatarThumb: undefined, diamondScore: "0", userIdStr: "" };
}

export const BattleUserArmyDecoder: MessageFns<BattleUserArmy> = {
  encode(message: BattleUserArmy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "0") {
      writer.uint32(8).int64(message.userId);
    }
    if (message.score !== "0") {
      writer.uint32(16).int64(message.score);
    }
    if (message.nickname !== "") {
      writer.uint32(26).string(message.nickname);
    }
    if (message.avatarThumb !== undefined) {
      ImageDecoder.encode(message.avatarThumb, writer.uint32(34).fork()).join();
    }
    if (message.diamondScore !== "0") {
      writer.uint32(40).int64(message.diamondScore);
    }
    if (message.userIdStr !== "") {
      writer.uint32(50).string(message.userIdStr);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BattleUserArmy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBattleUserArmy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.score = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nickname = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.avatarThumb = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.diamondScore = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.userIdStr = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseHighScoreControlCfg(): HighScoreControlCfg {
  return { normalControlApplied: false, threshold: "0", originDisplayToUserList: [] };
}

export const HighScoreControlCfgDecoder: MessageFns<HighScoreControlCfg> = {
  encode(message: HighScoreControlCfg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.normalControlApplied !== false) {
      writer.uint32(8).bool(message.normalControlApplied);
    }
    if (message.threshold !== "0") {
      writer.uint32(16).int64(message.threshold);
    }
    writer.uint32(26).fork();
    for (const v of message.originDisplayToUserList) {
      writer.int64(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HighScoreControlCfg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHighScoreControlCfg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.normalControlApplied = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.threshold = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag === 24) {
            message.originDisplayToUserList.push(reader.int64().toString());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.originDisplayToUserList.push(reader.int64().toString());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseHeartbeatMessage(): HeartbeatMessage {
  return { roomId: "0" };
}

export const HeartbeatMessageDecoder: MessageFns<HeartbeatMessage> = {
  encode(message: HeartbeatMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.roomId !== "0") {
      writer.uint32(8).uint64(message.roomId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HeartbeatMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeartbeatMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.roomId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastPushFrame(): WebcastPushFrame {
  return {
    seqId: "0",
    logId: "0",
    service: "0",
    method: "0",
    headers: {},
    payloadEncoding: "",
    payloadType: "",
    payload: new Uint8Array(0),
  };
}

export const WebcastPushFrameDecoder: MessageFns<WebcastPushFrame> = {
  encode(message: WebcastPushFrame, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.seqId !== "0") {
      writer.uint32(8).int64(message.seqId);
    }
    if (message.logId !== "0") {
      writer.uint32(16).int64(message.logId);
    }
    if (message.service !== "0") {
      writer.uint32(24).int64(message.service);
    }
    if (message.method !== "0") {
      writer.uint32(32).int64(message.method);
    }
    Object.entries(message.headers).forEach(([key, value]) => {
      WebcastPushFrame_HeadersEntryDecoder.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    if (message.payloadEncoding !== "") {
      writer.uint32(50).string(message.payloadEncoding);
    }
    if (message.payloadType !== "") {
      writer.uint32(58).string(message.payloadType);
    }
    if (message.payload.length !== 0) {
      writer.uint32(66).bytes(message.payload);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastPushFrame {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastPushFrame();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.seqId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.logId = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.service = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.method = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = WebcastPushFrame_HeadersEntryDecoder.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.headers[entry5.key] = entry5.value;
          }
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.payloadEncoding = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.payloadType = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.payload = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastPushFrame_HeadersEntry(): WebcastPushFrame_HeadersEntry {
  return { key: "", value: "" };
}

export const WebcastPushFrame_HeadersEntryDecoder: MessageFns<WebcastPushFrame_HeadersEntry> = {
  encode(message: WebcastPushFrame_HeadersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastPushFrame_HeadersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastPushFrame_HeadersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseMessage(): Message {
  return { type: "", binary: new Uint8Array(0) };
}

export const MessageDecoder: MessageFns<Message> = {
  encode(message: Message, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.binary.length !== 0) {
      writer.uint32(18).bytes(message.binary);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Message {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.binary = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebsocketParam(): WebsocketParam {
  return { name: "", value: "" };
}

export const WebsocketParamDecoder: MessageFns<WebsocketParam> = {
  encode(message: WebsocketParam, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebsocketParam {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebsocketParam();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastRoomUserSeqMessage(): WebcastRoomUserSeqMessage {
  return {
    common: undefined,
    viewerCount: 0,
    ranksList: [],
    popStr: "",
    seatsList: [],
    popularity: "0",
    totalUser: 0,
    anonymous: "0",
  };
}

export const WebcastRoomUserSeqMessageDecoder: MessageFns<WebcastRoomUserSeqMessage> = {
  encode(message: WebcastRoomUserSeqMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageDataDecoder.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.viewerCount !== 0) {
      writer.uint32(24).int32(message.viewerCount);
    }
    for (const v of message.ranksList) {
      WebcastRoomUserSeqMessage_ContributorDecoder.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.popStr !== "") {
      writer.uint32(34).string(message.popStr);
    }
    for (const v of message.seatsList) {
      WebcastRoomUserSeqMessage_ContributorDecoder.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.popularity !== "0") {
      writer.uint32(48).int64(message.popularity);
    }
    if (message.totalUser !== 0) {
      writer.uint32(56).int32(message.totalUser);
    }
    if (message.anonymous !== "0") {
      writer.uint32(64).int64(message.anonymous);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastRoomUserSeqMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastRoomUserSeqMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageDataDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.viewerCount = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ranksList.push(WebcastRoomUserSeqMessage_ContributorDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.popStr = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.seatsList.push(WebcastRoomUserSeqMessage_ContributorDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.popularity = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.totalUser = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.anonymous = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastRoomUserSeqMessage_Contributor(): WebcastRoomUserSeqMessage_Contributor {
  return { coinCount: 0, user: undefined, rank: 0, delta: "0" };
}

export const WebcastRoomUserSeqMessage_ContributorDecoder: MessageFns<WebcastRoomUserSeqMessage_Contributor> = {
  encode(message: WebcastRoomUserSeqMessage_Contributor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.coinCount !== 0) {
      writer.uint32(8).int32(message.coinCount);
    }
    if (message.user !== undefined) {
      UserDecoder.encode(message.user, writer.uint32(18).fork()).join();
    }
    if (message.rank !== 0) {
      writer.uint32(24).int32(message.rank);
    }
    if (message.delta !== "0") {
      writer.uint32(32).int64(message.delta);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastRoomUserSeqMessage_Contributor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastRoomUserSeqMessage_Contributor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.coinCount = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.user = UserDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.rank = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.delta = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseImageModel(): ImageModel {
  return {
    mUrls: [],
    mUri: "",
    height: 0,
    width: 0,
    avgColor: "",
    imageType: 0,
    schema: "",
    content: undefined,
    isAnimated: false,
  };
}

export const ImageModelDecoder: MessageFns<ImageModel> = {
  encode(message: ImageModel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.mUrls) {
      writer.uint32(10).string(v!);
    }
    if (message.mUri !== "") {
      writer.uint32(18).string(message.mUri);
    }
    if (message.height !== 0) {
      writer.uint32(24).int32(message.height);
    }
    if (message.width !== 0) {
      writer.uint32(32).int32(message.width);
    }
    if (message.avgColor !== "") {
      writer.uint32(42).string(message.avgColor);
    }
    if (message.imageType !== 0) {
      writer.uint32(48).int32(message.imageType);
    }
    if (message.schema !== "") {
      writer.uint32(58).string(message.schema);
    }
    if (message.content !== undefined) {
      ImageModel_ContentDecoder.encode(message.content, writer.uint32(66).fork()).join();
    }
    if (message.isAnimated !== false) {
      writer.uint32(72).bool(message.isAnimated);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImageModel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImageModel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mUrls.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mUri = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.height = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.width = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.avgColor = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.imageType = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.schema = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.content = ImageModel_ContentDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.isAnimated = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseImageModel_Content(): ImageModel_Content {
  return { name: "", fontColor: "", level: "0" };
}

export const ImageModel_ContentDecoder: MessageFns<ImageModel_Content> = {
  encode(message: ImageModel_Content, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.fontColor !== "") {
      writer.uint32(18).string(message.fontColor);
    }
    if (message.level !== "0") {
      writer.uint32(24).int64(message.level);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImageModel_Content {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImageModel_Content();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fontColor = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.level = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastChatMessage(): WebcastChatMessage {
  return {
    common: undefined,
    user: undefined,
    comment: "",
    visibleToSender: false,
    background: undefined,
    fullScreenTextColor: "",
    backgroundImageV2: undefined,
    publicAreaCommon: undefined,
    giftImage: undefined,
    inputType: 0,
    atUser: undefined,
    emotes: [],
    contentLanguage: "",
    msgFilter: undefined,
    quickChatScene: 0,
    communityflaggedStatus: 0,
    commentQualityScores: [],
    userIdentity: undefined,
    commentTag: [],
    publicAreaMessageCommon: undefined,
    screenTime: "0",
    signature: "",
    signatureVersion: "",
    ecStreamerKey: "",
  };
}

export const WebcastChatMessageDecoder: MessageFns<WebcastChatMessage> = {
  encode(message: WebcastChatMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageDataDecoder.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.user !== undefined) {
      UserDecoder.encode(message.user, writer.uint32(18).fork()).join();
    }
    if (message.comment !== "") {
      writer.uint32(26).string(message.comment);
    }
    if (message.visibleToSender !== false) {
      writer.uint32(32).bool(message.visibleToSender);
    }
    if (message.background !== undefined) {
      ImageModelDecoder.encode(message.background, writer.uint32(42).fork()).join();
    }
    if (message.fullScreenTextColor !== "") {
      writer.uint32(50).string(message.fullScreenTextColor);
    }
    if (message.backgroundImageV2 !== undefined) {
      ImageModelDecoder.encode(message.backgroundImageV2, writer.uint32(58).fork()).join();
    }
    if (message.publicAreaCommon !== undefined) {
      PublicAreaCommonDecoder.encode(message.publicAreaCommon, writer.uint32(74).fork()).join();
    }
    if (message.giftImage !== undefined) {
      ImageModelDecoder.encode(message.giftImage, writer.uint32(82).fork()).join();
    }
    if (message.inputType !== 0) {
      writer.uint32(88).int32(message.inputType);
    }
    if (message.atUser !== undefined) {
      UserDecoder.encode(message.atUser, writer.uint32(98).fork()).join();
    }
    for (const v of message.emotes) {
      WebcastSubEmoteDecoder.encode(v!, writer.uint32(106).fork()).join();
    }
    if (message.contentLanguage !== "") {
      writer.uint32(114).string(message.contentLanguage);
    }
    if (message.msgFilter !== undefined) {
      MsgFilterDecoder.encode(message.msgFilter, writer.uint32(122).fork()).join();
    }
    if (message.quickChatScene !== 0) {
      writer.uint32(128).int32(message.quickChatScene);
    }
    if (message.communityflaggedStatus !== 0) {
      writer.uint32(136).int32(message.communityflaggedStatus);
    }
    for (const v of message.commentQualityScores) {
      WebcastChatMessage_CommentQualityScoreDecoder.encode(v!, writer.uint32(154).fork()).join();
    }
    if (message.userIdentity !== undefined) {
      WebcastChatMessage_UserIdentityDecoder.encode(message.userIdentity, writer.uint32(146).fork()).join();
    }
    writer.uint32(162).fork();
    for (const v of message.commentTag) {
      writer.int32(v);
    }
    writer.join();
    if (message.publicAreaMessageCommon !== undefined) {
      PublicAreaMessageCommonDecoder.encode(message.publicAreaMessageCommon, writer.uint32(170).fork()).join();
    }
    if (message.screenTime !== "0") {
      writer.uint32(176).int64(message.screenTime);
    }
    if (message.signature !== "") {
      writer.uint32(186).string(message.signature);
    }
    if (message.signatureVersion !== "") {
      writer.uint32(194).string(message.signatureVersion);
    }
    if (message.ecStreamerKey !== "") {
      writer.uint32(202).string(message.ecStreamerKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastChatMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastChatMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageDataDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.user = UserDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.comment = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.visibleToSender = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.background = ImageModelDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.fullScreenTextColor = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.backgroundImageV2 = ImageModelDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.publicAreaCommon = PublicAreaCommonDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.giftImage = ImageModelDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.inputType = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.atUser = UserDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.emotes.push(WebcastSubEmoteDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.contentLanguage = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.msgFilter = MsgFilterDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.quickChatScene = reader.int32();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.communityflaggedStatus = reader.int32();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.commentQualityScores.push(WebcastChatMessage_CommentQualityScoreDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.userIdentity = WebcastChatMessage_UserIdentityDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag === 160) {
            message.commentTag.push(reader.int32() as any);

            continue;
          }

          if (tag === 162) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.commentTag.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.publicAreaMessageCommon = PublicAreaMessageCommonDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.screenTime = reader.int64().toString();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.signature = reader.string();
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.signatureVersion = reader.string();
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.ecStreamerKey = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastChatMessage_UserIdentity(): WebcastChatMessage_UserIdentity {
  return {
    isGiftGiverOfAnchor: false,
    isSubscriberOfAnchor: false,
    isMutualFollowingWithAnchor: false,
    isFollowerOfAnchor: false,
    isModeratorOfAnchor: false,
    isAnchor: false,
  };
}

export const WebcastChatMessage_UserIdentityDecoder: MessageFns<WebcastChatMessage_UserIdentity> = {
  encode(message: WebcastChatMessage_UserIdentity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isGiftGiverOfAnchor !== false) {
      writer.uint32(8).bool(message.isGiftGiverOfAnchor);
    }
    if (message.isSubscriberOfAnchor !== false) {
      writer.uint32(16).bool(message.isSubscriberOfAnchor);
    }
    if (message.isMutualFollowingWithAnchor !== false) {
      writer.uint32(24).bool(message.isMutualFollowingWithAnchor);
    }
    if (message.isFollowerOfAnchor !== false) {
      writer.uint32(32).bool(message.isFollowerOfAnchor);
    }
    if (message.isModeratorOfAnchor !== false) {
      writer.uint32(40).bool(message.isModeratorOfAnchor);
    }
    if (message.isAnchor !== false) {
      writer.uint32(48).bool(message.isAnchor);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastChatMessage_UserIdentity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastChatMessage_UserIdentity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isGiftGiverOfAnchor = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isSubscriberOfAnchor = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isMutualFollowingWithAnchor = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isFollowerOfAnchor = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isModeratorOfAnchor = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isAnchor = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastChatMessage_CommentQualityScore(): WebcastChatMessage_CommentQualityScore {
  return { version: "", score: "0" };
}

export const WebcastChatMessage_CommentQualityScoreDecoder: MessageFns<WebcastChatMessage_CommentQualityScore> = {
  encode(message: WebcastChatMessage_CommentQualityScore, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    if (message.score !== "0") {
      writer.uint32(16).int64(message.score);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastChatMessage_CommentQualityScore {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastChatMessage_CommentQualityScore();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.score = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseEmoteUploadInfo(): EmoteUploadInfo {
  return { userId: "0", emoteUploadSource: undefined, userInfo: undefined, userIdStr: "" };
}

export const EmoteUploadInfoDecoder: MessageFns<EmoteUploadInfo> = {
  encode(message: EmoteUploadInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "0") {
      writer.uint32(8).int64(message.userId);
    }
    if (message.emoteUploadSource !== undefined) {
      writer.uint32(16).int32(message.emoteUploadSource);
    }
    if (message.userInfo !== undefined) {
      UserDecoder.encode(message.userInfo, writer.uint32(26).fork()).join();
    }
    if (message.userIdStr !== "") {
      writer.uint32(34).string(message.userIdStr);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmoteUploadInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmoteUploadInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.emoteUploadSource = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userInfo = UserDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userIdStr = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastEmoteChatMessage(): WebcastEmoteChatMessage {
  return { common: undefined, user: undefined, emoteList: [], msgFilter: undefined, userIdentity: undefined };
}

export const WebcastEmoteChatMessageDecoder: MessageFns<WebcastEmoteChatMessage> = {
  encode(message: WebcastEmoteChatMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageDataDecoder.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.user !== undefined) {
      UserDecoder.encode(message.user, writer.uint32(18).fork()).join();
    }
    for (const v of message.emoteList) {
      EmoteDecoder.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.msgFilter !== undefined) {
      MsgFilterDecoder.encode(message.msgFilter, writer.uint32(34).fork()).join();
    }
    if (message.userIdentity !== undefined) {
      UserIdentityDecoder.encode(message.userIdentity, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastEmoteChatMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastEmoteChatMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageDataDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.user = UserDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.emoteList.push(EmoteDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.msgFilter = MsgFilterDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.userIdentity = UserIdentityDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastSubEmote(): WebcastSubEmote {
  return { placeInComment: 0, emote: undefined };
}

export const WebcastSubEmoteDecoder: MessageFns<WebcastSubEmote> = {
  encode(message: WebcastSubEmote, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.placeInComment !== 0) {
      writer.uint32(8).int32(message.placeInComment);
    }
    if (message.emote !== undefined) {
      EmoteDetailsDecoder.encode(message.emote, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastSubEmote {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastSubEmote();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.placeInComment = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.emote = EmoteDetailsDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastMemberMessage(): WebcastMemberMessage {
  return {
    common: undefined,
    user: undefined,
    action: 0,
    memberCount: 0,
    operator: undefined,
    isSetToAdmin: false,
    isTopUser: false,
    rankScore: "0",
    topUserNo: "0",
    enterType: "0",
    actionDescription: "",
    userId: "0",
    effectConfig: undefined,
    popStr: "",
    enterEffectConfig: undefined,
    backgroundImage: undefined,
    backgroundImageV2: undefined,
    anchorDisplayText: undefined,
    clientEnterSource: "",
    clientEnterType: "",
    clientLiveReason: "",
    actionDuration: "0",
    userShareType: "",
    displayStyle: 0,
    adminPermissions: {},
    kickSource: 0,
    allowPreviewTime: "0",
    lastSubscriptionAction: "0",
    publicAreaMessageCommon: undefined,
    liveSubOnlyTier: "0",
    liveSubOnlyMonth: "0",
    ecStreamerKey: "",
    showWave: "0",
    waveAlgorithmData: undefined,
    hitAbStatus: 0,
  };
}

export const WebcastMemberMessageDecoder: MessageFns<WebcastMemberMessage> = {
  encode(message: WebcastMemberMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageDataDecoder.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.user !== undefined) {
      UserDecoder.encode(message.user, writer.uint32(18).fork()).join();
    }
    if (message.action !== 0) {
      writer.uint32(80).int32(message.action);
    }
    if (message.memberCount !== 0) {
      writer.uint32(24).int32(message.memberCount);
    }
    if (message.operator !== undefined) {
      UserDecoder.encode(message.operator, writer.uint32(34).fork()).join();
    }
    if (message.isSetToAdmin !== false) {
      writer.uint32(40).bool(message.isSetToAdmin);
    }
    if (message.isTopUser !== false) {
      writer.uint32(48).bool(message.isTopUser);
    }
    if (message.rankScore !== "0") {
      writer.uint32(56).int64(message.rankScore);
    }
    if (message.topUserNo !== "0") {
      writer.uint32(64).int64(message.topUserNo);
    }
    if (message.enterType !== "0") {
      writer.uint32(72).int64(message.enterType);
    }
    if (message.actionDescription !== "") {
      writer.uint32(90).string(message.actionDescription);
    }
    if (message.userId !== "0") {
      writer.uint32(96).int64(message.userId);
    }
    if (message.effectConfig !== undefined) {
      WebcastMemberMessage_EffectConfigDecoder.encode(message.effectConfig, writer.uint32(106).fork()).join();
    }
    if (message.popStr !== "") {
      writer.uint32(114).string(message.popStr);
    }
    if (message.enterEffectConfig !== undefined) {
      WebcastMemberMessage_EffectConfigDecoder.encode(message.enterEffectConfig, writer.uint32(122).fork()).join();
    }
    if (message.backgroundImage !== undefined) {
      ImageDecoder.encode(message.backgroundImage, writer.uint32(130).fork()).join();
    }
    if (message.backgroundImageV2 !== undefined) {
      ImageDecoder.encode(message.backgroundImageV2, writer.uint32(138).fork()).join();
    }
    if (message.anchorDisplayText !== undefined) {
      TextDecoder.encode(message.anchorDisplayText, writer.uint32(146).fork()).join();
    }
    if (message.clientEnterSource !== "") {
      writer.uint32(154).string(message.clientEnterSource);
    }
    if (message.clientEnterType !== "") {
      writer.uint32(162).string(message.clientEnterType);
    }
    if (message.clientLiveReason !== "") {
      writer.uint32(170).string(message.clientLiveReason);
    }
    if (message.actionDuration !== "0") {
      writer.uint32(176).int64(message.actionDuration);
    }
    if (message.userShareType !== "") {
      writer.uint32(186).string(message.userShareType);
    }
    if (message.displayStyle !== 0) {
      writer.uint32(192).int32(message.displayStyle);
    }
    Object.entries(message.adminPermissions).forEach(([key, value]) => {
      WebcastMemberMessage_AdminPermissionsEntryDecoder.encode({ key: key as any, value }, writer.uint32(202).fork()).join();
    });
    if (message.kickSource !== 0) {
      writer.uint32(208).int32(message.kickSource);
    }
    if (message.allowPreviewTime !== "0") {
      writer.uint32(216).int64(message.allowPreviewTime);
    }
    if (message.lastSubscriptionAction !== "0") {
      writer.uint32(224).int64(message.lastSubscriptionAction);
    }
    if (message.publicAreaMessageCommon !== undefined) {
      PublicAreaMessageCommonDecoder.encode(message.publicAreaMessageCommon, writer.uint32(234).fork()).join();
    }
    if (message.liveSubOnlyTier !== "0") {
      writer.uint32(240).int64(message.liveSubOnlyTier);
    }
    if (message.liveSubOnlyMonth !== "0") {
      writer.uint32(248).int64(message.liveSubOnlyMonth);
    }
    if (message.ecStreamerKey !== "") {
      writer.uint32(258).string(message.ecStreamerKey);
    }
    if (message.showWave !== "0") {
      writer.uint32(264).int64(message.showWave);
    }
    if (message.waveAlgorithmData !== undefined) {
      WebcastMemberMessage_WaveAlgorithmDataDecoder.encode(message.waveAlgorithmData, writer.uint32(274).fork()).join();
    }
    if (message.hitAbStatus !== 0) {
      writer.uint32(280).int32(message.hitAbStatus);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastMemberMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastMemberMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageDataDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.user = UserDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.action = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.memberCount = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.operator = UserDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isSetToAdmin = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isTopUser = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.rankScore = reader.int64().toString();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.topUserNo = reader.int64().toString();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.enterType = reader.int64().toString();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.actionDescription = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.userId = reader.int64().toString();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.effectConfig = WebcastMemberMessage_EffectConfigDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.popStr = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.enterEffectConfig = WebcastMemberMessage_EffectConfigDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.backgroundImage = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.backgroundImageV2 = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.anchorDisplayText = TextDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.clientEnterSource = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.clientEnterType = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.clientLiveReason = reader.string();
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.actionDuration = reader.int64().toString();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.userShareType = reader.string();
          continue;
        }
        case 24: {
          if (tag !== 192) {
            break;
          }

          message.displayStyle = reader.int32() as any;
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          const entry25 = WebcastMemberMessage_AdminPermissionsEntryDecoder.decode(reader, reader.uint32());
          if (entry25.value !== undefined) {
            message.adminPermissions[entry25.key] = entry25.value;
          }
          continue;
        }
        case 26: {
          if (tag !== 208) {
            break;
          }

          message.kickSource = reader.int32();
          continue;
        }
        case 27: {
          if (tag !== 216) {
            break;
          }

          message.allowPreviewTime = reader.int64().toString();
          continue;
        }
        case 28: {
          if (tag !== 224) {
            break;
          }

          message.lastSubscriptionAction = reader.int64().toString();
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.publicAreaMessageCommon = PublicAreaMessageCommonDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 30: {
          if (tag !== 240) {
            break;
          }

          message.liveSubOnlyTier = reader.int64().toString();
          continue;
        }
        case 31: {
          if (tag !== 248) {
            break;
          }

          message.liveSubOnlyMonth = reader.int64().toString();
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.ecStreamerKey = reader.string();
          continue;
        }
        case 33: {
          if (tag !== 264) {
            break;
          }

          message.showWave = reader.int64().toString();
          continue;
        }
        case 34: {
          if (tag !== 274) {
            break;
          }

          message.waveAlgorithmData = WebcastMemberMessage_WaveAlgorithmDataDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 35: {
          if (tag !== 280) {
            break;
          }

          message.hitAbStatus = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastMemberMessage_AdminPermissionsEntry(): WebcastMemberMessage_AdminPermissionsEntry {
  return { key: 0, value: 0 };
}

export const WebcastMemberMessage_AdminPermissionsEntryDecoder: MessageFns<WebcastMemberMessage_AdminPermissionsEntry> = {
  encode(message: WebcastMemberMessage_AdminPermissionsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== 0) {
      writer.uint32(8).int32(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastMemberMessage_AdminPermissionsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastMemberMessage_AdminPermissionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastMemberMessage_EffectConfig(): WebcastMemberMessage_EffectConfig {
  return {
    type: "0",
    icon: undefined,
    avatarPos: "0",
    text: undefined,
    textIcon: undefined,
    stayTime: 0,
    animAssetId: "0",
    badge: undefined,
    flexSettingArrayList: [],
  };
}

export const WebcastMemberMessage_EffectConfigDecoder: MessageFns<WebcastMemberMessage_EffectConfig> = {
  encode(message: WebcastMemberMessage_EffectConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "0") {
      writer.uint32(8).int64(message.type);
    }
    if (message.icon !== undefined) {
      ImageDecoder.encode(message.icon, writer.uint32(18).fork()).join();
    }
    if (message.avatarPos !== "0") {
      writer.uint32(24).int64(message.avatarPos);
    }
    if (message.text !== undefined) {
      TextDecoder.encode(message.text, writer.uint32(34).fork()).join();
    }
    if (message.textIcon !== undefined) {
      ImageDecoder.encode(message.textIcon, writer.uint32(42).fork()).join();
    }
    if (message.stayTime !== 0) {
      writer.uint32(48).int32(message.stayTime);
    }
    if (message.animAssetId !== "0") {
      writer.uint32(56).int64(message.animAssetId);
    }
    if (message.badge !== undefined) {
      ImageDecoder.encode(message.badge, writer.uint32(66).fork()).join();
    }
    writer.uint32(74).fork();
    for (const v of message.flexSettingArrayList) {
      writer.int64(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastMemberMessage_EffectConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastMemberMessage_EffectConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.icon = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.avatarPos = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.text = TextDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.textIcon = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.stayTime = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.animAssetId = reader.int64().toString();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.badge = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag === 72) {
            message.flexSettingArrayList.push(reader.int64().toString());

            continue;
          }

          if (tag === 74) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.flexSettingArrayList.push(reader.int64().toString());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastMemberMessage_WaveAlgorithmData(): WebcastMemberMessage_WaveAlgorithmData {
  return { algorithmVersion: "", isAlgHit: false, predictScore: "", isRewatch: false, isFollow: false };
}

export const WebcastMemberMessage_WaveAlgorithmDataDecoder: MessageFns<WebcastMemberMessage_WaveAlgorithmData> = {
  encode(message: WebcastMemberMessage_WaveAlgorithmData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.algorithmVersion !== "") {
      writer.uint32(10).string(message.algorithmVersion);
    }
    if (message.isAlgHit !== false) {
      writer.uint32(16).bool(message.isAlgHit);
    }
    if (message.predictScore !== "") {
      writer.uint32(26).string(message.predictScore);
    }
    if (message.isRewatch !== false) {
      writer.uint32(32).bool(message.isRewatch);
    }
    if (message.isFollow !== false) {
      writer.uint32(40).bool(message.isFollow);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastMemberMessage_WaveAlgorithmData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastMemberMessage_WaveAlgorithmData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.algorithmVersion = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isAlgHit = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.predictScore = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isRewatch = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isFollow = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastMemberMessage_EffectConfigBean(): WebcastMemberMessage_EffectConfigBean {
  return { type: 0, icon: undefined, textKey: undefined, badge: undefined };
}

export const WebcastMemberMessage_EffectConfigBeanDecoder: MessageFns<WebcastMemberMessage_EffectConfigBean> = {
  encode(message: WebcastMemberMessage_EffectConfigBean, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.icon !== undefined) {
      ImageModelDecoder.encode(message.icon, writer.uint32(18).fork()).join();
    }
    if (message.textKey !== undefined) {
      TextDecoder.encode(message.textKey, writer.uint32(34).fork()).join();
    }
    if (message.badge !== undefined) {
      ImageModelDecoder.encode(message.badge, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastMemberMessage_EffectConfigBean {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastMemberMessage_EffectConfigBean();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.icon = ImageModelDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.textKey = TextDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.badge = ImageModelDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGiftMessage(): WebcastGiftMessage {
  return {
    common: undefined,
    giftId: 0,
    user: undefined,
    repeatEnd: 0,
    groupId: "0",
    giftDetails: undefined,
    monitorExtra: "",
    fanTicketCount: "0",
    groupCount: 0,
    repeatCount: 0,
    comboCount: 0,
    toUser: undefined,
    textEffect: undefined,
    incomeTaskgifts: "0",
    roomFanTicketCount: "0",
    priority: undefined,
    logId: "",
    sendType: "0",
    publicAreaCommon: undefined,
    trayDisplayText: undefined,
    bannedDisplayEffects: "0",
    mTrayInfo: undefined,
    giftExtra: undefined,
    colorId: "0",
    isFirstSent: false,
    displayTextForAnchor: undefined,
    displayTextForAudience: undefined,
    orderId: "",
    giftsInBox: undefined,
    msgFilter: undefined,
    lynxExtra: [],
    userIdentity: undefined,
    matchInfo: undefined,
    linkmicGiftExpressionStrategy: 0,
    flyingMicResources: undefined,
    disableGiftTracking: false,
    asset: undefined,
    version: 0,
    sponsorshipInfo: [],
    flyingMicResourcesV2: undefined,
    publicAreaMessageCommon: undefined,
    signature: "",
    signatureVersion: "",
    multiGenerateMessage: false,
    toMemberId: "",
    toMemberIdInt: "0",
    toMemberNickname: "",
    interactiveGiftInfo: undefined,
  };
}

export const WebcastGiftMessageDecoder: MessageFns<WebcastGiftMessage> = {
  encode(message: WebcastGiftMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageDataDecoder.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.giftId !== 0) {
      writer.uint32(16).int32(message.giftId);
    }
    if (message.user !== undefined) {
      UserDecoder.encode(message.user, writer.uint32(58).fork()).join();
    }
    if (message.repeatEnd !== 0) {
      writer.uint32(72).int32(message.repeatEnd);
    }
    if (message.groupId !== "0") {
      writer.uint32(88).uint64(message.groupId);
    }
    if (message.giftDetails !== undefined) {
      GiftDecoder.encode(message.giftDetails, writer.uint32(122).fork()).join();
    }
    if (message.monitorExtra !== "") {
      writer.uint32(178).string(message.monitorExtra);
    }
    if (message.fanTicketCount !== "0") {
      writer.uint32(24).int64(message.fanTicketCount);
    }
    if (message.groupCount !== 0) {
      writer.uint32(32).int32(message.groupCount);
    }
    if (message.repeatCount !== 0) {
      writer.uint32(40).int32(message.repeatCount);
    }
    if (message.comboCount !== 0) {
      writer.uint32(48).int32(message.comboCount);
    }
    if (message.toUser !== undefined) {
      UserDecoder.encode(message.toUser, writer.uint32(66).fork()).join();
    }
    if (message.textEffect !== undefined) {
      WebcastGiftMessage_TextEffectDecoder.encode(message.textEffect, writer.uint32(82).fork()).join();
    }
    if (message.incomeTaskgifts !== "0") {
      writer.uint32(96).int64(message.incomeTaskgifts);
    }
    if (message.roomFanTicketCount !== "0") {
      writer.uint32(104).int64(message.roomFanTicketCount);
    }
    if (message.priority !== undefined) {
      WebcastGiftMessage_GiftIMPriorityDecoder.encode(message.priority, writer.uint32(114).fork()).join();
    }
    if (message.logId !== "") {
      writer.uint32(130).string(message.logId);
    }
    if (message.sendType !== "0") {
      writer.uint32(136).int64(message.sendType);
    }
    if (message.publicAreaCommon !== undefined) {
      PublicAreaCommonDecoder.encode(message.publicAreaCommon, writer.uint32(146).fork()).join();
    }
    if (message.trayDisplayText !== undefined) {
      TextDecoder.encode(message.trayDisplayText, writer.uint32(154).fork()).join();
    }
    if (message.bannedDisplayEffects !== "0") {
      writer.uint32(160).int64(message.bannedDisplayEffects);
    }
    if (message.mTrayInfo !== undefined) {
      WebcastGiftMessage_GiftTrayInfoDecoder.encode(message.mTrayInfo, writer.uint32(170).fork()).join();
    }
    if (message.giftExtra !== undefined) {
      WebcastGiftMessage_GiftMonitorInfoDecoder.encode(message.giftExtra, writer.uint32(186).fork()).join();
    }
    if (message.colorId !== "0") {
      writer.uint32(192).int64(message.colorId);
    }
    if (message.isFirstSent !== false) {
      writer.uint32(200).bool(message.isFirstSent);
    }
    if (message.displayTextForAnchor !== undefined) {
      TextDecoder.encode(message.displayTextForAnchor, writer.uint32(210).fork()).join();
    }
    if (message.displayTextForAudience !== undefined) {
      TextDecoder.encode(message.displayTextForAudience, writer.uint32(218).fork()).join();
    }
    if (message.orderId !== "") {
      writer.uint32(226).string(message.orderId);
    }
    if (message.giftsInBox !== undefined) {
      WebcastGiftMessage_GiftsBoxInfoDecoder.encode(message.giftsInBox, writer.uint32(234).fork()).join();
    }
    if (message.msgFilter !== undefined) {
      MsgFilterDecoder.encode(message.msgFilter, writer.uint32(242).fork()).join();
    }
    for (const v of message.lynxExtra) {
      WebcastGiftMessage_LynxGiftExtraDecoder.encode(v!, writer.uint32(250).fork()).join();
    }
    if (message.userIdentity !== undefined) {
      UserIdentityDecoder.encode(message.userIdentity, writer.uint32(258).fork()).join();
    }
    if (message.matchInfo !== undefined) {
      WebcastGiftMessage_MatchInfoDecoder.encode(message.matchInfo, writer.uint32(266).fork()).join();
    }
    if (message.linkmicGiftExpressionStrategy !== 0) {
      writer.uint32(272).int32(message.linkmicGiftExpressionStrategy);
    }
    if (message.flyingMicResources !== undefined) {
      WebcastGiftMessage_FlyingMicResourcesDecoder.encode(message.flyingMicResources, writer.uint32(282).fork()).join();
    }
    if (message.disableGiftTracking !== false) {
      writer.uint32(288).bool(message.disableGiftTracking);
    }
    if (message.asset !== undefined) {
      WebcastGiftMessage_AssetsModelDecoder.encode(message.asset, writer.uint32(298).fork()).join();
    }
    if (message.version !== 0) {
      writer.uint32(304).int32(message.version);
    }
    for (const v of message.sponsorshipInfo) {
      WebcastGiftMessage_SponsorshipInfoDecoder.encode(v!, writer.uint32(314).fork()).join();
    }
    if (message.flyingMicResourcesV2 !== undefined) {
      WebcastGiftMessage_FlyingMicResourcesDecoder.encode(message.flyingMicResourcesV2, writer.uint32(322).fork()).join();
    }
    if (message.publicAreaMessageCommon !== undefined) {
      PublicAreaMessageCommonDecoder.encode(message.publicAreaMessageCommon, writer.uint32(330).fork()).join();
    }
    if (message.signature !== "") {
      writer.uint32(338).string(message.signature);
    }
    if (message.signatureVersion !== "") {
      writer.uint32(346).string(message.signatureVersion);
    }
    if (message.multiGenerateMessage !== false) {
      writer.uint32(352).bool(message.multiGenerateMessage);
    }
    if (message.toMemberId !== "") {
      writer.uint32(362).string(message.toMemberId);
    }
    if (message.toMemberIdInt !== "0") {
      writer.uint32(368).int64(message.toMemberIdInt);
    }
    if (message.toMemberNickname !== "") {
      writer.uint32(378).string(message.toMemberNickname);
    }
    if (message.interactiveGiftInfo !== undefined) {
      WebcastGiftMessage_InteractiveGiftInfoDecoder.encode(message.interactiveGiftInfo, writer.uint32(386).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGiftMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageDataDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.giftId = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.user = UserDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.repeatEnd = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.groupId = reader.uint64().toString();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.giftDetails = GiftDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.monitorExtra = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.fanTicketCount = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.groupCount = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.repeatCount = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.comboCount = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.toUser = UserDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.textEffect = WebcastGiftMessage_TextEffectDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.incomeTaskgifts = reader.int64().toString();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.roomFanTicketCount = reader.int64().toString();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.priority = WebcastGiftMessage_GiftIMPriorityDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.logId = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.sendType = reader.int64().toString();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.publicAreaCommon = PublicAreaCommonDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.trayDisplayText = TextDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.bannedDisplayEffects = reader.int64().toString();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.mTrayInfo = WebcastGiftMessage_GiftTrayInfoDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.giftExtra = WebcastGiftMessage_GiftMonitorInfoDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 192) {
            break;
          }

          message.colorId = reader.int64().toString();
          continue;
        }
        case 25: {
          if (tag !== 200) {
            break;
          }

          message.isFirstSent = reader.bool();
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.displayTextForAnchor = TextDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.displayTextForAudience = TextDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.giftsInBox = WebcastGiftMessage_GiftsBoxInfoDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.msgFilter = MsgFilterDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.lynxExtra.push(WebcastGiftMessage_LynxGiftExtraDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.userIdentity = UserIdentityDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 33: {
          if (tag !== 266) {
            break;
          }

          message.matchInfo = WebcastGiftMessage_MatchInfoDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 34: {
          if (tag !== 272) {
            break;
          }

          message.linkmicGiftExpressionStrategy = reader.int32() as any;
          continue;
        }
        case 35: {
          if (tag !== 282) {
            break;
          }

          message.flyingMicResources = WebcastGiftMessage_FlyingMicResourcesDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 36: {
          if (tag !== 288) {
            break;
          }

          message.disableGiftTracking = reader.bool();
          continue;
        }
        case 37: {
          if (tag !== 298) {
            break;
          }

          message.asset = WebcastGiftMessage_AssetsModelDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 38: {
          if (tag !== 304) {
            break;
          }

          message.version = reader.int32() as any;
          continue;
        }
        case 39: {
          if (tag !== 314) {
            break;
          }

          message.sponsorshipInfo.push(WebcastGiftMessage_SponsorshipInfoDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 40: {
          if (tag !== 322) {
            break;
          }

          message.flyingMicResourcesV2 = WebcastGiftMessage_FlyingMicResourcesDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 41: {
          if (tag !== 330) {
            break;
          }

          message.publicAreaMessageCommon = PublicAreaMessageCommonDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 42: {
          if (tag !== 338) {
            break;
          }

          message.signature = reader.string();
          continue;
        }
        case 43: {
          if (tag !== 346) {
            break;
          }

          message.signatureVersion = reader.string();
          continue;
        }
        case 44: {
          if (tag !== 352) {
            break;
          }

          message.multiGenerateMessage = reader.bool();
          continue;
        }
        case 45: {
          if (tag !== 362) {
            break;
          }

          message.toMemberId = reader.string();
          continue;
        }
        case 46: {
          if (tag !== 368) {
            break;
          }

          message.toMemberIdInt = reader.int64().toString();
          continue;
        }
        case 47: {
          if (tag !== 378) {
            break;
          }

          message.toMemberNickname = reader.string();
          continue;
        }
        case 48: {
          if (tag !== 386) {
            break;
          }

          message.interactiveGiftInfo = WebcastGiftMessage_InteractiveGiftInfoDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGiftMessage_InteractiveGiftInfo(): WebcastGiftMessage_InteractiveGiftInfo {
  return { crossScreenDelay: "0", crossScreenRole: "0", ignoreConfig: 0, uniqId: "0", toUserTeamId: "0" };
}

export const WebcastGiftMessage_InteractiveGiftInfoDecoder: MessageFns<WebcastGiftMessage_InteractiveGiftInfo> = {
  encode(message: WebcastGiftMessage_InteractiveGiftInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.crossScreenDelay !== "0") {
      writer.uint32(8).int64(message.crossScreenDelay);
    }
    if (message.crossScreenRole !== "0") {
      writer.uint32(16).int64(message.crossScreenRole);
    }
    if (message.ignoreConfig !== 0) {
      writer.uint32(24).int32(message.ignoreConfig);
    }
    if (message.uniqId !== "0") {
      writer.uint32(32).int64(message.uniqId);
    }
    if (message.toUserTeamId !== "0") {
      writer.uint32(40).int64(message.toUserTeamId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGiftMessage_InteractiveGiftInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessage_InteractiveGiftInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.crossScreenDelay = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.crossScreenRole = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.ignoreConfig = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.uniqId = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.toUserTeamId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGiftMessage_GiftIMPriority(): WebcastGiftMessage_GiftIMPriority {
  return { queueSizesList: [], selfQueuePriority: "0", priority: "0" };
}

export const WebcastGiftMessage_GiftIMPriorityDecoder: MessageFns<WebcastGiftMessage_GiftIMPriority> = {
  encode(message: WebcastGiftMessage_GiftIMPriority, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.queueSizesList) {
      writer.int64(v);
    }
    writer.join();
    if (message.selfQueuePriority !== "0") {
      writer.uint32(16).int64(message.selfQueuePriority);
    }
    if (message.priority !== "0") {
      writer.uint32(24).int64(message.priority);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGiftMessage_GiftIMPriority {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessage_GiftIMPriority();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.queueSizesList.push(reader.int64().toString());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.queueSizesList.push(reader.int64().toString());
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.selfQueuePriority = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.priority = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGiftMessage_TextEffect(): WebcastGiftMessage_TextEffect {
  return { portraitDetail: undefined, landscapeDetail: undefined };
}

export const WebcastGiftMessage_TextEffectDecoder: MessageFns<WebcastGiftMessage_TextEffect> = {
  encode(message: WebcastGiftMessage_TextEffect, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.portraitDetail !== undefined) {
      WebcastGiftMessage_TextEffect_DetailDecoder.encode(message.portraitDetail, writer.uint32(10).fork()).join();
    }
    if (message.landscapeDetail !== undefined) {
      WebcastGiftMessage_TextEffect_DetailDecoder.encode(message.landscapeDetail, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGiftMessage_TextEffect {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessage_TextEffect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.portraitDetail = WebcastGiftMessage_TextEffect_DetailDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.landscapeDetail = WebcastGiftMessage_TextEffect_DetailDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGiftMessage_TextEffect_Detail(): WebcastGiftMessage_TextEffect_Detail {
  return {
    text: undefined,
    textFontSize: 0,
    background: undefined,
    start: "0",
    duration: "0",
    x: 0,
    y: 0,
    width: 0,
    height: 0,
    shadowDx: 0,
    shadowDy: 0,
    shadowRadius: 0,
    shadowColor: "",
    strokeColor: "",
    strokeWidth: 0,
  };
}

export const WebcastGiftMessage_TextEffect_DetailDecoder: MessageFns<WebcastGiftMessage_TextEffect_Detail> = {
  encode(message: WebcastGiftMessage_TextEffect_Detail, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== undefined) {
      TextDecoder.encode(message.text, writer.uint32(10).fork()).join();
    }
    if (message.textFontSize !== 0) {
      writer.uint32(16).int32(message.textFontSize);
    }
    if (message.background !== undefined) {
      ImageDecoder.encode(message.background, writer.uint32(26).fork()).join();
    }
    if (message.start !== "0") {
      writer.uint32(32).int64(message.start);
    }
    if (message.duration !== "0") {
      writer.uint32(40).int64(message.duration);
    }
    if (message.x !== 0) {
      writer.uint32(48).int32(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(56).int32(message.y);
    }
    if (message.width !== 0) {
      writer.uint32(64).int32(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(72).int32(message.height);
    }
    if (message.shadowDx !== 0) {
      writer.uint32(80).int32(message.shadowDx);
    }
    if (message.shadowDy !== 0) {
      writer.uint32(88).int32(message.shadowDy);
    }
    if (message.shadowRadius !== 0) {
      writer.uint32(96).int32(message.shadowRadius);
    }
    if (message.shadowColor !== "") {
      writer.uint32(106).string(message.shadowColor);
    }
    if (message.strokeColor !== "") {
      writer.uint32(114).string(message.strokeColor);
    }
    if (message.strokeWidth !== 0) {
      writer.uint32(120).int32(message.strokeWidth);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGiftMessage_TextEffect_Detail {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessage_TextEffect_Detail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.text = TextDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.textFontSize = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.background = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.start = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.duration = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.x = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.y = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.width = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.height = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.shadowDx = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.shadowDy = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.shadowRadius = reader.int32();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.shadowColor = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.strokeColor = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.strokeWidth = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGiftMessage_GiftTrayInfo(): WebcastGiftMessage_GiftTrayInfo {
  return {
    mDynamicImg: undefined,
    canMirror: false,
    trayNormalBgImg: undefined,
    trayNormalBgColor: [],
    traySmallBgImg: undefined,
    traySmallBgColor: [],
    rightTagText: undefined,
    rightTagBgImg: undefined,
    rightTagBgColor: [],
    trayNameTextColor: "",
    trayDescTextColor: "",
    rightTagJumpSchema: "",
  };
}

export const WebcastGiftMessage_GiftTrayInfoDecoder: MessageFns<WebcastGiftMessage_GiftTrayInfo> = {
  encode(message: WebcastGiftMessage_GiftTrayInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mDynamicImg !== undefined) {
      ImageDecoder.encode(message.mDynamicImg, writer.uint32(10).fork()).join();
    }
    if (message.canMirror !== false) {
      writer.uint32(16).bool(message.canMirror);
    }
    if (message.trayNormalBgImg !== undefined) {
      ImageDecoder.encode(message.trayNormalBgImg, writer.uint32(26).fork()).join();
    }
    for (const v of message.trayNormalBgColor) {
      writer.uint32(34).string(v!);
    }
    if (message.traySmallBgImg !== undefined) {
      ImageDecoder.encode(message.traySmallBgImg, writer.uint32(42).fork()).join();
    }
    for (const v of message.traySmallBgColor) {
      writer.uint32(50).string(v!);
    }
    if (message.rightTagText !== undefined) {
      TextDecoder.encode(message.rightTagText, writer.uint32(58).fork()).join();
    }
    if (message.rightTagBgImg !== undefined) {
      ImageDecoder.encode(message.rightTagBgImg, writer.uint32(66).fork()).join();
    }
    for (const v of message.rightTagBgColor) {
      writer.uint32(74).string(v!);
    }
    if (message.trayNameTextColor !== "") {
      writer.uint32(82).string(message.trayNameTextColor);
    }
    if (message.trayDescTextColor !== "") {
      writer.uint32(90).string(message.trayDescTextColor);
    }
    if (message.rightTagJumpSchema !== "") {
      writer.uint32(98).string(message.rightTagJumpSchema);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGiftMessage_GiftTrayInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessage_GiftTrayInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mDynamicImg = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.canMirror = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.trayNormalBgImg = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.trayNormalBgColor.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.traySmallBgImg = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.traySmallBgColor.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.rightTagText = TextDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.rightTagBgImg = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.rightTagBgColor.push(reader.string());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.trayNameTextColor = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.trayDescTextColor = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.rightTagJumpSchema = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGiftMessage_GiftMonitorInfo(): WebcastGiftMessage_GiftMonitorInfo {
  return {
    anchorId: "0",
    profitApiMessageDur: "0",
    sendGiftProfitApiStartMs: "0",
    sendGiftProfitCoreStartMs: "0",
    sendGiftReqStartMs: "0",
    sendGiftSendMessageSuccessMs: "0",
    sendProfitApiDur: "0",
    toUserId: "0",
    sendGiftStartClientLocalMs: "0",
    fromPlatform: "",
    fromVersion: "",
  };
}

export const WebcastGiftMessage_GiftMonitorInfoDecoder: MessageFns<WebcastGiftMessage_GiftMonitorInfo> = {
  encode(message: WebcastGiftMessage_GiftMonitorInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.anchorId !== "0") {
      writer.uint32(8).int64(message.anchorId);
    }
    if (message.profitApiMessageDur !== "0") {
      writer.uint32(16).int64(message.profitApiMessageDur);
    }
    if (message.sendGiftProfitApiStartMs !== "0") {
      writer.uint32(24).int64(message.sendGiftProfitApiStartMs);
    }
    if (message.sendGiftProfitCoreStartMs !== "0") {
      writer.uint32(32).int64(message.sendGiftProfitCoreStartMs);
    }
    if (message.sendGiftReqStartMs !== "0") {
      writer.uint32(40).int64(message.sendGiftReqStartMs);
    }
    if (message.sendGiftSendMessageSuccessMs !== "0") {
      writer.uint32(48).int64(message.sendGiftSendMessageSuccessMs);
    }
    if (message.sendProfitApiDur !== "0") {
      writer.uint32(56).int64(message.sendProfitApiDur);
    }
    if (message.toUserId !== "0") {
      writer.uint32(64).int64(message.toUserId);
    }
    if (message.sendGiftStartClientLocalMs !== "0") {
      writer.uint32(72).int64(message.sendGiftStartClientLocalMs);
    }
    if (message.fromPlatform !== "") {
      writer.uint32(82).string(message.fromPlatform);
    }
    if (message.fromVersion !== "") {
      writer.uint32(90).string(message.fromVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGiftMessage_GiftMonitorInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessage_GiftMonitorInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.anchorId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.profitApiMessageDur = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.sendGiftProfitApiStartMs = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.sendGiftProfitCoreStartMs = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.sendGiftReqStartMs = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.sendGiftSendMessageSuccessMs = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.sendProfitApiDur = reader.int64().toString();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.toUserId = reader.int64().toString();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.sendGiftStartClientLocalMs = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.fromPlatform = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.fromVersion = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGiftMessage_MatchInfo(): WebcastGiftMessage_MatchInfo {
  return { critical: "0", effectCardInUse: false, multiplierType: 0, multiplierValue: "0" };
}

export const WebcastGiftMessage_MatchInfoDecoder: MessageFns<WebcastGiftMessage_MatchInfo> = {
  encode(message: WebcastGiftMessage_MatchInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.critical !== "0") {
      writer.uint32(8).int64(message.critical);
    }
    if (message.effectCardInUse !== false) {
      writer.uint32(16).bool(message.effectCardInUse);
    }
    if (message.multiplierType !== 0) {
      writer.uint32(24).int32(message.multiplierType);
    }
    if (message.multiplierValue !== "0") {
      writer.uint32(32).int64(message.multiplierValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGiftMessage_MatchInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessage_MatchInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.critical = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.effectCardInUse = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.multiplierType = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.multiplierValue = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGiftMessage_GiftsBoxInfo(): WebcastGiftMessage_GiftsBoxInfo {
  return { gifts: [] };
}

export const WebcastGiftMessage_GiftsBoxInfoDecoder: MessageFns<WebcastGiftMessage_GiftsBoxInfo> = {
  encode(message: WebcastGiftMessage_GiftsBoxInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.gifts) {
      WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBoxDecoder.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGiftMessage_GiftsBoxInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessage_GiftsBoxInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.gifts.push(WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBoxDecoder.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox(): WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox {
  return { giftId: "0", effectId: "0", colorId: "0", remainTimes: 0, asset: undefined };
}

export const WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBoxDecoder: MessageFns<WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox> =
  {
    encode(
      message: WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.giftId !== "0") {
        writer.uint32(8).int64(message.giftId);
      }
      if (message.effectId !== "0") {
        writer.uint32(16).int64(message.effectId);
      }
      if (message.colorId !== "0") {
        writer.uint32(24).int64(message.colorId);
      }
      if (message.remainTimes !== 0) {
        writer.uint32(32).int32(message.remainTimes);
      }
      if (message.asset !== undefined) {
        WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel.encode(message.asset, writer.uint32(42).fork())
          .join();
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseWebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.giftId = reader.int64().toString();
            continue;
          }
          case 2: {
            if (tag !== 16) {
              break;
            }

            message.effectId = reader.int64().toString();
            continue;
          }
          case 3: {
            if (tag !== 24) {
              break;
            }

            message.colorId = reader.int64().toString();
            continue;
          }
          case 4: {
            if (tag !== 32) {
              break;
            }

            message.remainTimes = reader.int32();
            continue;
          }
          case 5: {
            if (tag !== 42) {
              break;
            }

            message.asset = WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },
  };

function createBaseWebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel(): WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel {
  return {
    name: "",
    resourceUri: "",
    resourceModel: undefined,
    describe: "",
    id: "0",
    resourceType: 0,
    md5: "",
    size: "0",
    lokiExtraContent: undefined,
    downloadType: 0,
    resourceByteVC1Model: undefined,
    bytevc1Md5: "",
    videoResourceList: [],
    faceRecognitionArchiveMeta: undefined,
    lynxUrlSettingsKey: "",
    downgradeResourceType: 0,
    assetExtra: undefined,
    stickerAssetVariant: 0,
    immediateDownload: false,
    stickerAssetVariantReason: 0,
  };
}

export const WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel: MessageFns<
  WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel> = {
  encode(
    message: WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.resourceUri !== "") {
      writer.uint32(18).string(message.resourceUri);
    }
    if (message.resourceModel !== undefined) {
      WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_ResourceModelDecoder.encode(
        message.resourceModel,
        writer.uint32(34).fork(),
      ).join();
    }
    if (message.describe !== "") {
      writer.uint32(42).string(message.describe);
    }
    if (message.id !== "0") {
      writer.uint32(48).int64(message.id);
    }
    if (message.resourceType !== 0) {
      writer.uint32(56).int32(message.resourceType);
    }
    if (message.md5 !== "") {
      writer.uint32(66).string(message.md5);
    }
    if (message.size !== "0") {
      writer.uint32(72).int64(message.size);
    }
    if (message.lokiExtraContent !== undefined) {
      WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContentDecoder.encode(
        message.lokiExtraContent,
        writer.uint32(82).fork(),
      ).join();
    }
    if (message.downloadType !== 0) {
      writer.uint32(208).int32(message.downloadType);
    }
    if (message.resourceByteVC1Model !== undefined) {
      WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_ResourceModelDecoder.encode(
        message.resourceByteVC1Model,
        writer.uint32(226).fork(),
      ).join();
    }
    if (message.bytevc1Md5 !== "") {
      writer.uint32(234).string(message.bytevc1Md5);
    }
    for (const v of message.videoResourceList) {
      WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_VideoResourceDecoder.encode(v!, writer.uint32(242).fork())
        .join();
    }
    if (message.faceRecognitionArchiveMeta !== undefined) {
      WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_FaceRecognitionMetaDecoder.encode(
        message.faceRecognitionArchiveMeta,
        writer.uint32(250).fork(),
      ).join();
    }
    if (message.lynxUrlSettingsKey !== "") {
      writer.uint32(258).string(message.lynxUrlSettingsKey);
    }
    if (message.downgradeResourceType !== 0) {
      writer.uint32(264).int32(message.downgradeResourceType);
    }
    if (message.assetExtra !== undefined) {
      WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_AssetExtraDecoder.encode(
        message.assetExtra,
        writer.uint32(274).fork(),
      ).join();
    }
    if (message.stickerAssetVariant !== 0) {
      writer.uint32(280).int32(message.stickerAssetVariant);
    }
    if (message.immediateDownload !== false) {
      writer.uint32(288).bool(message.immediateDownload);
    }
    if (message.stickerAssetVariantReason !== 0) {
      writer.uint32(296).int32(message.stickerAssetVariantReason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.resourceUri = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.resourceModel = WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_ResourceModelDecoder.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.describe = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.id = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.resourceType = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.md5 = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.size = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.lokiExtraContent = WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContentDecoder.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 26: {
          if (tag !== 208) {
            break;
          }

          message.downloadType = reader.int32();
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.resourceByteVC1Model = WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_ResourceModelDecoder.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.bytevc1Md5 = reader.string();
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.videoResourceList.push(
            WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_VideoResourceDecoder.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.faceRecognitionArchiveMeta =
            WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_FaceRecognitionMetaDecoder.decode(
              reader,
              reader.uint32(),
            );
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.lynxUrlSettingsKey = reader.string();
          continue;
        }
        case 33: {
          if (tag !== 264) {
            break;
          }

          message.downgradeResourceType = reader.int32();
          continue;
        }
        case 34: {
          if (tag !== 274) {
            break;
          }

          message.assetExtra = WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_AssetExtraDecoder.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 35: {
          if (tag !== 280) {
            break;
          }

          message.stickerAssetVariant = reader.int32();
          continue;
        }
        case 36: {
          if (tag !== 288) {
            break;
          }

          message.immediateDownload = reader.bool();
          continue;
        }
        case 37: {
          if (tag !== 296) {
            break;
          }

          message.stickerAssetVariantReason = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_AssetExtra(): WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_AssetExtra {
  return { effectStarlingKey: "" };
}

export const WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_AssetExtraDecoder: MessageFns<WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_AssetExtra> = {
  encode(
    message: WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_AssetExtra,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.effectStarlingKey !== "") {
      writer.uint32(10).string(message.effectStarlingKey);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_AssetExtra {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_AssetExtra();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.effectStarlingKey = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_ResourceModel(): WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_ResourceModel {
  return { urlList: [], uri: "" };
}

export const WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_ResourceModelDecoder: MessageFns<WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_ResourceModel> = {
  encode(
    message: WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_ResourceModel,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.urlList) {
      writer.uint32(10).string(v!);
    }
    if (message.uri !== "") {
      writer.uint32(18).string(message.uri);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_ResourceModel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_ResourceModel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.urlList.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContent(): WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContent {
  return {
    giftType: "",
    giftDuration: "0",
    needScreenShot: false,
    ismultiFrame: false,
    viewOverlay: "",
    befViewRenderSize: undefined,
    befViewRenderFPS: 0,
    befViewFitMode: 0,
    modelNames: "",
    requirements: [],
  };
}

export const WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContentDecoder: MessageFns<WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContent> = {
  encode(
    message: WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContent,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.giftType !== "") {
      writer.uint32(10).string(message.giftType);
    }
    if (message.giftDuration !== "0") {
      writer.uint32(16).int64(message.giftDuration);
    }
    if (message.needScreenShot !== false) {
      writer.uint32(24).bool(message.needScreenShot);
    }
    if (message.ismultiFrame !== false) {
      writer.uint32(32).bool(message.ismultiFrame);
    }
    if (message.viewOverlay !== "") {
      writer.uint32(42).string(message.viewOverlay);
    }
    if (message.befViewRenderSize !== undefined) {
      WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContent_BEFViewRenderSizeDecoder.encode(
        message.befViewRenderSize,
        writer.uint32(50).fork(),
      ).join();
    }
    if (message.befViewRenderFPS !== 0) {
      writer.uint32(56).int32(message.befViewRenderFPS);
    }
    if (message.befViewFitMode !== 0) {
      writer.uint32(64).int32(message.befViewFitMode);
    }
    if (message.modelNames !== "") {
      writer.uint32(74).string(message.modelNames);
    }
    for (const v of message.requirements) {
      writer.uint32(82).string(v!);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.giftType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.giftDuration = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.needScreenShot = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.ismultiFrame = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.viewOverlay = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.befViewRenderSize =
            WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContent_BEFViewRenderSizeDecoder.decode(
              reader,
              reader.uint32(),
            );
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.befViewRenderFPS = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.befViewFitMode = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.modelNames = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.requirements.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContent_BEFViewRenderSize(): WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContent_BEFViewRenderSize {
  return { with: 0, height: 0 };
}

export const WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContent_BEFViewRenderSizeDecoder: MessageFns<WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContent_BEFViewRenderSize> = {
  encode(
    message: WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContent_BEFViewRenderSize,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.with !== 0) {
      writer.uint32(8).int32(message.with);
    }
    if (message.height !== 0) {
      writer.uint32(16).int32(message.height);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContent_BEFViewRenderSize {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message =
      createBaseWebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContent_BEFViewRenderSize();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.with = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.height = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_VideoResource(): WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_VideoResource {
  return { videoTypeName: "", videoUrl: undefined, videoMd5: "" };
}

export const WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_VideoResourceDecoder: MessageFns<WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_VideoResource> = {
  encode(
    message: WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_VideoResource,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.videoTypeName !== "") {
      writer.uint32(10).string(message.videoTypeName);
    }
    if (message.videoUrl !== undefined) {
      WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_ResourceModelDecoder.encode(
        message.videoUrl,
        writer.uint32(18).fork(),
      ).join();
    }
    if (message.videoMd5 !== "") {
      writer.uint32(26).string(message.videoMd5);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_VideoResource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_VideoResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.videoTypeName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.videoUrl = WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_ResourceModelDecoder.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.videoMd5 = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_FaceRecognitionMeta(): WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_FaceRecognitionMeta {
  return { version: "", requirements: [], modelNames: "", sdkExtra: "" };
}

export const WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_FaceRecognitionMetaDecoder: MessageFns<WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_FaceRecognitionMeta> = {
  encode(
    message: WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_FaceRecognitionMeta,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    for (const v of message.requirements) {
      writer.uint32(18).string(v!);
    }
    if (message.modelNames !== "") {
      writer.uint32(26).string(message.modelNames);
    }
    if (message.sdkExtra !== "") {
      writer.uint32(34).string(message.sdkExtra);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_FaceRecognitionMeta {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_FaceRecognitionMeta();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.requirements.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.modelNames = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sdkExtra = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGiftMessage_AssetsModel(): WebcastGiftMessage_AssetsModel {
  return {
    name: "",
    resourceUri: "",
    resourceModel: undefined,
    describe: "",
    id: "0",
    resourceType: 0,
    md5: "",
    size: "0",
    lokiExtraContent: undefined,
    downloadType: 0,
    resourceByteVC1Model: undefined,
    bytevc1Md5: "",
    videoResourceList: [],
    faceRecognitionArchiveMeta: undefined,
    lynxUrlSettingsKey: "",
    downgradeResourceType: 0,
    assetExtra: undefined,
    stickerAssetVariant: 0,
    immediateDownload: false,
    stickerAssetVariantReason: 0,
  };
}

export const WebcastGiftMessage_AssetsModelDecoder: MessageFns<WebcastGiftMessage_AssetsModel> = {
  encode(message: WebcastGiftMessage_AssetsModel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.resourceUri !== "") {
      writer.uint32(18).string(message.resourceUri);
    }
    if (message.resourceModel !== undefined) {
      WebcastGiftMessage_AssetsModel_ResourceModelDecoder.encode(message.resourceModel, writer.uint32(34).fork()).join();
    }
    if (message.describe !== "") {
      writer.uint32(42).string(message.describe);
    }
    if (message.id !== "0") {
      writer.uint32(48).int64(message.id);
    }
    if (message.resourceType !== 0) {
      writer.uint32(56).int32(message.resourceType);
    }
    if (message.md5 !== "") {
      writer.uint32(66).string(message.md5);
    }
    if (message.size !== "0") {
      writer.uint32(72).int64(message.size);
    }
    if (message.lokiExtraContent !== undefined) {
      WebcastGiftMessage_AssetsModel_LokiExtraContentDecoder.encode(message.lokiExtraContent, writer.uint32(82).fork()).join();
    }
    if (message.downloadType !== 0) {
      writer.uint32(208).int32(message.downloadType);
    }
    if (message.resourceByteVC1Model !== undefined) {
      WebcastGiftMessage_AssetsModel_ResourceModelDecoder.encode(message.resourceByteVC1Model, writer.uint32(226).fork())
        .join();
    }
    if (message.bytevc1Md5 !== "") {
      writer.uint32(234).string(message.bytevc1Md5);
    }
    for (const v of message.videoResourceList) {
      WebcastGiftMessage_AssetsModel_VideoResourceDecoder.encode(v!, writer.uint32(242).fork()).join();
    }
    if (message.faceRecognitionArchiveMeta !== undefined) {
      WebcastGiftMessage_AssetsModel_FaceRecognitionMetaDecoder.encode(
        message.faceRecognitionArchiveMeta,
        writer.uint32(250).fork(),
      ).join();
    }
    if (message.lynxUrlSettingsKey !== "") {
      writer.uint32(258).string(message.lynxUrlSettingsKey);
    }
    if (message.downgradeResourceType !== 0) {
      writer.uint32(264).int32(message.downgradeResourceType);
    }
    if (message.assetExtra !== undefined) {
      WebcastGiftMessage_AssetsModel_AssetExtraDecoder.encode(message.assetExtra, writer.uint32(274).fork()).join();
    }
    if (message.stickerAssetVariant !== 0) {
      writer.uint32(280).int32(message.stickerAssetVariant);
    }
    if (message.immediateDownload !== false) {
      writer.uint32(288).bool(message.immediateDownload);
    }
    if (message.stickerAssetVariantReason !== 0) {
      writer.uint32(296).int32(message.stickerAssetVariantReason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGiftMessage_AssetsModel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessage_AssetsModel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.resourceUri = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.resourceModel = WebcastGiftMessage_AssetsModel_ResourceModelDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.describe = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.id = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.resourceType = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.md5 = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.size = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.lokiExtraContent = WebcastGiftMessage_AssetsModel_LokiExtraContentDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 26: {
          if (tag !== 208) {
            break;
          }

          message.downloadType = reader.int32();
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.resourceByteVC1Model = WebcastGiftMessage_AssetsModel_ResourceModelDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.bytevc1Md5 = reader.string();
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.videoResourceList.push(WebcastGiftMessage_AssetsModel_VideoResourceDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.faceRecognitionArchiveMeta = WebcastGiftMessage_AssetsModel_FaceRecognitionMetaDecoder.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.lynxUrlSettingsKey = reader.string();
          continue;
        }
        case 33: {
          if (tag !== 264) {
            break;
          }

          message.downgradeResourceType = reader.int32();
          continue;
        }
        case 34: {
          if (tag !== 274) {
            break;
          }

          message.assetExtra = WebcastGiftMessage_AssetsModel_AssetExtraDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 35: {
          if (tag !== 280) {
            break;
          }

          message.stickerAssetVariant = reader.int32();
          continue;
        }
        case 36: {
          if (tag !== 288) {
            break;
          }

          message.immediateDownload = reader.bool();
          continue;
        }
        case 37: {
          if (tag !== 296) {
            break;
          }

          message.stickerAssetVariantReason = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGiftMessage_AssetsModel_AssetExtra(): WebcastGiftMessage_AssetsModel_AssetExtra {
  return { effectStarlingKey: "" };
}

export const WebcastGiftMessage_AssetsModel_AssetExtraDecoder: MessageFns<WebcastGiftMessage_AssetsModel_AssetExtra> = {
  encode(message: WebcastGiftMessage_AssetsModel_AssetExtra, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.effectStarlingKey !== "") {
      writer.uint32(10).string(message.effectStarlingKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGiftMessage_AssetsModel_AssetExtra {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessage_AssetsModel_AssetExtra();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.effectStarlingKey = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGiftMessage_AssetsModel_ResourceModel(): WebcastGiftMessage_AssetsModel_ResourceModel {
  return { urlList: [], uri: "" };
}

export const WebcastGiftMessage_AssetsModel_ResourceModelDecoder: MessageFns<WebcastGiftMessage_AssetsModel_ResourceModel> = {
  encode(
    message: WebcastGiftMessage_AssetsModel_ResourceModel,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.urlList) {
      writer.uint32(10).string(v!);
    }
    if (message.uri !== "") {
      writer.uint32(18).string(message.uri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGiftMessage_AssetsModel_ResourceModel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessage_AssetsModel_ResourceModel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.urlList.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGiftMessage_AssetsModel_LokiExtraContent(): WebcastGiftMessage_AssetsModel_LokiExtraContent {
  return {
    giftType: "",
    giftDuration: "0",
    needScreenShot: false,
    ismultiFrame: false,
    viewOverlay: "",
    befViewRenderSize: undefined,
    befViewRenderFPS: 0,
    befViewFitMode: 0,
    modelNames: "",
    requirements: [],
  };
}

export const WebcastGiftMessage_AssetsModel_LokiExtraContentDecoder: MessageFns<WebcastGiftMessage_AssetsModel_LokiExtraContent> = {
  encode(
    message: WebcastGiftMessage_AssetsModel_LokiExtraContent,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.giftType !== "") {
      writer.uint32(10).string(message.giftType);
    }
    if (message.giftDuration !== "0") {
      writer.uint32(16).int64(message.giftDuration);
    }
    if (message.needScreenShot !== false) {
      writer.uint32(24).bool(message.needScreenShot);
    }
    if (message.ismultiFrame !== false) {
      writer.uint32(32).bool(message.ismultiFrame);
    }
    if (message.viewOverlay !== "") {
      writer.uint32(42).string(message.viewOverlay);
    }
    if (message.befViewRenderSize !== undefined) {
      WebcastGiftMessage_AssetsModel_LokiExtraContent_BEFViewRenderSizeDecoder.encode(
        message.befViewRenderSize,
        writer.uint32(50).fork(),
      ).join();
    }
    if (message.befViewRenderFPS !== 0) {
      writer.uint32(56).int32(message.befViewRenderFPS);
    }
    if (message.befViewFitMode !== 0) {
      writer.uint32(64).int32(message.befViewFitMode);
    }
    if (message.modelNames !== "") {
      writer.uint32(74).string(message.modelNames);
    }
    for (const v of message.requirements) {
      writer.uint32(82).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGiftMessage_AssetsModel_LokiExtraContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessage_AssetsModel_LokiExtraContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.giftType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.giftDuration = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.needScreenShot = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.ismultiFrame = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.viewOverlay = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.befViewRenderSize = WebcastGiftMessage_AssetsModel_LokiExtraContent_BEFViewRenderSizeDecoder.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.befViewRenderFPS = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.befViewFitMode = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.modelNames = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.requirements.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGiftMessage_AssetsModel_LokiExtraContent_BEFViewRenderSize(): WebcastGiftMessage_AssetsModel_LokiExtraContent_BEFViewRenderSize {
  return { with: 0, height: 0 };
}

export const WebcastGiftMessage_AssetsModel_LokiExtraContent_BEFViewRenderSizeDecoder: MessageFns<WebcastGiftMessage_AssetsModel_LokiExtraContent_BEFViewRenderSize> = {
  encode(
    message: WebcastGiftMessage_AssetsModel_LokiExtraContent_BEFViewRenderSize,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.with !== 0) {
      writer.uint32(8).int32(message.with);
    }
    if (message.height !== 0) {
      writer.uint32(16).int32(message.height);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): WebcastGiftMessage_AssetsModel_LokiExtraContent_BEFViewRenderSize {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessage_AssetsModel_LokiExtraContent_BEFViewRenderSize();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.with = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.height = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGiftMessage_AssetsModel_VideoResource(): WebcastGiftMessage_AssetsModel_VideoResource {
  return { videoTypeName: "", videoUrl: undefined, videoMd5: "" };
}

export const WebcastGiftMessage_AssetsModel_VideoResourceDecoder: MessageFns<WebcastGiftMessage_AssetsModel_VideoResource> = {
  encode(
    message: WebcastGiftMessage_AssetsModel_VideoResource,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.videoTypeName !== "") {
      writer.uint32(10).string(message.videoTypeName);
    }
    if (message.videoUrl !== undefined) {
      WebcastGiftMessage_AssetsModel_ResourceModelDecoder.encode(message.videoUrl, writer.uint32(18).fork()).join();
    }
    if (message.videoMd5 !== "") {
      writer.uint32(26).string(message.videoMd5);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGiftMessage_AssetsModel_VideoResource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessage_AssetsModel_VideoResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.videoTypeName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.videoUrl = WebcastGiftMessage_AssetsModel_ResourceModelDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.videoMd5 = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGiftMessage_AssetsModel_FaceRecognitionMeta(): WebcastGiftMessage_AssetsModel_FaceRecognitionMeta {
  return { version: "", requirements: [], modelNames: "", sdkExtra: "" };
}

export const WebcastGiftMessage_AssetsModel_FaceRecognitionMetaDecoder: MessageFns<WebcastGiftMessage_AssetsModel_FaceRecognitionMeta> = {
  encode(
    message: WebcastGiftMessage_AssetsModel_FaceRecognitionMeta,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    for (const v of message.requirements) {
      writer.uint32(18).string(v!);
    }
    if (message.modelNames !== "") {
      writer.uint32(26).string(message.modelNames);
    }
    if (message.sdkExtra !== "") {
      writer.uint32(34).string(message.sdkExtra);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGiftMessage_AssetsModel_FaceRecognitionMeta {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessage_AssetsModel_FaceRecognitionMeta();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.requirements.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.modelNames = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sdkExtra = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGiftMessage_LynxGiftExtra(): WebcastGiftMessage_LynxGiftExtra {
  return { id: "0", code: "0", type: "0", params: [], extra: "" };
}

export const WebcastGiftMessage_LynxGiftExtraDecoder: MessageFns<WebcastGiftMessage_LynxGiftExtra> = {
  encode(message: WebcastGiftMessage_LynxGiftExtra, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "0") {
      writer.uint32(8).int64(message.id);
    }
    if (message.code !== "0") {
      writer.uint32(16).int64(message.code);
    }
    if (message.type !== "0") {
      writer.uint32(24).int64(message.type);
    }
    for (const v of message.params) {
      writer.uint32(34).string(v!);
    }
    if (message.extra !== "") {
      writer.uint32(42).string(message.extra);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGiftMessage_LynxGiftExtra {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessage_LynxGiftExtra();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.code = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.type = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.params.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.extra = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGiftMessage_FlyingMicResources(): WebcastGiftMessage_FlyingMicResources {
  return { pathImage: undefined, micImage: undefined, transitionConfigs: [] };
}

export const WebcastGiftMessage_FlyingMicResourcesDecoder: MessageFns<WebcastGiftMessage_FlyingMicResources> = {
  encode(message: WebcastGiftMessage_FlyingMicResources, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pathImage !== undefined) {
      ImageDecoder.encode(message.pathImage, writer.uint32(10).fork()).join();
    }
    if (message.micImage !== undefined) {
      ImageDecoder.encode(message.micImage, writer.uint32(18).fork()).join();
    }
    for (const v of message.transitionConfigs) {
      WebcastGiftMessage_FlyingMicResources_TransitionConfigDecoder.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGiftMessage_FlyingMicResources {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessage_FlyingMicResources();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pathImage = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.micImage = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.transitionConfigs.push(
            WebcastGiftMessage_FlyingMicResources_TransitionConfigDecoder.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGiftMessage_FlyingMicResources_TransitionConfig(): WebcastGiftMessage_FlyingMicResources_TransitionConfig {
  return { configId: "0", resourceImage: undefined };
}

export const WebcastGiftMessage_FlyingMicResources_TransitionConfigDecoder: MessageFns<WebcastGiftMessage_FlyingMicResources_TransitionConfig> = {
  encode(
    message: WebcastGiftMessage_FlyingMicResources_TransitionConfig,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.configId !== "0") {
      writer.uint32(8).int64(message.configId);
    }
    if (message.resourceImage !== undefined) {
      ImageDecoder.encode(message.resourceImage, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGiftMessage_FlyingMicResources_TransitionConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessage_FlyingMicResources_TransitionConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.configId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.resourceImage = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGiftMessage_SponsorshipInfo(): WebcastGiftMessage_SponsorshipInfo {
  return {
    giftId: "0",
    sponsorId: "0",
    lightGiftUp: false,
    unlightedGiftIcon: "",
    giftGalleryDetailPageSchemeUrl: "",
    giftGalleryClickSponsor: false,
    becomeAllSponsored: false,
  };
}

export const WebcastGiftMessage_SponsorshipInfoDecoder: MessageFns<WebcastGiftMessage_SponsorshipInfo> = {
  encode(message: WebcastGiftMessage_SponsorshipInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.giftId !== "0") {
      writer.uint32(8).int64(message.giftId);
    }
    if (message.sponsorId !== "0") {
      writer.uint32(16).int64(message.sponsorId);
    }
    if (message.lightGiftUp !== false) {
      writer.uint32(24).bool(message.lightGiftUp);
    }
    if (message.unlightedGiftIcon !== "") {
      writer.uint32(34).string(message.unlightedGiftIcon);
    }
    if (message.giftGalleryDetailPageSchemeUrl !== "") {
      writer.uint32(42).string(message.giftGalleryDetailPageSchemeUrl);
    }
    if (message.giftGalleryClickSponsor !== false) {
      writer.uint32(48).bool(message.giftGalleryClickSponsor);
    }
    if (message.becomeAllSponsored !== false) {
      writer.uint32(168).bool(message.becomeAllSponsored);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGiftMessage_SponsorshipInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessage_SponsorshipInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.giftId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.sponsorId = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.lightGiftUp = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.unlightedGiftIcon = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.giftGalleryDetailPageSchemeUrl = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.giftGalleryClickSponsor = reader.bool();
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.becomeAllSponsored = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicBattle(): WebcastLinkMicBattle {
  return {
    common: undefined,
    battleId: "0",
    battleSetting: undefined,
    action: 0,
    battleResult: {},
    mBattleDisplayConfig: undefined,
    inviteeGiftPermissionType: 0,
    armies: {},
    anchorInfo: {},
    bubbleText: "",
    supportedActions: [],
    battleCombos: {},
    teamUsers: [],
    inviteeGiftPermissionTypes: [],
    actionByUserId: "0",
    teamBattleResult: [],
    teamArmies: [],
    abtestSettings: [],
    teamMatchCampaign: undefined,
    fuzzyDisplayConfigV2: undefined,
  };
}

export const WebcastLinkMicBattleDecoder: MessageFns<WebcastLinkMicBattle> = {
  encode(message: WebcastLinkMicBattle, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageDataDecoder.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.battleId !== "0") {
      writer.uint32(16).int64(message.battleId);
    }
    if (message.battleSetting !== undefined) {
      BattleSettingDecoder.encode(message.battleSetting, writer.uint32(26).fork()).join();
    }
    if (message.action !== 0) {
      writer.uint32(32).int32(message.action);
    }
    Object.entries(message.battleResult).forEach(([key, value]) => {
      WebcastLinkMicBattle_BattleResultEntryDecoder.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    if (message.mBattleDisplayConfig !== undefined) {
      WebcastLinkMicBattle_BattleDisplayConfigDecoder.encode(message.mBattleDisplayConfig, writer.uint32(50).fork()).join();
    }
    if (message.inviteeGiftPermissionType !== 0) {
      writer.uint32(64).int32(message.inviteeGiftPermissionType);
    }
    Object.entries(message.armies).forEach(([key, value]) => {
      WebcastLinkMicBattle_ArmiesEntryDecoder.encode({ key: key as any, value }, writer.uint32(74).fork()).join();
    });
    Object.entries(message.anchorInfo).forEach(([key, value]) => {
      WebcastLinkMicBattle_AnchorInfoEntryDecoder.encode({ key: key as any, value }, writer.uint32(82).fork()).join();
    });
    if (message.bubbleText !== "") {
      writer.uint32(90).string(message.bubbleText);
    }
    for (const v of message.supportedActions) {
      WebcastLinkMicBattle_SupportedActionsWrapperDecoder.encode(v!, writer.uint32(98).fork()).join();
    }
    Object.entries(message.battleCombos).forEach(([key, value]) => {
      WebcastLinkMicBattle_BattleCombosEntryDecoder.encode({ key: key as any, value }, writer.uint32(106).fork()).join();
    });
    for (const v of message.teamUsers) {
      WebcastLinkMicBattle_TeamUsersInfoDecoder.encode(v!, writer.uint32(114).fork()).join();
    }
    for (const v of message.inviteeGiftPermissionTypes) {
      WebcastLinkMicBattle_BattleInviteeGiftPermissionDecoder.encode(v!, writer.uint32(122).fork()).join();
    }
    if (message.actionByUserId !== "0") {
      writer.uint32(128).int64(message.actionByUserId);
    }
    for (const v of message.teamBattleResult) {
      WebcastLinkMicBattle_BattleTeamResultDecoder.encode(v!, writer.uint32(138).fork()).join();
    }
    for (const v of message.teamArmies) {
      BattleTeamUserArmiesDecoder.encode(v!, writer.uint32(146).fork()).join();
    }
    for (const v of message.abtestSettings) {
      WebcastLinkMicBattle_BattleABTestSettingDecoder.encode(v!, writer.uint32(154).fork()).join();
    }
    if (message.teamMatchCampaign !== undefined) {
      WebcastLinkMicBattle_TeamMatchCampaignDecoder.encode(message.teamMatchCampaign, writer.uint32(162).fork()).join();
    }
    if (message.fuzzyDisplayConfigV2 !== undefined) {
      HighScoreControlCfgDecoder.encode(message.fuzzyDisplayConfigV2, writer.uint32(170).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicBattle {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicBattle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageDataDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.battleId = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.battleSetting = BattleSettingDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.action = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = WebcastLinkMicBattle_BattleResultEntryDecoder.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.battleResult[entry5.key] = entry5.value;
          }
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.mBattleDisplayConfig = WebcastLinkMicBattle_BattleDisplayConfigDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.inviteeGiftPermissionType = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          const entry9 = WebcastLinkMicBattle_ArmiesEntryDecoder.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            message.armies[entry9.key] = entry9.value;
          }
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          const entry10 = WebcastLinkMicBattle_AnchorInfoEntryDecoder.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.anchorInfo[entry10.key] = entry10.value;
          }
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.bubbleText = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.supportedActions.push(WebcastLinkMicBattle_SupportedActionsWrapperDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          const entry13 = WebcastLinkMicBattle_BattleCombosEntryDecoder.decode(reader, reader.uint32());
          if (entry13.value !== undefined) {
            message.battleCombos[entry13.key] = entry13.value;
          }
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.teamUsers.push(WebcastLinkMicBattle_TeamUsersInfoDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.inviteeGiftPermissionTypes.push(
            WebcastLinkMicBattle_BattleInviteeGiftPermissionDecoder.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.actionByUserId = reader.int64().toString();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.teamBattleResult.push(WebcastLinkMicBattle_BattleTeamResultDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.teamArmies.push(BattleTeamUserArmiesDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.abtestSettings.push(WebcastLinkMicBattle_BattleABTestSettingDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.teamMatchCampaign = WebcastLinkMicBattle_TeamMatchCampaignDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.fuzzyDisplayConfigV2 = HighScoreControlCfgDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicBattle_BattleResultEntry(): WebcastLinkMicBattle_BattleResultEntry {
  return { key: "0", value: undefined };
}

export const WebcastLinkMicBattle_BattleResultEntryDecoder: MessageFns<WebcastLinkMicBattle_BattleResultEntry> = {
  encode(message: WebcastLinkMicBattle_BattleResultEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "0") {
      writer.uint32(8).int64(message.key);
    }
    if (message.value !== undefined) {
      WebcastLinkMicBattle_BattleResultDecoder.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicBattle_BattleResultEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicBattle_BattleResultEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = WebcastLinkMicBattle_BattleResultDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicBattle_ArmiesEntry(): WebcastLinkMicBattle_ArmiesEntry {
  return { key: "0", value: undefined };
}

export const WebcastLinkMicBattle_ArmiesEntryDecoder: MessageFns<WebcastLinkMicBattle_ArmiesEntry> = {
  encode(message: WebcastLinkMicBattle_ArmiesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "0") {
      writer.uint32(8).int64(message.key);
    }
    if (message.value !== undefined) {
      BattleUserArmiesDecoder.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicBattle_ArmiesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicBattle_ArmiesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = BattleUserArmiesDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicBattle_AnchorInfoEntry(): WebcastLinkMicBattle_AnchorInfoEntry {
  return { key: "0", value: undefined };
}

export const WebcastLinkMicBattle_AnchorInfoEntryDecoder: MessageFns<WebcastLinkMicBattle_AnchorInfoEntry> = {
  encode(message: WebcastLinkMicBattle_AnchorInfoEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "0") {
      writer.uint32(8).int64(message.key);
    }
    if (message.value !== undefined) {
      WebcastLinkMicBattle_BattleUserInfoDecoder.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicBattle_AnchorInfoEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicBattle_AnchorInfoEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = WebcastLinkMicBattle_BattleUserInfoDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicBattle_BattleCombosEntry(): WebcastLinkMicBattle_BattleCombosEntry {
  return { key: "0", value: undefined };
}

export const WebcastLinkMicBattle_BattleCombosEntryDecoder: MessageFns<WebcastLinkMicBattle_BattleCombosEntry> = {
  encode(message: WebcastLinkMicBattle_BattleCombosEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "0") {
      writer.uint32(8).int64(message.key);
    }
    if (message.value !== undefined) {
      WebcastLinkMicBattle_BattleComboInfoDecoder.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicBattle_BattleCombosEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicBattle_BattleCombosEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = WebcastLinkMicBattle_BattleComboInfoDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicBattle_TeamMatchCampaign(): WebcastLinkMicBattle_TeamMatchCampaign {
  return { bestTeammateRelation: [], startSfxTeamId: [], hasTeamMatchMvpSfx: false };
}

export const WebcastLinkMicBattle_TeamMatchCampaignDecoder: MessageFns<WebcastLinkMicBattle_TeamMatchCampaign> = {
  encode(message: WebcastLinkMicBattle_TeamMatchCampaign, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.bestTeammateRelation) {
      WebcastLinkMicBattle_TeamMatchCampaign_BestTeammateRelationDecoder.encode(v!, writer.uint32(10).fork()).join();
    }
    writer.uint32(18).fork();
    for (const v of message.startSfxTeamId) {
      writer.int64(v);
    }
    writer.join();
    if (message.hasTeamMatchMvpSfx !== false) {
      writer.uint32(24).bool(message.hasTeamMatchMvpSfx);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicBattle_TeamMatchCampaign {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicBattle_TeamMatchCampaign();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bestTeammateRelation.push(
            WebcastLinkMicBattle_TeamMatchCampaign_BestTeammateRelationDecoder.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.startSfxTeamId.push(reader.int64().toString());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.startSfxTeamId.push(reader.int64().toString());
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.hasTeamMatchMvpSfx = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicBattle_TeamMatchCampaign_BestTeammateRelation(): WebcastLinkMicBattle_TeamMatchCampaign_BestTeammateRelation {
  return { userId: "0", bestTeammateId: "0" };
}

export const WebcastLinkMicBattle_TeamMatchCampaign_BestTeammateRelationDecoder: MessageFns<WebcastLinkMicBattle_TeamMatchCampaign_BestTeammateRelation> = {
  encode(
    message: WebcastLinkMicBattle_TeamMatchCampaign_BestTeammateRelation,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.userId !== "0") {
      writer.uint32(8).int64(message.userId);
    }
    if (message.bestTeammateId !== "0") {
      writer.uint32(16).int64(message.bestTeammateId);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): WebcastLinkMicBattle_TeamMatchCampaign_BestTeammateRelation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicBattle_TeamMatchCampaign_BestTeammateRelation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.bestTeammateId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicBattle_BattleTeamResult(): WebcastLinkMicBattle_BattleTeamResult {
  return { teamId: "0", teamUsers: [], result: 0, totalScore: "0" };
}

export const WebcastLinkMicBattle_BattleTeamResultDecoder: MessageFns<WebcastLinkMicBattle_BattleTeamResult> = {
  encode(message: WebcastLinkMicBattle_BattleTeamResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.teamId !== "0") {
      writer.uint32(8).int64(message.teamId);
    }
    for (const v of message.teamUsers) {
      BattleTeamUserDecoder.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.result !== 0) {
      writer.uint32(24).int32(message.result);
    }
    if (message.totalScore !== "0") {
      writer.uint32(32).int64(message.totalScore);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicBattle_BattleTeamResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicBattle_BattleTeamResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.teamId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.teamUsers.push(BattleTeamUserDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.result = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalScore = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicBattle_BattleInviteeGiftPermission(): WebcastLinkMicBattle_BattleInviteeGiftPermission {
  return { userId: "0", giftPermissionType: 0 };
}

export const WebcastLinkMicBattle_BattleInviteeGiftPermissionDecoder: MessageFns<WebcastLinkMicBattle_BattleInviteeGiftPermission> = {
  encode(
    message: WebcastLinkMicBattle_BattleInviteeGiftPermission,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.userId !== "0") {
      writer.uint32(8).int64(message.userId);
    }
    if (message.giftPermissionType !== 0) {
      writer.uint32(16).int32(message.giftPermissionType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicBattle_BattleInviteeGiftPermission {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicBattle_BattleInviteeGiftPermission();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.giftPermissionType = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicBattle_SupportedActionsWrapper(): WebcastLinkMicBattle_SupportedActionsWrapper {
  return { actionType: "0" };
}

export const WebcastLinkMicBattle_SupportedActionsWrapperDecoder: MessageFns<WebcastLinkMicBattle_SupportedActionsWrapper> = {
  encode(
    message: WebcastLinkMicBattle_SupportedActionsWrapper,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.actionType !== "0") {
      writer.uint32(8).int64(message.actionType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicBattle_SupportedActionsWrapper {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicBattle_SupportedActionsWrapper();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.actionType = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicBattle_TeamUsersInfo(): WebcastLinkMicBattle_TeamUsersInfo {
  return { teamId: "0", userIds: [] };
}

export const WebcastLinkMicBattle_TeamUsersInfoDecoder: MessageFns<WebcastLinkMicBattle_TeamUsersInfo> = {
  encode(message: WebcastLinkMicBattle_TeamUsersInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.teamId !== "0") {
      writer.uint32(8).int64(message.teamId);
    }
    writer.uint32(18).fork();
    for (const v of message.userIds) {
      writer.int64(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicBattle_TeamUsersInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicBattle_TeamUsersInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.teamId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.userIds.push(reader.int64().toString());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.userIds.push(reader.int64().toString());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicBattle_BattleComboInfo(): WebcastLinkMicBattle_BattleComboInfo {
  return { userId: "0", comboStatus: "0", comboCount: "0", comboIconUrl: "", comboType: 0, comboRuleGuideSchema: "" };
}

export const WebcastLinkMicBattle_BattleComboInfoDecoder: MessageFns<WebcastLinkMicBattle_BattleComboInfo> = {
  encode(message: WebcastLinkMicBattle_BattleComboInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "0") {
      writer.uint32(8).int64(message.userId);
    }
    if (message.comboStatus !== "0") {
      writer.uint32(16).int64(message.comboStatus);
    }
    if (message.comboCount !== "0") {
      writer.uint32(24).int64(message.comboCount);
    }
    if (message.comboIconUrl !== "") {
      writer.uint32(34).string(message.comboIconUrl);
    }
    if (message.comboType !== 0) {
      writer.uint32(40).int32(message.comboType);
    }
    if (message.comboRuleGuideSchema !== "") {
      writer.uint32(50).string(message.comboRuleGuideSchema);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicBattle_BattleComboInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicBattle_BattleComboInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.comboStatus = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.comboCount = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.comboIconUrl = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.comboType = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.comboRuleGuideSchema = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicBattle_BattleResult(): WebcastLinkMicBattle_BattleResult {
  return { userId: "0", result: 0, score: "0" };
}

export const WebcastLinkMicBattle_BattleResultDecoder: MessageFns<WebcastLinkMicBattle_BattleResult> = {
  encode(message: WebcastLinkMicBattle_BattleResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "0") {
      writer.uint32(8).int64(message.userId);
    }
    if (message.result !== 0) {
      writer.uint32(16).int32(message.result);
    }
    if (message.score !== "0") {
      writer.uint32(24).int64(message.score);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicBattle_BattleResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicBattle_BattleResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.score = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicBattle_BattleDisplayConfig(): WebcastLinkMicBattle_BattleDisplayConfig {
  return { threshold: 0, text: "", diffThreshold: 0, diffText: "", exemptStrategy: undefined };
}

export const WebcastLinkMicBattle_BattleDisplayConfigDecoder: MessageFns<WebcastLinkMicBattle_BattleDisplayConfig> = {
  encode(message: WebcastLinkMicBattle_BattleDisplayConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.threshold !== 0) {
      writer.uint32(8).int32(message.threshold);
    }
    if (message.text !== "") {
      writer.uint32(18).string(message.text);
    }
    if (message.diffThreshold !== 0) {
      writer.uint32(24).int32(message.diffThreshold);
    }
    if (message.diffText !== "") {
      writer.uint32(34).string(message.diffText);
    }
    if (message.exemptStrategy !== undefined) {
      WebcastLinkMicBattle_BattleDisplayConfig_ExemptStrategyDecoder.encode(message.exemptStrategy, writer.uint32(42).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicBattle_BattleDisplayConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicBattle_BattleDisplayConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.threshold = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.text = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.diffThreshold = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.diffText = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.exemptStrategy = WebcastLinkMicBattle_BattleDisplayConfig_ExemptStrategyDecoder.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicBattle_BattleDisplayConfig_ExemptStrategy(): WebcastLinkMicBattle_BattleDisplayConfig_ExemptStrategy {
  return { exemptBothHost: false, exemptAudienceTop: 0 };
}

export const WebcastLinkMicBattle_BattleDisplayConfig_ExemptStrategyDecoder: MessageFns<WebcastLinkMicBattle_BattleDisplayConfig_ExemptStrategy> = {
  encode(
    message: WebcastLinkMicBattle_BattleDisplayConfig_ExemptStrategy,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.exemptBothHost !== false) {
      writer.uint32(8).bool(message.exemptBothHost);
    }
    if (message.exemptAudienceTop !== 0) {
      writer.uint32(16).int32(message.exemptAudienceTop);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicBattle_BattleDisplayConfig_ExemptStrategy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicBattle_BattleDisplayConfig_ExemptStrategy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.exemptBothHost = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.exemptAudienceTop = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicBattle_BattleUserInfo(): WebcastLinkMicBattle_BattleUserInfo {
  return { user: undefined, tags: [] };
}

export const WebcastLinkMicBattle_BattleUserInfoDecoder: MessageFns<WebcastLinkMicBattle_BattleUserInfo> = {
  encode(message: WebcastLinkMicBattle_BattleUserInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      WebcastLinkMicBattle_BattleUserInfo_BattleBaseUserInfoDecoder.encode(message.user, writer.uint32(10).fork()).join();
    }
    for (const v of message.tags) {
      WebcastLinkMicBattle_BattleUserInfo_BattleRivalTagDecoder.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicBattle_BattleUserInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicBattle_BattleUserInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = WebcastLinkMicBattle_BattleUserInfo_BattleBaseUserInfoDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tags.push(WebcastLinkMicBattle_BattleUserInfo_BattleRivalTagDecoder.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicBattle_BattleUserInfo_BattleBaseUserInfo(): WebcastLinkMicBattle_BattleUserInfo_BattleBaseUserInfo {
  return { userId: "0", nickName: "", avatarThumb: undefined, displayId: "" };
}

export const WebcastLinkMicBattle_BattleUserInfo_BattleBaseUserInfoDecoder: MessageFns<WebcastLinkMicBattle_BattleUserInfo_BattleBaseUserInfo> = {
  encode(
    message: WebcastLinkMicBattle_BattleUserInfo_BattleBaseUserInfo,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.userId !== "0") {
      writer.uint32(8).int64(message.userId);
    }
    if (message.nickName !== "") {
      writer.uint32(18).string(message.nickName);
    }
    if (message.avatarThumb !== undefined) {
      ImageDecoder.encode(message.avatarThumb, writer.uint32(26).fork()).join();
    }
    if (message.displayId !== "") {
      writer.uint32(34).string(message.displayId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicBattle_BattleUserInfo_BattleBaseUserInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicBattle_BattleUserInfo_BattleBaseUserInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nickName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.avatarThumb = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.displayId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicBattle_BattleUserInfo_BattleRivalTag(): WebcastLinkMicBattle_BattleUserInfo_BattleRivalTag {
  return { bgImage: undefined, iconImage: undefined, content: "" };
}

export const WebcastLinkMicBattle_BattleUserInfo_BattleRivalTagDecoder: MessageFns<WebcastLinkMicBattle_BattleUserInfo_BattleRivalTag> = {
  encode(
    message: WebcastLinkMicBattle_BattleUserInfo_BattleRivalTag,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.bgImage !== undefined) {
      ImageDecoder.encode(message.bgImage, writer.uint32(10).fork()).join();
    }
    if (message.iconImage !== undefined) {
      ImageDecoder.encode(message.iconImage, writer.uint32(18).fork()).join();
    }
    if (message.content !== "") {
      writer.uint32(26).string(message.content);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicBattle_BattleUserInfo_BattleRivalTag {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicBattle_BattleUserInfo_BattleRivalTag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bgImage = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.iconImage = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.content = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicBattle_BattleABTestSetting(): WebcastLinkMicBattle_BattleABTestSetting {
  return { uid: "0", abTestList: undefined };
}

export const WebcastLinkMicBattle_BattleABTestSettingDecoder: MessageFns<WebcastLinkMicBattle_BattleABTestSetting> = {
  encode(message: WebcastLinkMicBattle_BattleABTestSetting, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uid !== "0") {
      writer.uint32(8).int64(message.uid);
    }
    if (message.abTestList !== undefined) {
      WebcastLinkMicBattle_BattleABTestSetting_BattleABTestListDecoder.encode(message.abTestList, writer.uint32(18).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicBattle_BattleABTestSetting {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicBattle_BattleABTestSetting();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uid = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.abTestList = WebcastLinkMicBattle_BattleABTestSetting_BattleABTestListDecoder.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicBattle_BattleABTestSetting_BattleABTestList(): WebcastLinkMicBattle_BattleABTestSetting_BattleABTestList {
  return { abTestList: [] };
}

export const WebcastLinkMicBattle_BattleABTestSetting_BattleABTestListDecoder: MessageFns<WebcastLinkMicBattle_BattleABTestSetting_BattleABTestList> = {
  encode(
    message: WebcastLinkMicBattle_BattleABTestSetting_BattleABTestList,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.abTestList) {
      WebcastLinkMicBattle_BattleABTestSetting_BattleABTestList_BattleABTestDecoder.encode(v!, writer.uint32(10).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicBattle_BattleABTestSetting_BattleABTestList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicBattle_BattleABTestSetting_BattleABTestList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.abTestList.push(
            WebcastLinkMicBattle_BattleABTestSetting_BattleABTestList_BattleABTestDecoder.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicBattle_BattleABTestSetting_BattleABTestList_BattleABTest(): WebcastLinkMicBattle_BattleABTestSetting_BattleABTestList_BattleABTest {
  return { abTestType: 0, group: 0 };
}

export const WebcastLinkMicBattle_BattleABTestSetting_BattleABTestList_BattleABTestDecoder: MessageFns<WebcastLinkMicBattle_BattleABTestSetting_BattleABTestList_BattleABTest> = {
  encode(
    message: WebcastLinkMicBattle_BattleABTestSetting_BattleABTestList_BattleABTest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.abTestType !== 0) {
      writer.uint32(8).int32(message.abTestType);
    }
    if (message.group !== 0) {
      writer.uint32(16).int32(message.group);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): WebcastLinkMicBattle_BattleABTestSetting_BattleABTestList_BattleABTest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicBattle_BattleABTestSetting_BattleABTestList_BattleABTest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.abTestType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.group = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicArmies(): WebcastLinkMicArmies {
  return {
    common: undefined,
    battleId: "0",
    battleItems: {},
    channelId: "0",
    giftSentTime: "0",
    scoreUpdateTime: "0",
    battleStatus: 0,
    fromUserId: "0",
    giftId: "0",
    giftCount: 0,
    gifIconImage: undefined,
    totalDiamondCount: 0,
    repeatCount: 0,
    teamArmies: [],
    triggerCriticalStrike: false,
    hasTeamMatchMvpSfx: false,
    logId: "",
    battleSettings: undefined,
    fuzzyDisplayConfigV2: undefined,
  };
}

export const WebcastLinkMicArmiesDecoder: MessageFns<WebcastLinkMicArmies> = {
  encode(message: WebcastLinkMicArmies, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageDataDecoder.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.battleId !== "0") {
      writer.uint32(16).int64(message.battleId);
    }
    Object.entries(message.battleItems).forEach(([key, value]) => {
      WebcastLinkMicArmies_BattleItemsEntryDecoder.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.channelId !== "0") {
      writer.uint32(32).int64(message.channelId);
    }
    if (message.giftSentTime !== "0") {
      writer.uint32(40).int64(message.giftSentTime);
    }
    if (message.scoreUpdateTime !== "0") {
      writer.uint32(48).int64(message.scoreUpdateTime);
    }
    if (message.battleStatus !== 0) {
      writer.uint32(56).int32(message.battleStatus);
    }
    if (message.fromUserId !== "0") {
      writer.uint32(64).int64(message.fromUserId);
    }
    if (message.giftId !== "0") {
      writer.uint32(72).int64(message.giftId);
    }
    if (message.giftCount !== 0) {
      writer.uint32(80).int32(message.giftCount);
    }
    if (message.gifIconImage !== undefined) {
      ImageDecoder.encode(message.gifIconImage, writer.uint32(90).fork()).join();
    }
    if (message.totalDiamondCount !== 0) {
      writer.uint32(96).int32(message.totalDiamondCount);
    }
    if (message.repeatCount !== 0) {
      writer.uint32(104).int32(message.repeatCount);
    }
    for (const v of message.teamArmies) {
      BattleTeamUserArmiesDecoder.encode(v!, writer.uint32(114).fork()).join();
    }
    if (message.triggerCriticalStrike !== false) {
      writer.uint32(120).bool(message.triggerCriticalStrike);
    }
    if (message.hasTeamMatchMvpSfx !== false) {
      writer.uint32(128).bool(message.hasTeamMatchMvpSfx);
    }
    if (message.logId !== "") {
      writer.uint32(138).string(message.logId);
    }
    if (message.battleSettings !== undefined) {
      BattleSettingDecoder.encode(message.battleSettings, writer.uint32(146).fork()).join();
    }
    if (message.fuzzyDisplayConfigV2 !== undefined) {
      HighScoreControlCfgDecoder.encode(message.fuzzyDisplayConfigV2, writer.uint32(154).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicArmies {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicArmies();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageDataDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.battleId = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = WebcastLinkMicArmies_BattleItemsEntryDecoder.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.battleItems[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.channelId = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.giftSentTime = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.scoreUpdateTime = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.battleStatus = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.fromUserId = reader.int64().toString();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.giftId = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.giftCount = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.gifIconImage = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.totalDiamondCount = reader.int32();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.repeatCount = reader.int32();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.teamArmies.push(BattleTeamUserArmiesDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.triggerCriticalStrike = reader.bool();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.hasTeamMatchMvpSfx = reader.bool();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.logId = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.battleSettings = BattleSettingDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.fuzzyDisplayConfigV2 = HighScoreControlCfgDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicArmies_BattleItemsEntry(): WebcastLinkMicArmies_BattleItemsEntry {
  return { key: "0", value: undefined };
}

export const WebcastLinkMicArmies_BattleItemsEntryDecoder: MessageFns<WebcastLinkMicArmies_BattleItemsEntry> = {
  encode(message: WebcastLinkMicArmies_BattleItemsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "0") {
      writer.uint32(8).int64(message.key);
    }
    if (message.value !== undefined) {
      BattleUserArmiesDecoder.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicArmies_BattleItemsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicArmies_BattleItemsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = BattleUserArmiesDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicArmiesItems(): WebcastLinkMicArmiesItems {
  return { hostUserId: "0", battleGroups: [] };
}

export const WebcastLinkMicArmiesItemsDecoder: MessageFns<WebcastLinkMicArmiesItems> = {
  encode(message: WebcastLinkMicArmiesItems, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hostUserId !== "0") {
      writer.uint32(8).uint64(message.hostUserId);
    }
    for (const v of message.battleGroups) {
      WebcastLinkMicArmiesGroupDecoder.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicArmiesItems {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicArmiesItems();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.hostUserId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.battleGroups.push(WebcastLinkMicArmiesGroupDecoder.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicArmiesGroup(): WebcastLinkMicArmiesGroup {
  return { users: [], points: 0 };
}

export const WebcastLinkMicArmiesGroupDecoder: MessageFns<WebcastLinkMicArmiesGroup> = {
  encode(message: WebcastLinkMicArmiesGroup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.users) {
      UserDecoder.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.points !== 0) {
      writer.uint32(16).int32(message.points);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicArmiesGroup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicArmiesGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.users.push(UserDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.points = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastSocialMessage(): WebcastSocialMessage {
  return {
    common: undefined,
    user: undefined,
    shareType: "0",
    action: "0",
    shareTarget: "",
    followCount: 0,
    shareDisplayStyle: "0",
    shareCount: 0,
    publicAreaMessageCommon: undefined,
    signature: "",
    signatureVersion: "",
    showDurationMs: "0",
  };
}

export const WebcastSocialMessageDecoder: MessageFns<WebcastSocialMessage> = {
  encode(message: WebcastSocialMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageDataDecoder.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.user !== undefined) {
      UserDecoder.encode(message.user, writer.uint32(18).fork()).join();
    }
    if (message.shareType !== "0") {
      writer.uint32(24).int64(message.shareType);
    }
    if (message.action !== "0") {
      writer.uint32(32).int64(message.action);
    }
    if (message.shareTarget !== "") {
      writer.uint32(42).string(message.shareTarget);
    }
    if (message.followCount !== 0) {
      writer.uint32(48).int32(message.followCount);
    }
    if (message.shareDisplayStyle !== "0") {
      writer.uint32(56).int64(message.shareDisplayStyle);
    }
    if (message.shareCount !== 0) {
      writer.uint32(64).int32(message.shareCount);
    }
    if (message.publicAreaMessageCommon !== undefined) {
      PublicAreaMessageCommonDecoder.encode(message.publicAreaMessageCommon, writer.uint32(74).fork()).join();
    }
    if (message.signature !== "") {
      writer.uint32(82).string(message.signature);
    }
    if (message.signatureVersion !== "") {
      writer.uint32(90).string(message.signatureVersion);
    }
    if (message.showDurationMs !== "0") {
      writer.uint32(96).int64(message.showDurationMs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastSocialMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastSocialMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageDataDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.user = UserDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.shareType = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.action = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.shareTarget = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.followCount = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.shareDisplayStyle = reader.int64().toString();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.shareCount = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.publicAreaMessageCommon = PublicAreaMessageCommonDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.signature = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.signatureVersion = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.showDurationMs = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLikeMessage(): WebcastLikeMessage {
  return {
    common: undefined,
    likeCount: 0,
    totalLikeCount: 0,
    color: 0,
    user: undefined,
    icon: "",
    icons: [],
    specifiedDisplayText: [],
    effectCnt: "0",
    likeEffect: [],
    publicAreaMessageCommon: undefined,
    roomMessageHeatLevel: "0",
  };
}

export const WebcastLikeMessageDecoder: MessageFns<WebcastLikeMessage> = {
  encode(message: WebcastLikeMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageDataDecoder.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.likeCount !== 0) {
      writer.uint32(16).int32(message.likeCount);
    }
    if (message.totalLikeCount !== 0) {
      writer.uint32(24).int32(message.totalLikeCount);
    }
    if (message.color !== 0) {
      writer.uint32(32).int32(message.color);
    }
    if (message.user !== undefined) {
      UserDecoder.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.icon !== "") {
      writer.uint32(50).string(message.icon);
    }
    for (const v of message.icons) {
      ImageDecoder.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.specifiedDisplayText) {
      SpecifiedDisplayTextDecoder.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.effectCnt !== "0") {
      writer.uint32(72).int64(message.effectCnt);
    }
    for (const v of message.likeEffect) {
      LikeEffectDecoder.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.publicAreaMessageCommon !== undefined) {
      PublicAreaMessageCommonDecoder.encode(message.publicAreaMessageCommon, writer.uint32(90).fork()).join();
    }
    if (message.roomMessageHeatLevel !== "0") {
      writer.uint32(96).int64(message.roomMessageHeatLevel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLikeMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLikeMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageDataDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.likeCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.totalLikeCount = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.color = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = UserDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.icon = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.icons.push(ImageDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.specifiedDisplayText.push(SpecifiedDisplayTextDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.effectCnt = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.likeEffect.push(LikeEffectDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.publicAreaMessageCommon = PublicAreaMessageCommonDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.roomMessageHeatLevel = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseSpecifiedDisplayText(): SpecifiedDisplayText {
  return { uid: "0", displayText: undefined };
}

export const SpecifiedDisplayTextDecoder: MessageFns<SpecifiedDisplayText> = {
  encode(message: SpecifiedDisplayText, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uid !== "0") {
      writer.uint32(8).int64(message.uid);
    }
    if (message.displayText !== undefined) {
      TextDecoder.encode(message.displayText, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpecifiedDisplayText {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpecifiedDisplayText();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uid = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.displayText = TextDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLikeEffect(): LikeEffect {
  return { version: "0", effectCnt: "0", effectIntervalMs: "0", level: "0" };
}

export const LikeEffectDecoder: MessageFns<LikeEffect> = {
  encode(message: LikeEffect, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== "0") {
      writer.uint32(8).int64(message.version);
    }
    if (message.effectCnt !== "0") {
      writer.uint32(16).int64(message.effectCnt);
    }
    if (message.effectIntervalMs !== "0") {
      writer.uint32(24).int64(message.effectIntervalMs);
    }
    if (message.level !== "0") {
      writer.uint32(32).int64(message.level);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LikeEffect {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLikeEffect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.version = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.effectCnt = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.effectIntervalMs = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.level = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastQuestionNewMessage(): WebcastQuestionNewMessage {
  return { common: undefined, details: undefined };
}

export const WebcastQuestionNewMessageDecoder: MessageFns<WebcastQuestionNewMessage> = {
  encode(message: WebcastQuestionNewMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageDataDecoder.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.details !== undefined) {
      WebcastQuestionNewMessage_QuestionDecoder.encode(message.details, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastQuestionNewMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastQuestionNewMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageDataDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.details = WebcastQuestionNewMessage_QuestionDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastQuestionNewMessage_Question(): WebcastQuestionNewMessage_Question {
  return {
    questionId: "0",
    questionText: "",
    answerStatus: 0,
    createTime: "0",
    user: undefined,
    createFrom: 0,
    answerFrom: 0,
  };
}

export const WebcastQuestionNewMessage_QuestionDecoder: MessageFns<WebcastQuestionNewMessage_Question> = {
  encode(message: WebcastQuestionNewMessage_Question, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.questionId !== "0") {
      writer.uint32(8).int64(message.questionId);
    }
    if (message.questionText !== "") {
      writer.uint32(18).string(message.questionText);
    }
    if (message.answerStatus !== 0) {
      writer.uint32(24).int32(message.answerStatus);
    }
    if (message.createTime !== "0") {
      writer.uint32(32).int64(message.createTime);
    }
    if (message.user !== undefined) {
      UserDecoder.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.createFrom !== 0) {
      writer.uint32(160).int32(message.createFrom);
    }
    if (message.answerFrom !== 0) {
      writer.uint32(168).int32(message.answerFrom);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastQuestionNewMessage_Question {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastQuestionNewMessage_Question();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.questionId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.questionText = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.answerStatus = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.createTime = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = UserDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.createFrom = reader.int32();
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.answerFrom = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastMessageEventDetails(): WebcastMessageEventDetails {
  return { displayType: "", label: "" };
}

export const WebcastMessageEventDetailsDecoder: MessageFns<WebcastMessageEventDetails> = {
  encode(message: WebcastMessageEventDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayType !== "") {
      writer.uint32(10).string(message.displayType);
    }
    if (message.label !== "") {
      writer.uint32(18).string(message.label);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastMessageEventDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastMessageEventDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.displayType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.label = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLiveIntroMessage(): WebcastLiveIntroMessage {
  return {
    common: undefined,
    roomId: "0",
    auditStatus: 0,
    description: "",
    host: undefined,
    introMode: 0,
    badges: [],
    language: "",
  };
}

export const WebcastLiveIntroMessageDecoder: MessageFns<WebcastLiveIntroMessage> = {
  encode(message: WebcastLiveIntroMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageDataDecoder.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.roomId !== "0") {
      writer.uint32(16).int64(message.roomId);
    }
    if (message.auditStatus !== 0) {
      writer.uint32(24).int32(message.auditStatus);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.host !== undefined) {
      UserDecoder.encode(message.host, writer.uint32(42).fork()).join();
    }
    if (message.introMode !== 0) {
      writer.uint32(48).int32(message.introMode);
    }
    for (const v of message.badges) {
      BadgeStructDecoder.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.language !== "") {
      writer.uint32(66).string(message.language);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLiveIntroMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLiveIntroMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageDataDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.roomId = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.auditStatus = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.host = UserDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.introMode = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.badges.push(BadgeStructDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.language = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseSystemMessage(): SystemMessage {
  return { description: "" };
}

export const SystemMessageDecoder: MessageFns<SystemMessage> = {
  encode(message: SystemMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SystemMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSystemMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRankItem(): RankItem {
  return { colour: "", id: "0" };
}

export const RankItemDecoder: MessageFns<RankItem> = {
  encode(message: RankItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.colour !== "") {
      writer.uint32(10).string(message.colour);
    }
    if (message.id !== "0") {
      writer.uint32(32).uint64(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RankItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRankItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.colour = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.id = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastHourlyRankMessage(): WebcastHourlyRankMessage {
  return { data: undefined, common: undefined, data2: 0 };
}

export const WebcastHourlyRankMessageDecoder: MessageFns<WebcastHourlyRankMessage> = {
  encode(message: WebcastHourlyRankMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data !== undefined) {
      WebcastHourlyRankMessage_RankContainerDecoder.encode(message.data, writer.uint32(18).fork()).join();
    }
    if (message.common !== undefined) {
      CommonMessageDataDecoder.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.data2 !== 0) {
      writer.uint32(24).uint32(message.data2);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastHourlyRankMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastHourlyRankMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = WebcastHourlyRankMessage_RankContainerDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageDataDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.data2 = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastHourlyRankMessage_RankContainer(): WebcastHourlyRankMessage_RankContainer {
  return {
    data1: 0,
    rankingData: undefined,
    data2: 0,
    rankings: undefined,
    rankingData2: undefined,
    data3: 0,
    data4: 0,
  };
}

export const WebcastHourlyRankMessage_RankContainerDecoder: MessageFns<WebcastHourlyRankMessage_RankContainer> = {
  encode(message: WebcastHourlyRankMessage_RankContainer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data1 !== 0) {
      writer.uint32(8).uint32(message.data1);
    }
    if (message.rankingData !== undefined) {
      WebcastHourlyRankMessage_RankContainer_RankingDataDecoder.encode(message.rankingData, writer.uint32(18).fork()).join();
    }
    if (message.data2 !== 0) {
      writer.uint32(24).uint32(message.data2);
    }
    if (message.rankings !== undefined) {
      RankingDecoder.encode(message.rankings, writer.uint32(34).fork()).join();
    }
    if (message.rankingData2 !== undefined) {
      WebcastHourlyRankMessage_RankContainer_RankingData2Decoder.encode(message.rankingData2, writer.uint32(42).fork()).join();
    }
    if (message.data3 !== 0) {
      writer.uint32(48).uint32(message.data3);
    }
    if (message.data4 !== 0) {
      writer.uint32(56).uint32(message.data4);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastHourlyRankMessage_RankContainer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastHourlyRankMessage_RankContainer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.data1 = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rankingData = WebcastHourlyRankMessage_RankContainer_RankingDataDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.data2 = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.rankings = RankingDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.rankingData2 = WebcastHourlyRankMessage_RankContainer_RankingData2Decoder.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.data3 = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.data4 = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastHourlyRankMessage_RankContainer_RankingData(): WebcastHourlyRankMessage_RankContainer_RankingData {
  return { data1: 0, rankdata: undefined, data2: "" };
}

export const WebcastHourlyRankMessage_RankContainer_RankingDataDecoder: MessageFns<WebcastHourlyRankMessage_RankContainer_RankingData> = {
  encode(
    message: WebcastHourlyRankMessage_RankContainer_RankingData,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.data1 !== 0) {
      writer.uint32(8).uint32(message.data1);
    }
    if (message.rankdata !== undefined) {
      RankingDecoder.encode(message.rankdata, writer.uint32(18).fork()).join();
    }
    if (message.data2 !== "") {
      writer.uint32(26).string(message.data2);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastHourlyRankMessage_RankContainer_RankingData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastHourlyRankMessage_RankContainer_RankingData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.data1 = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rankdata = RankingDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data2 = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastHourlyRankMessage_RankContainer_RankingData2(): WebcastHourlyRankMessage_RankContainer_RankingData2 {
  return { data1: 0, data2: 0, rankdata: undefined, data3: "", data4: 0, data5: 0 };
}

export const WebcastHourlyRankMessage_RankContainer_RankingData2Decoder: MessageFns<WebcastHourlyRankMessage_RankContainer_RankingData2> = {
  encode(
    message: WebcastHourlyRankMessage_RankContainer_RankingData2,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.data1 !== 0) {
      writer.uint32(8).uint32(message.data1);
    }
    if (message.data2 !== 0) {
      writer.uint32(16).uint32(message.data2);
    }
    if (message.rankdata !== undefined) {
      RankingDecoder.encode(message.rankdata, writer.uint32(26).fork()).join();
    }
    if (message.data3 !== "") {
      writer.uint32(34).string(message.data3);
    }
    if (message.data4 !== 0) {
      writer.uint32(40).uint32(message.data4);
    }
    if (message.data5 !== 0) {
      writer.uint32(48).uint32(message.data5);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastHourlyRankMessage_RankContainer_RankingData2 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastHourlyRankMessage_RankContainer_RankingData2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.data1 = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.data2 = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rankdata = RankingDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.data3 = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.data4 = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.data5 = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseEmoteDetails(): EmoteDetails {
  return { emoteId: "", image: undefined };
}

export const EmoteDetailsDecoder: MessageFns<EmoteDetails> = {
  encode(message: EmoteDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.emoteId !== "") {
      writer.uint32(10).string(message.emoteId);
    }
    if (message.image !== undefined) {
      EmoteImageDecoder.encode(message.image, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmoteDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmoteDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.emoteId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.image = EmoteImageDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseEmoteImage(): EmoteImage {
  return { imageUrl: "" };
}

export const EmoteImageDecoder: MessageFns<EmoteImage> = {
  encode(message: EmoteImage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.imageUrl !== "") {
      writer.uint32(10).string(message.imageUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmoteImage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmoteImage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.imageUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastEnvelopeMessage(): WebcastEnvelopeMessage {
  return { common: undefined, envelopeInfo: undefined, display: 0 };
}

export const WebcastEnvelopeMessageDecoder: MessageFns<WebcastEnvelopeMessage> = {
  encode(message: WebcastEnvelopeMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageDataDecoder.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.envelopeInfo !== undefined) {
      WebcastEnvelopeMessage_EnvelopeInfoDecoder.encode(message.envelopeInfo, writer.uint32(18).fork()).join();
    }
    if (message.display !== 0) {
      writer.uint32(24).int32(message.display);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastEnvelopeMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastEnvelopeMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageDataDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.envelopeInfo = WebcastEnvelopeMessage_EnvelopeInfoDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.display = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastEnvelopeMessage_EnvelopeInfo(): WebcastEnvelopeMessage_EnvelopeInfo {
  return {
    envelopeId: "",
    businessType: 0,
    envelopeIdc: "",
    sendUserName: "",
    diamondCount: 0,
    peopleCount: 0,
    unpackAt: 0,
    sendUserId: "",
    sendUserAvatar: undefined,
    createAt: "",
    roomId: "",
    followShowStatus: 0,
    skinId: 0,
  };
}

export const WebcastEnvelopeMessage_EnvelopeInfoDecoder: MessageFns<WebcastEnvelopeMessage_EnvelopeInfo> = {
  encode(message: WebcastEnvelopeMessage_EnvelopeInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.envelopeId !== "") {
      writer.uint32(10).string(message.envelopeId);
    }
    if (message.businessType !== 0) {
      writer.uint32(16).int32(message.businessType);
    }
    if (message.envelopeIdc !== "") {
      writer.uint32(26).string(message.envelopeIdc);
    }
    if (message.sendUserName !== "") {
      writer.uint32(34).string(message.sendUserName);
    }
    if (message.diamondCount !== 0) {
      writer.uint32(40).int32(message.diamondCount);
    }
    if (message.peopleCount !== 0) {
      writer.uint32(48).int32(message.peopleCount);
    }
    if (message.unpackAt !== 0) {
      writer.uint32(56).int32(message.unpackAt);
    }
    if (message.sendUserId !== "") {
      writer.uint32(66).string(message.sendUserId);
    }
    if (message.sendUserAvatar !== undefined) {
      ImageDecoder.encode(message.sendUserAvatar, writer.uint32(74).fork()).join();
    }
    if (message.createAt !== "") {
      writer.uint32(82).string(message.createAt);
    }
    if (message.roomId !== "") {
      writer.uint32(90).string(message.roomId);
    }
    if (message.followShowStatus !== 0) {
      writer.uint32(96).int32(message.followShowStatus);
    }
    if (message.skinId !== 0) {
      writer.uint32(104).int32(message.skinId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastEnvelopeMessage_EnvelopeInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastEnvelopeMessage_EnvelopeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.envelopeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.businessType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.envelopeIdc = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sendUserName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.diamondCount = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.peopleCount = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.unpackAt = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.sendUserId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.sendUserAvatar = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.createAt = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.roomId = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.followShowStatus = reader.int32() as any;
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.skinId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseTreasureBoxData(): TreasureBoxData {
  return { coins: 0, canOpen: 0, timestamp: "0" };
}

export const TreasureBoxDataDecoder: MessageFns<TreasureBoxData> = {
  encode(message: TreasureBoxData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.coins !== 0) {
      writer.uint32(40).uint32(message.coins);
    }
    if (message.canOpen !== 0) {
      writer.uint32(48).uint32(message.canOpen);
    }
    if (message.timestamp !== "0") {
      writer.uint32(56).uint64(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TreasureBoxData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTreasureBoxData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.coins = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.canOpen = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.timestamp = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastSubNotifyMessage(): WebcastSubNotifyMessage {
  return {
    common: undefined,
    user: undefined,
    exhibitionType: 0,
    subMonth: "0",
    subscribeType: 0,
    oldSubscribeStatus: 0,
    subscribeMessageType: undefined,
    subscribingStatus: 0,
    isSend: false,
    isCustom: false,
    giftSource: 0,
    messageDisplayStyle: 0,
    publicAreaMessageCommon: undefined,
    packageId: "",
    eventTracking: undefined,
  };
}

export const WebcastSubNotifyMessageDecoder: MessageFns<WebcastSubNotifyMessage> = {
  encode(message: WebcastSubNotifyMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageDataDecoder.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.user !== undefined) {
      UserDecoder.encode(message.user, writer.uint32(18).fork()).join();
    }
    if (message.exhibitionType !== 0) {
      writer.uint32(24).int32(message.exhibitionType);
    }
    if (message.subMonth !== "0") {
      writer.uint32(32).int64(message.subMonth);
    }
    if (message.subscribeType !== 0) {
      writer.uint32(40).int32(message.subscribeType);
    }
    if (message.oldSubscribeStatus !== 0) {
      writer.uint32(48).int32(message.oldSubscribeStatus);
    }
    if (message.subscribeMessageType !== undefined) {
      writer.uint32(56).int32(message.subscribeMessageType);
    }
    if (message.subscribingStatus !== 0) {
      writer.uint32(64).int32(message.subscribingStatus);
    }
    if (message.isSend !== false) {
      writer.uint32(72).bool(message.isSend);
    }
    if (message.isCustom !== false) {
      writer.uint32(80).bool(message.isCustom);
    }
    if (message.giftSource !== 0) {
      writer.uint32(88).int32(message.giftSource);
    }
    if (message.messageDisplayStyle !== 0) {
      writer.uint32(96).int32(message.messageDisplayStyle);
    }
    if (message.publicAreaMessageCommon !== undefined) {
      PublicAreaMessageCommonDecoder.encode(message.publicAreaMessageCommon, writer.uint32(106).fork()).join();
    }
    if (message.packageId !== "") {
      writer.uint32(114).string(message.packageId);
    }
    if (message.eventTracking !== undefined) {
      WebcastSubNotifyMessage_EventTrackingDecoder.encode(message.eventTracking, writer.uint32(122).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastSubNotifyMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastSubNotifyMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageDataDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.user = UserDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.exhibitionType = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.subMonth = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.subscribeType = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.oldSubscribeStatus = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.subscribeMessageType = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.subscribingStatus = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.isSend = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.isCustom = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.giftSource = reader.int32() as any;
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.messageDisplayStyle = reader.int32() as any;
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.publicAreaMessageCommon = PublicAreaMessageCommonDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.packageId = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.eventTracking = WebcastSubNotifyMessage_EventTrackingDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastSubNotifyMessage_EventTracking(): WebcastSubNotifyMessage_EventTracking {
  return { giftSubSenderId: "0", giftSubReceiverId: "0", anchorId: "0", giftSubOrderCreateTime: "0" };
}

export const WebcastSubNotifyMessage_EventTrackingDecoder: MessageFns<WebcastSubNotifyMessage_EventTracking> = {
  encode(message: WebcastSubNotifyMessage_EventTracking, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.giftSubSenderId !== "0") {
      writer.uint32(8).int64(message.giftSubSenderId);
    }
    if (message.giftSubReceiverId !== "0") {
      writer.uint32(16).int64(message.giftSubReceiverId);
    }
    if (message.anchorId !== "0") {
      writer.uint32(24).int64(message.anchorId);
    }
    if (message.giftSubOrderCreateTime !== "0") {
      writer.uint32(32).int64(message.giftSubOrderCreateTime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastSubNotifyMessage_EventTracking {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastSubNotifyMessage_EventTracking();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.giftSubSenderId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.giftSubReceiverId = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.anchorId = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.giftSubOrderCreateTime = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseFollowInfo(): FollowInfo {
  return { followingCount: 0, followerCount: 0, followStatus: 0, pushStatus: 0 };
}

export const FollowInfoDecoder: MessageFns<FollowInfo> = {
  encode(message: FollowInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.followingCount !== 0) {
      writer.uint32(8).int32(message.followingCount);
    }
    if (message.followerCount !== 0) {
      writer.uint32(16).int32(message.followerCount);
    }
    if (message.followStatus !== 0) {
      writer.uint32(24).int32(message.followStatus);
    }
    if (message.pushStatus !== 0) {
      writer.uint32(32).int32(message.pushStatus);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FollowInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFollowInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.followingCount = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.followerCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.followStatus = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.pushStatus = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseProfilePicture(): ProfilePicture {
  return { urls: [] };
}

export const ProfilePictureDecoder: MessageFns<ProfilePicture> = {
  encode(message: ProfilePicture, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.urls) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProfilePicture {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProfilePicture();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.urls.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUserBadgesAttributes(): UserBadgesAttributes {
  return { badgeSceneType: 0, imageBadges: [], badges: [], privilegeLogExtra: undefined };
}

export const UserBadgesAttributesDecoder: MessageFns<UserBadgesAttributes> = {
  encode(message: UserBadgesAttributes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.badgeSceneType !== 0) {
      writer.uint32(24).int32(message.badgeSceneType);
    }
    for (const v of message.imageBadges) {
      UserImageBadgeDecoder.encode(v!, writer.uint32(162).fork()).join();
    }
    for (const v of message.badges) {
      UserBadgeDecoder.encode(v!, writer.uint32(170).fork()).join();
    }
    if (message.privilegeLogExtra !== undefined) {
      PrivilegeLogExtraDecoder.encode(message.privilegeLogExtra, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserBadgesAttributes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserBadgesAttributes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.badgeSceneType = reader.int32();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.imageBadges.push(UserImageBadgeDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.badges.push(UserBadgeDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.privilegeLogExtra = PrivilegeLogExtraDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUserBadge(): UserBadge {
  return { type: "", name: "" };
}

export const UserBadgeDecoder: MessageFns<UserBadge> = {
  encode(message: UserBadge, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserBadge {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserBadge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUserImageBadge(): UserImageBadge {
  return { displayType: 0, image: undefined };
}

export const UserImageBadgeDecoder: MessageFns<UserImageBadge> = {
  encode(message: UserImageBadge, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayType !== 0) {
      writer.uint32(8).int32(message.displayType);
    }
    if (message.image !== undefined) {
      UserImageBadgeImageDecoder.encode(message.image, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserImageBadge {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserImageBadge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.displayType = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.image = UserImageBadgeImageDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUserImageBadgeImage(): UserImageBadgeImage {
  return { url: "" };
}

export const UserImageBadgeImageDecoder: MessageFns<UserImageBadgeImage> = {
  encode(message: UserImageBadgeImage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserImageBadgeImage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserImageBadgeImage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastBarrageMessage(): WebcastBarrageMessage {
  return {
    common: undefined,
    event: undefined,
    msgType: undefined,
    icon: undefined,
    duration: "0",
    backGround: undefined,
    rightIcon: undefined,
    displayConfig: 0,
    galleryGiftId: "0",
    useMarquee: false,
    showType: undefined,
    renderType: undefined,
    leftIconDisplayType: undefined,
    ribbonAnimation: undefined,
    hybridUrl: "",
    schema: "",
    subType: "",
    privilegeLogExtra: undefined,
    content: undefined,
    scene: 0,
    control: undefined,
    rightLabel: undefined,
    badge: undefined,
    animationData: undefined,
    commonBarrageContent: undefined,
    userGradeParam: undefined,
    fansLevelParam: undefined,
    subscribeGiftParam: undefined,
    giftGalleryParams: undefined,
  };
}

export const WebcastBarrageMessageDecoder: MessageFns<WebcastBarrageMessage> = {
  encode(message: WebcastBarrageMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageDataDecoder.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.event !== undefined) {
      WebcastBarrageMessage_BarrageEventDecoder.encode(message.event, writer.uint32(18).fork()).join();
    }
    if (message.msgType !== undefined) {
      writer.uint32(24).int32(message.msgType);
    }
    if (message.icon !== undefined) {
      ImageModelDecoder.encode(message.icon, writer.uint32(34).fork()).join();
    }
    if (message.duration !== "0") {
      writer.uint32(48).int64(message.duration);
    }
    if (message.backGround !== undefined) {
      ImageModelDecoder.encode(message.backGround, writer.uint32(58).fork()).join();
    }
    if (message.rightIcon !== undefined) {
      ImageModelDecoder.encode(message.rightIcon, writer.uint32(66).fork()).join();
    }
    if (message.displayConfig !== 0) {
      writer.uint32(72).int32(message.displayConfig);
    }
    if (message.galleryGiftId !== "0") {
      writer.uint32(80).int64(message.galleryGiftId);
    }
    if (message.useMarquee !== false) {
      writer.uint32(112).bool(message.useMarquee);
    }
    if (message.showType !== undefined) {
      writer.uint32(120).int32(message.showType);
    }
    if (message.renderType !== undefined) {
      writer.uint32(136).int32(message.renderType);
    }
    if (message.leftIconDisplayType !== undefined) {
      writer.uint32(144).int32(message.leftIconDisplayType);
    }
    if (message.ribbonAnimation !== undefined) {
      ImageModelDecoder.encode(message.ribbonAnimation, writer.uint32(154).fork()).join();
    }
    if (message.hybridUrl !== "") {
      writer.uint32(170).string(message.hybridUrl);
    }
    if (message.schema !== "") {
      writer.uint32(178).string(message.schema);
    }
    if (message.subType !== "") {
      writer.uint32(186).string(message.subType);
    }
    if (message.privilegeLogExtra !== undefined) {
      PrivilegeLogExtraDecoder.encode(message.privilegeLogExtra, writer.uint32(826).fork()).join();
    }
    if (message.content !== undefined) {
      TextDecoder.encode(message.content, writer.uint32(42).fork()).join();
    }
    if (message.scene !== 0) {
      writer.uint32(88).int32(message.scene);
    }
    if (message.control !== undefined) {
      WebcastBarrageMessage_DisplayControlDecoder.encode(message.control, writer.uint32(98).fork()).join();
    }
    if (message.rightLabel !== undefined) {
      WebcastBarrageMessage_RightLabelDecoder.encode(message.rightLabel, writer.uint32(106).fork()).join();
    }
    if (message.badge !== undefined) {
      BadgeStructDecoder.encode(message.badge, writer.uint32(130).fork()).join();
    }
    if (message.animationData !== undefined) {
      WebcastBarrageMessage_AnimationDataDecoder.encode(message.animationData, writer.uint32(162).fork()).join();
    }
    if (message.commonBarrageContent !== undefined) {
      TextDecoder.encode(message.commonBarrageContent, writer.uint32(194).fork()).join();
    }
    if (message.userGradeParam !== undefined) {
      WebcastBarrageMessage_BarrageTypeUserGradeParamDecoder.encode(message.userGradeParam, writer.uint32(802).fork()).join();
    }
    if (message.fansLevelParam !== undefined) {
      WebcastBarrageMessage_BarrageTypeFansLevelParamDecoder.encode(message.fansLevelParam, writer.uint32(810).fork()).join();
    }
    if (message.subscribeGiftParam !== undefined) {
      WebcastBarrageMessage_BarrageTypeSubscribeGiftParamDecoder.encode(message.subscribeGiftParam, writer.uint32(818).fork())
        .join();
    }
    if (message.giftGalleryParams !== undefined) {
      WebcastBarrageMessage_BarrageTypeGiftGalleryParamDecoder.encode(message.giftGalleryParams, writer.uint32(834).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastBarrageMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastBarrageMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageDataDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.event = WebcastBarrageMessage_BarrageEventDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.msgType = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.icon = ImageModelDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.duration = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.backGround = ImageModelDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.rightIcon = ImageModelDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.displayConfig = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.galleryGiftId = reader.int64().toString();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.useMarquee = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.showType = reader.int32() as any;
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.renderType = reader.int32() as any;
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.leftIconDisplayType = reader.int32() as any;
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.ribbonAnimation = ImageModelDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.hybridUrl = reader.string();
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.schema = reader.string();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.subType = reader.string();
          continue;
        }
        case 103: {
          if (tag !== 826) {
            break;
          }

          message.privilegeLogExtra = PrivilegeLogExtraDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.content = TextDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.scene = reader.int32() as any;
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.control = WebcastBarrageMessage_DisplayControlDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.rightLabel = WebcastBarrageMessage_RightLabelDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.badge = BadgeStructDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.animationData = WebcastBarrageMessage_AnimationDataDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.commonBarrageContent = TextDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 100: {
          if (tag !== 802) {
            break;
          }

          message.userGradeParam = WebcastBarrageMessage_BarrageTypeUserGradeParamDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 101: {
          if (tag !== 810) {
            break;
          }

          message.fansLevelParam = WebcastBarrageMessage_BarrageTypeFansLevelParamDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 102: {
          if (tag !== 818) {
            break;
          }

          message.subscribeGiftParam = WebcastBarrageMessage_BarrageTypeSubscribeGiftParamDecoder.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 104: {
          if (tag !== 834) {
            break;
          }

          message.giftGalleryParams = WebcastBarrageMessage_BarrageTypeGiftGalleryParamDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastBarrageMessage_BarrageEvent(): WebcastBarrageMessage_BarrageEvent {
  return { eventName: "", params: {} };
}

export const WebcastBarrageMessage_BarrageEventDecoder: MessageFns<WebcastBarrageMessage_BarrageEvent> = {
  encode(message: WebcastBarrageMessage_BarrageEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventName !== "") {
      writer.uint32(10).string(message.eventName);
    }
    Object.entries(message.params).forEach(([key, value]) => {
      WebcastBarrageMessage_BarrageEvent_ParamsEntryDecoder.encode({ key: key as any, value }, writer.uint32(18).fork())
        .join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastBarrageMessage_BarrageEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastBarrageMessage_BarrageEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.eventName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = WebcastBarrageMessage_BarrageEvent_ParamsEntryDecoder.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.params[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastBarrageMessage_BarrageEvent_ParamsEntry(): WebcastBarrageMessage_BarrageEvent_ParamsEntry {
  return { key: "", value: "" };
}

export const WebcastBarrageMessage_BarrageEvent_ParamsEntryDecoder: MessageFns<WebcastBarrageMessage_BarrageEvent_ParamsEntry> = {
  encode(
    message: WebcastBarrageMessage_BarrageEvent_ParamsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastBarrageMessage_BarrageEvent_ParamsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastBarrageMessage_BarrageEvent_ParamsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastBarrageMessage_BarrageTypeUserGradeParam(): WebcastBarrageMessage_BarrageTypeUserGradeParam {
  return { currentGrade: 0, displayConfig: 0, userId: "", user: undefined };
}

export const WebcastBarrageMessage_BarrageTypeUserGradeParamDecoder: MessageFns<WebcastBarrageMessage_BarrageTypeUserGradeParam> = {
  encode(
    message: WebcastBarrageMessage_BarrageTypeUserGradeParam,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.currentGrade !== 0) {
      writer.uint32(8).int32(message.currentGrade);
    }
    if (message.displayConfig !== 0) {
      writer.uint32(16).int32(message.displayConfig);
    }
    if (message.userId !== "") {
      writer.uint32(26).string(message.userId);
    }
    if (message.user !== undefined) {
      UserDecoder.encode(message.user, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastBarrageMessage_BarrageTypeUserGradeParam {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastBarrageMessage_BarrageTypeUserGradeParam();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.currentGrade = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.displayConfig = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.user = UserDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastBarrageMessage_BarrageTypeFansLevelParam(): WebcastBarrageMessage_BarrageTypeFansLevelParam {
  return { currentGrade: 0, displayConfig: 0, user: undefined };
}

export const WebcastBarrageMessage_BarrageTypeFansLevelParamDecoder: MessageFns<WebcastBarrageMessage_BarrageTypeFansLevelParam> = {
  encode(
    message: WebcastBarrageMessage_BarrageTypeFansLevelParam,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.currentGrade !== 0) {
      writer.uint32(8).int32(message.currentGrade);
    }
    if (message.displayConfig !== 0) {
      writer.uint32(16).int32(message.displayConfig);
    }
    if (message.user !== undefined) {
      UserDecoder.encode(message.user, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastBarrageMessage_BarrageTypeFansLevelParam {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastBarrageMessage_BarrageTypeFansLevelParam();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.currentGrade = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.displayConfig = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.user = UserDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastBarrageMessage_BarrageTypeSubscribeGiftParam(): WebcastBarrageMessage_BarrageTypeSubscribeGiftParam {
  return { giftSubCount: "0", showGiftSubCount: false };
}

export const WebcastBarrageMessage_BarrageTypeSubscribeGiftParamDecoder: MessageFns<WebcastBarrageMessage_BarrageTypeSubscribeGiftParam> = {
  encode(
    message: WebcastBarrageMessage_BarrageTypeSubscribeGiftParam,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.giftSubCount !== "0") {
      writer.uint32(8).int64(message.giftSubCount);
    }
    if (message.showGiftSubCount !== false) {
      writer.uint32(16).bool(message.showGiftSubCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastBarrageMessage_BarrageTypeSubscribeGiftParam {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastBarrageMessage_BarrageTypeSubscribeGiftParam();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.giftSubCount = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.showGiftSubCount = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastBarrageMessage_AnimationData(): WebcastBarrageMessage_AnimationData {
  return { geckoChannelName: "", fileName: "", height: "0", width: "0", rightOffset: "0" };
}

export const WebcastBarrageMessage_AnimationDataDecoder: MessageFns<WebcastBarrageMessage_AnimationData> = {
  encode(message: WebcastBarrageMessage_AnimationData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.geckoChannelName !== "") {
      writer.uint32(10).string(message.geckoChannelName);
    }
    if (message.fileName !== "") {
      writer.uint32(18).string(message.fileName);
    }
    if (message.height !== "0") {
      writer.uint32(24).int64(message.height);
    }
    if (message.width !== "0") {
      writer.uint32(32).int64(message.width);
    }
    if (message.rightOffset !== "0") {
      writer.uint32(40).int64(message.rightOffset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastBarrageMessage_AnimationData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastBarrageMessage_AnimationData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.geckoChannelName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fileName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.height = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.width = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.rightOffset = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastBarrageMessage_BarrageTypeGiftGalleryParam(): WebcastBarrageMessage_BarrageTypeGiftGalleryParam {
  return { fromUserId: "0", toUserId: "0" };
}

export const WebcastBarrageMessage_BarrageTypeGiftGalleryParamDecoder: MessageFns<WebcastBarrageMessage_BarrageTypeGiftGalleryParam> = {
  encode(
    message: WebcastBarrageMessage_BarrageTypeGiftGalleryParam,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.fromUserId !== "0") {
      writer.uint32(8).int64(message.fromUserId);
    }
    if (message.toUserId !== "0") {
      writer.uint32(16).int64(message.toUserId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastBarrageMessage_BarrageTypeGiftGalleryParam {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastBarrageMessage_BarrageTypeGiftGalleryParam();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.fromUserId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.toUserId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastBarrageMessage_DisplayControl(): WebcastBarrageMessage_DisplayControl {
  return { priority: 0, duration: "0", targetGroupShowRst: {}, horizontalTriggerType: 0 };
}

export const WebcastBarrageMessage_DisplayControlDecoder: MessageFns<WebcastBarrageMessage_DisplayControl> = {
  encode(message: WebcastBarrageMessage_DisplayControl, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.priority !== 0) {
      writer.uint32(8).int32(message.priority);
    }
    if (message.duration !== "0") {
      writer.uint32(16).int64(message.duration);
    }
    Object.entries(message.targetGroupShowRst).forEach(([key, value]) => {
      WebcastBarrageMessage_DisplayControl_TargetGroupShowRstEntryDecoder.encode(
        { key: key as any, value },
        writer.uint32(26).fork(),
      ).join();
    });
    if (message.horizontalTriggerType !== 0) {
      writer.uint32(32).int32(message.horizontalTriggerType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastBarrageMessage_DisplayControl {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastBarrageMessage_DisplayControl();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.priority = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.duration = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = WebcastBarrageMessage_DisplayControl_TargetGroupShowRstEntryDecoder.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.targetGroupShowRst[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.horizontalTriggerType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastBarrageMessage_DisplayControl_TargetGroupShowRstEntry(): WebcastBarrageMessage_DisplayControl_TargetGroupShowRstEntry {
  return { key: 0, value: undefined };
}

export const WebcastBarrageMessage_DisplayControl_TargetGroupShowRstEntryDecoder: MessageFns<WebcastBarrageMessage_DisplayControl_TargetGroupShowRstEntry> = {
  encode(
    message: WebcastBarrageMessage_DisplayControl_TargetGroupShowRstEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== 0) {
      writer.uint32(8).int32(message.key);
    }
    if (message.value !== undefined) {
      WebcastBarrageMessage_DisplayControl_ShowResultDecoder.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): WebcastBarrageMessage_DisplayControl_TargetGroupShowRstEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastBarrageMessage_DisplayControl_TargetGroupShowRstEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = WebcastBarrageMessage_DisplayControl_ShowResultDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastBarrageMessage_DisplayControl_ShowResult(): WebcastBarrageMessage_DisplayControl_ShowResult {
  return { banned: false };
}

export const WebcastBarrageMessage_DisplayControl_ShowResultDecoder: MessageFns<WebcastBarrageMessage_DisplayControl_ShowResult> = {
  encode(
    message: WebcastBarrageMessage_DisplayControl_ShowResult,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.banned !== false) {
      writer.uint32(8).bool(message.banned);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastBarrageMessage_DisplayControl_ShowResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastBarrageMessage_DisplayControl_ShowResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.banned = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastBarrageMessage_RightLabel(): WebcastBarrageMessage_RightLabel {
  return { backgroundColor: "", content: undefined, height: "0" };
}

export const WebcastBarrageMessage_RightLabelDecoder: MessageFns<WebcastBarrageMessage_RightLabel> = {
  encode(message: WebcastBarrageMessage_RightLabel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.backgroundColor !== "") {
      writer.uint32(10).string(message.backgroundColor);
    }
    if (message.content !== undefined) {
      TextDecoder.encode(message.content, writer.uint32(18).fork()).join();
    }
    if (message.height !== "0") {
      writer.uint32(24).int64(message.height);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastBarrageMessage_RightLabel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastBarrageMessage_RightLabel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.backgroundColor = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.content = TextDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.height = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseProtoMessageFetchResult(): ProtoMessageFetchResult {
  return {
    messages: [],
    cursor: "",
    fetchInterval: "0",
    now: "0",
    internalExt: "",
    fetchType: 0,
    wsParams: {},
    heartBeatDuration: 0,
    needsAck: false,
    wsUrl: "",
    isFirst: false,
    historyCommentCursor: "",
    historyNoMore: false,
  };
}

export const ProtoMessageFetchResultDecoder: MessageFns<ProtoMessageFetchResult> = {
  encode(message: ProtoMessageFetchResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.messages) {
      BaseProtoMessageDecoder.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.cursor !== "") {
      writer.uint32(18).string(message.cursor);
    }
    if (message.fetchInterval !== "0") {
      writer.uint32(24).int64(message.fetchInterval);
    }
    if (message.now !== "0") {
      writer.uint32(32).int64(message.now);
    }
    if (message.internalExt !== "") {
      writer.uint32(42).string(message.internalExt);
    }
    if (message.fetchType !== 0) {
      writer.uint32(48).int32(message.fetchType);
    }
    Object.entries(message.wsParams).forEach(([key, value]) => {
      ProtoMessageFetchResult_WsParamsEntryDecoder.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    if (message.heartBeatDuration !== 0) {
      writer.uint32(64).int32(message.heartBeatDuration);
    }
    if (message.needsAck !== false) {
      writer.uint32(72).bool(message.needsAck);
    }
    if (message.wsUrl !== "") {
      writer.uint32(82).string(message.wsUrl);
    }
    if (message.isFirst !== false) {
      writer.uint32(88).bool(message.isFirst);
    }
    if (message.historyCommentCursor !== "") {
      writer.uint32(98).string(message.historyCommentCursor);
    }
    if (message.historyNoMore !== false) {
      writer.uint32(104).bool(message.historyNoMore);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoMessageFetchResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoMessageFetchResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.messages.push(BaseProtoMessageDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cursor = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.fetchInterval = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.now = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.internalExt = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.fetchType = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          const entry7 = ProtoMessageFetchResult_WsParamsEntryDecoder.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.wsParams[entry7.key] = entry7.value;
          }
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.heartBeatDuration = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.needsAck = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.wsUrl = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.isFirst = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.historyCommentCursor = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.historyNoMore = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseProtoMessageFetchResult_WsParamsEntry(): ProtoMessageFetchResult_WsParamsEntry {
  return { key: "", value: "" };
}

export const ProtoMessageFetchResult_WsParamsEntryDecoder: MessageFns<ProtoMessageFetchResult_WsParamsEntry> = {
  encode(message: ProtoMessageFetchResult_WsParamsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoMessageFetchResult_WsParamsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoMessageFetchResult_WsParamsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBaseProtoMessage(): BaseProtoMessage {
  return { type: "", payload: new Uint8Array(0), msgId: "0", msgType: 0, offset: "0", isHistory: false };
}

export const BaseProtoMessageDecoder: MessageFns<BaseProtoMessage> = {
  encode(message: BaseProtoMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.payload.length !== 0) {
      writer.uint32(18).bytes(message.payload);
    }
    if (message.msgId !== "0") {
      writer.uint32(24).int64(message.msgId);
    }
    if (message.msgType !== 0) {
      writer.uint32(32).int32(message.msgType);
    }
    if (message.offset !== "0") {
      writer.uint32(40).int64(message.offset);
    }
    if (message.isHistory !== false) {
      writer.uint32(48).bool(message.isHistory);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BaseProtoMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBaseProtoMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.payload = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.msgId = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.msgType = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.offset = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isHistory = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastRoomMessage(): WebcastRoomMessage {
  return {
    common: undefined,
    content: "",
    supportLandscape: false,
    source: "0",
    icon: undefined,
    scene: 0,
    isWelcome: false,
    publicAreaCommon: undefined,
    showDurationMs: "0",
    subScene: "",
  };
}

export const WebcastRoomMessageDecoder: MessageFns<WebcastRoomMessage> = {
  encode(message: WebcastRoomMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageDataDecoder.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.content !== "") {
      writer.uint32(18).string(message.content);
    }
    if (message.supportLandscape !== false) {
      writer.uint32(24).bool(message.supportLandscape);
    }
    if (message.source !== "0") {
      writer.uint32(32).int64(message.source);
    }
    if (message.icon !== undefined) {
      ImageDecoder.encode(message.icon, writer.uint32(42).fork()).join();
    }
    if (message.scene !== 0) {
      writer.uint32(48).int32(message.scene);
    }
    if (message.isWelcome !== false) {
      writer.uint32(56).bool(message.isWelcome);
    }
    if (message.publicAreaCommon !== undefined) {
      PublicAreaMessageCommonDecoder.encode(message.publicAreaCommon, writer.uint32(66).fork()).join();
    }
    if (message.showDurationMs !== "0") {
      writer.uint32(72).int64(message.showDurationMs);
    }
    if (message.subScene !== "") {
      writer.uint32(82).string(message.subScene);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastRoomMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastRoomMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageDataDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.content = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.supportLandscape = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.source = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.icon = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.scene = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.isWelcome = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.publicAreaCommon = PublicAreaMessageCommonDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.showDurationMs = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.subScene = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastCaptionMessage(): WebcastCaptionMessage {
  return {
    common: undefined,
    timestampMs: "0",
    durationMs: "0",
    content: [],
    sentenceId: "0",
    sequenceId: "0",
    definite: false,
  };
}

export const WebcastCaptionMessageDecoder: MessageFns<WebcastCaptionMessage> = {
  encode(message: WebcastCaptionMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageDataDecoder.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.timestampMs !== "0") {
      writer.uint32(16).int64(message.timestampMs);
    }
    if (message.durationMs !== "0") {
      writer.uint32(24).int64(message.durationMs);
    }
    for (const v of message.content) {
      WebcastCaptionMessage_CaptionContentDecoder.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.sentenceId !== "0") {
      writer.uint32(40).int64(message.sentenceId);
    }
    if (message.sequenceId !== "0") {
      writer.uint32(48).int64(message.sequenceId);
    }
    if (message.definite !== false) {
      writer.uint32(56).bool(message.definite);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastCaptionMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastCaptionMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageDataDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.timestampMs = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.durationMs = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.content.push(WebcastCaptionMessage_CaptionContentDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.sentenceId = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.sequenceId = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.definite = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastCaptionMessage_CaptionContent(): WebcastCaptionMessage_CaptionContent {
  return { lang: "", content: "" };
}

export const WebcastCaptionMessage_CaptionContentDecoder: MessageFns<WebcastCaptionMessage_CaptionContent> = {
  encode(message: WebcastCaptionMessage_CaptionContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lang !== "") {
      writer.uint32(10).string(message.lang);
    }
    if (message.content !== "") {
      writer.uint32(18).string(message.content);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastCaptionMessage_CaptionContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastCaptionMessage_CaptionContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.lang = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.content = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastControlMessage(): WebcastControlMessage {
  return {
    common: undefined,
    action: 0,
    tips: "",
    extra: undefined,
    perceptionDialog: undefined,
    perceptionAudienceText: undefined,
    punishInfo: undefined,
    floatText: undefined,
    floatStyle: 0,
  };
}

export const WebcastControlMessageDecoder: MessageFns<WebcastControlMessage> = {
  encode(message: WebcastControlMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageDataDecoder.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.action !== 0) {
      writer.uint32(16).int32(message.action);
    }
    if (message.tips !== "") {
      writer.uint32(26).string(message.tips);
    }
    if (message.extra !== undefined) {
      WebcastControlMessage_ExtraDecoder.encode(message.extra, writer.uint32(34).fork()).join();
    }
    if (message.perceptionDialog !== undefined) {
      WebcastControlMessage_PerceptionDialogInfoDecoder.encode(message.perceptionDialog, writer.uint32(42).fork()).join();
    }
    if (message.perceptionAudienceText !== undefined) {
      TextDecoder.encode(message.perceptionAudienceText, writer.uint32(50).fork()).join();
    }
    if (message.punishInfo !== undefined) {
      PunishEventInfoDecoder.encode(message.punishInfo, writer.uint32(58).fork()).join();
    }
    if (message.floatText !== undefined) {
      TextDecoder.encode(message.floatText, writer.uint32(66).fork()).join();
    }
    if (message.floatStyle !== 0) {
      writer.uint32(72).int32(message.floatStyle);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastControlMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastControlMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageDataDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.action = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tips = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.extra = WebcastControlMessage_ExtraDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.perceptionDialog = WebcastControlMessage_PerceptionDialogInfoDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.perceptionAudienceText = TextDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.punishInfo = PunishEventInfoDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.floatText = TextDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.floatStyle = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastControlMessage_Extra(): WebcastControlMessage_Extra {
  return {
    banInfoUrl: "",
    reasonNo: "0",
    title: undefined,
    violationReason: undefined,
    content: undefined,
    gotItButton: undefined,
    banDetailButton: undefined,
    source: "",
  };
}

export const WebcastControlMessage_ExtraDecoder: MessageFns<WebcastControlMessage_Extra> = {
  encode(message: WebcastControlMessage_Extra, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.banInfoUrl !== "") {
      writer.uint32(10).string(message.banInfoUrl);
    }
    if (message.reasonNo !== "0") {
      writer.uint32(16).int64(message.reasonNo);
    }
    if (message.title !== undefined) {
      TextDecoder.encode(message.title, writer.uint32(26).fork()).join();
    }
    if (message.violationReason !== undefined) {
      TextDecoder.encode(message.violationReason, writer.uint32(34).fork()).join();
    }
    if (message.content !== undefined) {
      TextDecoder.encode(message.content, writer.uint32(42).fork()).join();
    }
    if (message.gotItButton !== undefined) {
      TextDecoder.encode(message.gotItButton, writer.uint32(50).fork()).join();
    }
    if (message.banDetailButton !== undefined) {
      TextDecoder.encode(message.banDetailButton, writer.uint32(58).fork()).join();
    }
    if (message.source !== "") {
      writer.uint32(66).string(message.source);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastControlMessage_Extra {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastControlMessage_Extra();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.banInfoUrl = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.reasonNo = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.title = TextDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.violationReason = TextDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.content = TextDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.gotItButton = TextDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.banDetailButton = TextDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.source = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastControlMessage_PerceptionDialogInfo(): WebcastControlMessage_PerceptionDialogInfo {
  return {
    iconType: 0,
    title: undefined,
    subTitle: undefined,
    adviceActionText: undefined,
    defaultActionText: undefined,
    violationDetailUrl: "",
    scene: 0,
    targetUserId: "0",
    targetRoomId: "0",
    countDownTime: "0",
    showFeedback: false,
    feedbackOptions: [],
    policyTip: "0",
    appealPopup: 0,
  };
}

export const WebcastControlMessage_PerceptionDialogInfoDecoder: MessageFns<WebcastControlMessage_PerceptionDialogInfo> = {
  encode(message: WebcastControlMessage_PerceptionDialogInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.iconType !== 0) {
      writer.uint32(8).int32(message.iconType);
    }
    if (message.title !== undefined) {
      TextDecoder.encode(message.title, writer.uint32(18).fork()).join();
    }
    if (message.subTitle !== undefined) {
      TextDecoder.encode(message.subTitle, writer.uint32(26).fork()).join();
    }
    if (message.adviceActionText !== undefined) {
      TextDecoder.encode(message.adviceActionText, writer.uint32(34).fork()).join();
    }
    if (message.defaultActionText !== undefined) {
      TextDecoder.encode(message.defaultActionText, writer.uint32(42).fork()).join();
    }
    if (message.violationDetailUrl !== "") {
      writer.uint32(50).string(message.violationDetailUrl);
    }
    if (message.scene !== 0) {
      writer.uint32(56).int32(message.scene);
    }
    if (message.targetUserId !== "0") {
      writer.uint32(64).int64(message.targetUserId);
    }
    if (message.targetRoomId !== "0") {
      writer.uint32(72).int64(message.targetRoomId);
    }
    if (message.countDownTime !== "0") {
      writer.uint32(80).int64(message.countDownTime);
    }
    if (message.showFeedback !== false) {
      writer.uint32(88).bool(message.showFeedback);
    }
    for (const v of message.feedbackOptions) {
      WebcastControlMessage_PerceptionDialogInfo_PerceptionFeedbackOptionDecoder.encode(v!, writer.uint32(98).fork()).join();
    }
    if (message.policyTip !== "0") {
      writer.uint32(104).int64(message.policyTip);
    }
    if (message.appealPopup !== 0) {
      writer.uint32(112).int32(message.appealPopup);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastControlMessage_PerceptionDialogInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastControlMessage_PerceptionDialogInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.iconType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = TextDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.subTitle = TextDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.adviceActionText = TextDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.defaultActionText = TextDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.violationDetailUrl = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.scene = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.targetUserId = reader.int64().toString();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.targetRoomId = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.countDownTime = reader.int64().toString();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.showFeedback = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.feedbackOptions.push(
            WebcastControlMessage_PerceptionDialogInfo_PerceptionFeedbackOptionDecoder.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.policyTip = reader.int64().toString();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.appealPopup = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastControlMessage_PerceptionDialogInfo_PerceptionFeedbackOption(): WebcastControlMessage_PerceptionDialogInfo_PerceptionFeedbackOption {
  return { id: "0", contentKey: "" };
}

export const WebcastControlMessage_PerceptionDialogInfo_PerceptionFeedbackOptionDecoder: MessageFns<WebcastControlMessage_PerceptionDialogInfo_PerceptionFeedbackOption> = {
  encode(
    message: WebcastControlMessage_PerceptionDialogInfo_PerceptionFeedbackOption,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== "0") {
      writer.uint32(8).int64(message.id);
    }
    if (message.contentKey !== "") {
      writer.uint32(18).string(message.contentKey);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): WebcastControlMessage_PerceptionDialogInfo_PerceptionFeedbackOption {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastControlMessage_PerceptionDialogInfo_PerceptionFeedbackOption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contentKey = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGoalUpdateMessage(): WebcastGoalUpdateMessage {
  return {
    common: undefined,
    indicator: undefined,
    goal: undefined,
    contributorId: "0",
    contributorAvatar: undefined,
    contributorDisplayId: "",
    contributeSubgoal: undefined,
    contributeCount: "0",
    contributeScore: "0",
    giftRepeatCount: "0",
    contributorIdStr: "",
    pin: false,
    unpin: false,
    pinInfo: undefined,
    updateSource: 0,
    goalExtra: "",
  };
}

export const WebcastGoalUpdateMessageDecoder: MessageFns<WebcastGoalUpdateMessage> = {
  encode(message: WebcastGoalUpdateMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageDataDecoder.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.indicator !== undefined) {
      LiveStreamGoalIndicatorDecoder.encode(message.indicator, writer.uint32(18).fork()).join();
    }
    if (message.goal !== undefined) {
      LiveStreamGoalDecoder.encode(message.goal, writer.uint32(26).fork()).join();
    }
    if (message.contributorId !== "0") {
      writer.uint32(32).int64(message.contributorId);
    }
    if (message.contributorAvatar !== undefined) {
      ImageDecoder.encode(message.contributorAvatar, writer.uint32(42).fork()).join();
    }
    if (message.contributorDisplayId !== "") {
      writer.uint32(50).string(message.contributorDisplayId);
    }
    if (message.contributeSubgoal !== undefined) {
      WebcastGoalUpdateMessage_LiveStreamSubGoalDecoder.encode(message.contributeSubgoal, writer.uint32(58).fork()).join();
    }
    if (message.contributeCount !== "0") {
      writer.uint32(72).int64(message.contributeCount);
    }
    if (message.contributeScore !== "0") {
      writer.uint32(80).int64(message.contributeScore);
    }
    if (message.giftRepeatCount !== "0") {
      writer.uint32(88).int64(message.giftRepeatCount);
    }
    if (message.contributorIdStr !== "") {
      writer.uint32(98).string(message.contributorIdStr);
    }
    if (message.pin !== false) {
      writer.uint32(104).bool(message.pin);
    }
    if (message.unpin !== false) {
      writer.uint32(112).bool(message.unpin);
    }
    if (message.pinInfo !== undefined) {
      WebcastGoalUpdateMessage_GoalPinInfoDecoder.encode(message.pinInfo, writer.uint32(122).fork()).join();
    }
    if (message.updateSource !== 0) {
      writer.uint32(128).int32(message.updateSource);
    }
    if (message.goalExtra !== "") {
      writer.uint32(138).string(message.goalExtra);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGoalUpdateMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGoalUpdateMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageDataDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.indicator = LiveStreamGoalIndicatorDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.goal = LiveStreamGoalDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.contributorId = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.contributorAvatar = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.contributorDisplayId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.contributeSubgoal = WebcastGoalUpdateMessage_LiveStreamSubGoalDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.contributeCount = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.contributeScore = reader.int64().toString();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.giftRepeatCount = reader.int64().toString();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.contributorIdStr = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.pin = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.unpin = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.pinInfo = WebcastGoalUpdateMessage_GoalPinInfoDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.updateSource = reader.int32() as any;
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.goalExtra = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGoalUpdateMessage_LiveStreamSubGoal(): WebcastGoalUpdateMessage_LiveStreamSubGoal {
  return {
    type: 0,
    id: "0",
    progress: "0",
    target: "0",
    gift: undefined,
    idStr: "",
    pinInfo: undefined,
    source: 0,
    recommendedText: "",
    recommendedCommon: "",
  };
}

export const WebcastGoalUpdateMessage_LiveStreamSubGoalDecoder: MessageFns<WebcastGoalUpdateMessage_LiveStreamSubGoal> = {
  encode(message: WebcastGoalUpdateMessage_LiveStreamSubGoal, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.id !== "0") {
      writer.uint32(16).int64(message.id);
    }
    if (message.progress !== "0") {
      writer.uint32(24).int64(message.progress);
    }
    if (message.target !== "0") {
      writer.uint32(32).int64(message.target);
    }
    if (message.gift !== undefined) {
      WebcastGoalUpdateMessage_LiveStreamSubGoal_LiveStreamSubGoalGiftDecoder.encode(message.gift, writer.uint32(42).fork())
        .join();
    }
    if (message.idStr !== "") {
      writer.uint32(50).string(message.idStr);
    }
    if (message.pinInfo !== undefined) {
      WebcastGoalUpdateMessage_LiveStreamSubGoal_SubGoalPinInfoDecoder.encode(message.pinInfo, writer.uint32(58).fork())
        .join();
    }
    if (message.source !== 0) {
      writer.uint32(64).int32(message.source);
    }
    if (message.recommendedText !== "") {
      writer.uint32(74).string(message.recommendedText);
    }
    if (message.recommendedCommon !== "") {
      writer.uint32(82).string(message.recommendedCommon);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGoalUpdateMessage_LiveStreamSubGoal {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGoalUpdateMessage_LiveStreamSubGoal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.id = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.progress = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.target = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.gift = WebcastGoalUpdateMessage_LiveStreamSubGoal_LiveStreamSubGoalGiftDecoder.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.idStr = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.pinInfo = WebcastGoalUpdateMessage_LiveStreamSubGoal_SubGoalPinInfoDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.source = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.recommendedText = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.recommendedCommon = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGoalUpdateMessage_LiveStreamSubGoal_LiveStreamSubGoalGift(): WebcastGoalUpdateMessage_LiveStreamSubGoal_LiveStreamSubGoalGift {
  return { name: "", icon: undefined, diamondCount: "0", type: 0 };
}

export const WebcastGoalUpdateMessage_LiveStreamSubGoal_LiveStreamSubGoalGiftDecoder: MessageFns<WebcastGoalUpdateMessage_LiveStreamSubGoal_LiveStreamSubGoalGift> = {
  encode(
    message: WebcastGoalUpdateMessage_LiveStreamSubGoal_LiveStreamSubGoalGift,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.icon !== undefined) {
      ImageDecoder.encode(message.icon, writer.uint32(18).fork()).join();
    }
    if (message.diamondCount !== "0") {
      writer.uint32(24).int64(message.diamondCount);
    }
    if (message.type !== 0) {
      writer.uint32(32).int32(message.type);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): WebcastGoalUpdateMessage_LiveStreamSubGoal_LiveStreamSubGoalGift {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGoalUpdateMessage_LiveStreamSubGoal_LiveStreamSubGoalGift();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.icon = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.diamondCount = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.type = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGoalUpdateMessage_LiveStreamSubGoal_SubGoalPinInfo(): WebcastGoalUpdateMessage_LiveStreamSubGoal_SubGoalPinInfo {
  return { pinStartTime: "0", pinEndTime: "0", pinReadyTime: "0" };
}

export const WebcastGoalUpdateMessage_LiveStreamSubGoal_SubGoalPinInfoDecoder: MessageFns<WebcastGoalUpdateMessage_LiveStreamSubGoal_SubGoalPinInfo> = {
  encode(
    message: WebcastGoalUpdateMessage_LiveStreamSubGoal_SubGoalPinInfo,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.pinStartTime !== "0") {
      writer.uint32(8).int64(message.pinStartTime);
    }
    if (message.pinEndTime !== "0") {
      writer.uint32(16).int64(message.pinEndTime);
    }
    if (message.pinReadyTime !== "0") {
      writer.uint32(24).int64(message.pinReadyTime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGoalUpdateMessage_LiveStreamSubGoal_SubGoalPinInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGoalUpdateMessage_LiveStreamSubGoal_SubGoalPinInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.pinStartTime = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pinEndTime = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pinReadyTime = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGoalUpdateMessage_GoalPinInfo(): WebcastGoalUpdateMessage_GoalPinInfo {
  return { pin: false, unpin: false, pinEndTime: "0", subGoalId: "0", subGoalIdStr: "" };
}

export const WebcastGoalUpdateMessage_GoalPinInfoDecoder: MessageFns<WebcastGoalUpdateMessage_GoalPinInfo> = {
  encode(message: WebcastGoalUpdateMessage_GoalPinInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pin !== false) {
      writer.uint32(8).bool(message.pin);
    }
    if (message.unpin !== false) {
      writer.uint32(16).bool(message.unpin);
    }
    if (message.pinEndTime !== "0") {
      writer.uint32(24).int64(message.pinEndTime);
    }
    if (message.subGoalId !== "0") {
      writer.uint32(32).int64(message.subGoalId);
    }
    if (message.subGoalIdStr !== "") {
      writer.uint32(42).string(message.subGoalIdStr);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGoalUpdateMessage_GoalPinInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGoalUpdateMessage_GoalPinInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.pin = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.unpin = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pinEndTime = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.subGoalId = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.subGoalIdStr = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastImDeleteMessage(): WebcastImDeleteMessage {
  return { common: undefined, deleteMsgIdsList: [], deleteUserIdsList: [] };
}

export const WebcastImDeleteMessageDecoder: MessageFns<WebcastImDeleteMessage> = {
  encode(message: WebcastImDeleteMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageDataDecoder.encode(message.common, writer.uint32(10).fork()).join();
    }
    writer.uint32(18).fork();
    for (const v of message.deleteMsgIdsList) {
      writer.int64(v);
    }
    writer.join();
    writer.uint32(26).fork();
    for (const v of message.deleteUserIdsList) {
      writer.int64(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastImDeleteMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastImDeleteMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageDataDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.deleteMsgIdsList.push(reader.int64().toString());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.deleteMsgIdsList.push(reader.int64().toString());
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag === 24) {
            message.deleteUserIdsList.push(reader.int64().toString());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.deleteUserIdsList.push(reader.int64().toString());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastInRoomBannerMessage(): WebcastInRoomBannerMessage {
  return { common: undefined, data: {}, position: 0, actionType: 0 };
}

export const WebcastInRoomBannerMessageDecoder: MessageFns<WebcastInRoomBannerMessage> = {
  encode(message: WebcastInRoomBannerMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageDataDecoder.encode(message.common, writer.uint32(10).fork()).join();
    }
    Object.entries(message.data).forEach(([key, value]) => {
      WebcastInRoomBannerMessage_DataEntryDecoder.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    if (message.position !== 0) {
      writer.uint32(24).int32(message.position);
    }
    if (message.actionType !== 0) {
      writer.uint32(32).int32(message.actionType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastInRoomBannerMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastInRoomBannerMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageDataDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = WebcastInRoomBannerMessage_DataEntryDecoder.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.data[entry2.key] = entry2.value;
          }
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.position = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.actionType = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastInRoomBannerMessage_DataEntry(): WebcastInRoomBannerMessage_DataEntry {
  return { key: "", value: "" };
}

export const WebcastInRoomBannerMessage_DataEntryDecoder: MessageFns<WebcastInRoomBannerMessage_DataEntry> = {
  encode(message: WebcastInRoomBannerMessage_DataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastInRoomBannerMessage_DataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastInRoomBannerMessage_DataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastRankUpdateMessage(): WebcastRankUpdateMessage {
  return {
    common: undefined,
    updatesList: [],
    groupType: "0",
    priority: "0",
    tabsList: [],
    isAnimationLoopPlay: false,
    animationLoopForOff: false,
    unionAnimation: [],
    tabInfo: [],
  };
}

export const WebcastRankUpdateMessageDecoder: MessageFns<WebcastRankUpdateMessage> = {
  encode(message: WebcastRankUpdateMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageDataDecoder.encode(message.common, writer.uint32(10).fork()).join();
    }
    for (const v of message.updatesList) {
      WebcastRankUpdateMessage_RankUpdateDecoder.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.groupType !== "0") {
      writer.uint32(24).int64(message.groupType);
    }
    if (message.priority !== "0") {
      writer.uint32(40).int64(message.priority);
    }
    for (const v of message.tabsList) {
      WebcastRankUpdateMessage_RankTabInfoDecoder.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.isAnimationLoopPlay !== false) {
      writer.uint32(56).bool(message.isAnimationLoopPlay);
    }
    if (message.animationLoopForOff !== false) {
      writer.uint32(64).bool(message.animationLoopForOff);
    }
    for (const v of message.unionAnimation) {
      WebcastRankUpdateMessage_UnionAnimationInfoDecoder.encode(v!, writer.uint32(74).fork()).join();
    }
    for (const v of message.tabInfo) {
      WebcastRankUpdateMessage_RankListTabInfoDecoder.encode(v!, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastRankUpdateMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastRankUpdateMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageDataDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.updatesList.push(WebcastRankUpdateMessage_RankUpdateDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.groupType = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.priority = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.tabsList.push(WebcastRankUpdateMessage_RankTabInfoDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.isAnimationLoopPlay = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.animationLoopForOff = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.unionAnimation.push(WebcastRankUpdateMessage_UnionAnimationInfoDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.tabInfo.push(WebcastRankUpdateMessage_RankListTabInfoDecoder.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastRankUpdateMessage_UnionAnimationInfo(): WebcastRankUpdateMessage_UnionAnimationInfo {
  return { unionType: 0, rankTypeArray: 0, supportedVersion: "0" };
}

export const WebcastRankUpdateMessage_UnionAnimationInfoDecoder: MessageFns<WebcastRankUpdateMessage_UnionAnimationInfo> = {
  encode(
    message: WebcastRankUpdateMessage_UnionAnimationInfo,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.unionType !== 0) {
      writer.uint32(8).int32(message.unionType);
    }
    if (message.rankTypeArray !== 0) {
      writer.uint32(16).int32(message.rankTypeArray);
    }
    if (message.supportedVersion !== "0") {
      writer.uint32(24).int64(message.supportedVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastRankUpdateMessage_UnionAnimationInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastRankUpdateMessage_UnionAnimationInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.unionType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.rankTypeArray = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.supportedVersion = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastRankUpdateMessage_RankListTabInfo(): WebcastRankUpdateMessage_RankListTabInfo {
  return { tabs: [], supportedVersion: "0" };
}

export const WebcastRankUpdateMessage_RankListTabInfoDecoder: MessageFns<WebcastRankUpdateMessage_RankListTabInfo> = {
  encode(message: WebcastRankUpdateMessage_RankListTabInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.tabs) {
      WebcastRankUpdateMessage_RankTabInfoDecoder.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.supportedVersion !== "0") {
      writer.uint32(16).int64(message.supportedVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastRankUpdateMessage_RankListTabInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastRankUpdateMessage_RankListTabInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tabs.push(WebcastRankUpdateMessage_RankTabInfoDecoder.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.supportedVersion = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastRankUpdateMessage_RankTabInfo(): WebcastRankUpdateMessage_RankTabInfo {
  return { rankType: 0, title: "", titleText: undefined, listLynxType: "0" };
}

export const WebcastRankUpdateMessage_RankTabInfoDecoder: MessageFns<WebcastRankUpdateMessage_RankTabInfo> = {
  encode(message: WebcastRankUpdateMessage_RankTabInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rankType !== 0) {
      writer.uint32(8).int32(message.rankType);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.titleText !== undefined) {
      TextDecoder.encode(message.titleText, writer.uint32(26).fork()).join();
    }
    if (message.listLynxType !== "0") {
      writer.uint32(32).int64(message.listLynxType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastRankUpdateMessage_RankTabInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastRankUpdateMessage_RankTabInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.rankType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.titleText = TextDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.listLynxType = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastRankUpdateMessage_RankUpdate(): WebcastRankUpdateMessage_RankUpdate {
  return {
    rankType: "0",
    ownerRank: "0",
    defaultContent: undefined,
    showEntranceAnimation: false,
    countdown: "0",
    relatedTabRankType: "0",
    requestFirstShowType: "0",
    supportedVersion: "0",
    owneronrank: false,
  };
}

export const WebcastRankUpdateMessage_RankUpdateDecoder: MessageFns<WebcastRankUpdateMessage_RankUpdate> = {
  encode(message: WebcastRankUpdateMessage_RankUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rankType !== "0") {
      writer.uint32(8).int64(message.rankType);
    }
    if (message.ownerRank !== "0") {
      writer.uint32(16).int64(message.ownerRank);
    }
    if (message.defaultContent !== undefined) {
      TextDecoder.encode(message.defaultContent, writer.uint32(26).fork()).join();
    }
    if (message.showEntranceAnimation !== false) {
      writer.uint32(40).bool(message.showEntranceAnimation);
    }
    if (message.countdown !== "0") {
      writer.uint32(48).int64(message.countdown);
    }
    if (message.relatedTabRankType !== "0") {
      writer.uint32(64).int64(message.relatedTabRankType);
    }
    if (message.requestFirstShowType !== "0") {
      writer.uint32(72).int64(message.requestFirstShowType);
    }
    if (message.supportedVersion !== "0") {
      writer.uint32(80).int64(message.supportedVersion);
    }
    if (message.owneronrank !== false) {
      writer.uint32(88).bool(message.owneronrank);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastRankUpdateMessage_RankUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastRankUpdateMessage_RankUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.rankType = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.ownerRank = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.defaultContent = TextDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.showEntranceAnimation = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.countdown = reader.int64().toString();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.relatedTabRankType = reader.int64().toString();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.requestFirstShowType = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.supportedVersion = reader.int64().toString();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.owneronrank = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastPollMessage(): WebcastPollMessage {
  return {
    common: undefined,
    messageType: 0,
    pollId: "0",
    startContent: undefined,
    endContent: undefined,
    updateContent: undefined,
    pollKind: 0,
    pollBasicInfo: undefined,
    templateContent: undefined,
  };
}

export const WebcastPollMessageDecoder: MessageFns<WebcastPollMessage> = {
  encode(message: WebcastPollMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageDataDecoder.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.messageType !== 0) {
      writer.uint32(16).int32(message.messageType);
    }
    if (message.pollId !== "0") {
      writer.uint32(24).int64(message.pollId);
    }
    if (message.startContent !== undefined) {
      PollStartContentDecoder.encode(message.startContent, writer.uint32(34).fork()).join();
    }
    if (message.endContent !== undefined) {
      PollEndContentDecoder.encode(message.endContent, writer.uint32(42).fork()).join();
    }
    if (message.updateContent !== undefined) {
      PollUpdateVotesContentDecoder.encode(message.updateContent, writer.uint32(50).fork()).join();
    }
    if (message.pollKind !== 0) {
      writer.uint32(56).int32(message.pollKind);
    }
    if (message.pollBasicInfo !== undefined) {
      WebcastPollMessage_PollBasicInfoDecoder.encode(message.pollBasicInfo, writer.uint32(66).fork()).join();
    }
    if (message.templateContent !== undefined) {
      WebcastPollMessage_TemplateContentDecoder.encode(message.templateContent, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastPollMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastPollMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageDataDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.messageType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pollId = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.startContent = PollStartContentDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.endContent = PollEndContentDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.updateContent = PollUpdateVotesContentDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.pollKind = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.pollBasicInfo = WebcastPollMessage_PollBasicInfoDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.templateContent = WebcastPollMessage_TemplateContentDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastPollMessage_TemplateContent(): WebcastPollMessage_TemplateContent {
  return { templateId: "0", templateIdStr: "", status: 0, pollKind: 0, appealStatus: 0, violationIdStr: "" };
}

export const WebcastPollMessage_TemplateContentDecoder: MessageFns<WebcastPollMessage_TemplateContent> = {
  encode(message: WebcastPollMessage_TemplateContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.templateId !== "0") {
      writer.uint32(8).int64(message.templateId);
    }
    if (message.templateIdStr !== "") {
      writer.uint32(18).string(message.templateIdStr);
    }
    if (message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    if (message.pollKind !== 0) {
      writer.uint32(32).int32(message.pollKind);
    }
    if (message.appealStatus !== 0) {
      writer.uint32(40).int32(message.appealStatus);
    }
    if (message.violationIdStr !== "") {
      writer.uint32(50).string(message.violationIdStr);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastPollMessage_TemplateContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastPollMessage_TemplateContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.templateId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.templateIdStr = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.pollKind = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.appealStatus = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.violationIdStr = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastPollMessage_PollBasicInfo(): WebcastPollMessage_PollBasicInfo {
  return {
    pollSponsor: "",
    giftId: "0",
    title: "",
    isSuggestedQuestion: false,
    userCnt: "0",
    gift: undefined,
    pollIdStr: "",
    suggestedQuestionKey: "",
    pollDuration: "0",
    timeRemain: "0",
    pollIndex: "0",
    templateId: "0",
  };
}

export const WebcastPollMessage_PollBasicInfoDecoder: MessageFns<WebcastPollMessage_PollBasicInfo> = {
  encode(message: WebcastPollMessage_PollBasicInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pollSponsor !== "") {
      writer.uint32(10).string(message.pollSponsor);
    }
    if (message.giftId !== "0") {
      writer.uint32(16).int64(message.giftId);
    }
    if (message.title !== "") {
      writer.uint32(26).string(message.title);
    }
    if (message.isSuggestedQuestion !== false) {
      writer.uint32(32).bool(message.isSuggestedQuestion);
    }
    if (message.userCnt !== "0") {
      writer.uint32(40).int64(message.userCnt);
    }
    if (message.gift !== undefined) {
      GiftDecoder.encode(message.gift, writer.uint32(50).fork()).join();
    }
    if (message.pollIdStr !== "") {
      writer.uint32(58).string(message.pollIdStr);
    }
    if (message.suggestedQuestionKey !== "") {
      writer.uint32(66).string(message.suggestedQuestionKey);
    }
    if (message.pollDuration !== "0") {
      writer.uint32(72).int64(message.pollDuration);
    }
    if (message.timeRemain !== "0") {
      writer.uint32(80).int64(message.timeRemain);
    }
    if (message.pollIndex !== "0") {
      writer.uint32(88).int64(message.pollIndex);
    }
    if (message.templateId !== "0") {
      writer.uint32(96).int64(message.templateId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastPollMessage_PollBasicInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastPollMessage_PollBasicInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pollSponsor = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.giftId = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isSuggestedQuestion = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.userCnt = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.gift = GiftDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.pollIdStr = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.suggestedQuestionKey = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.pollDuration = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.timeRemain = reader.int64().toString();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.pollIndex = reader.int64().toString();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.templateId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastRankTextMessage(): WebcastRankTextMessage {
  return {
    common: undefined,
    scene: 0,
    ownerIdxBeforeUpdate: "0",
    ownerIdxAfterUpdate: "0",
    selfGetBadgeMsg: undefined,
    otherGetBadgeMsg: undefined,
    curUserId: "0",
  };
}

export const WebcastRankTextMessageDecoder: MessageFns<WebcastRankTextMessage> = {
  encode(message: WebcastRankTextMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageDataDecoder.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.scene !== 0) {
      writer.uint32(16).int32(message.scene);
    }
    if (message.ownerIdxBeforeUpdate !== "0") {
      writer.uint32(24).int64(message.ownerIdxBeforeUpdate);
    }
    if (message.ownerIdxAfterUpdate !== "0") {
      writer.uint32(32).int64(message.ownerIdxAfterUpdate);
    }
    if (message.selfGetBadgeMsg !== undefined) {
      TextDecoder.encode(message.selfGetBadgeMsg, writer.uint32(42).fork()).join();
    }
    if (message.otherGetBadgeMsg !== undefined) {
      TextDecoder.encode(message.otherGetBadgeMsg, writer.uint32(50).fork()).join();
    }
    if (message.curUserId !== "0") {
      writer.uint32(56).int64(message.curUserId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastRankTextMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastRankTextMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageDataDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.scene = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.ownerIdxBeforeUpdate = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.ownerIdxAfterUpdate = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.selfGetBadgeMsg = TextDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.otherGetBadgeMsg = TextDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.curUserId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicBattlePunishFinish(): WebcastLinkMicBattlePunishFinish {
  return { common: undefined, channelId: "0", opUid: "0", reason: 0, battleId: "0", battleSettings: undefined };
}

export const WebcastLinkMicBattlePunishFinishDecoder: MessageFns<WebcastLinkMicBattlePunishFinish> = {
  encode(message: WebcastLinkMicBattlePunishFinish, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageDataDecoder.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.channelId !== "0") {
      writer.uint32(16).int64(message.channelId);
    }
    if (message.opUid !== "0") {
      writer.uint32(24).int64(message.opUid);
    }
    if (message.reason !== 0) {
      writer.uint32(32).int32(message.reason);
    }
    if (message.battleId !== "0") {
      writer.uint32(40).int64(message.battleId);
    }
    if (message.battleSettings !== undefined) {
      BattleSettingDecoder.encode(message.battleSettings, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicBattlePunishFinish {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicBattlePunishFinish();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageDataDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.channelId = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.opUid = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.reason = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.battleId = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.battleSettings = BattleSettingDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkmicBattleTaskMessage(): WebcastLinkmicBattleTaskMessage {
  return {
    common: undefined,
    battleTaskMessageType: 0,
    taskStart: undefined,
    taskUpdate: undefined,
    taskSettle: undefined,
    rewardSettle: undefined,
    battleId: "0",
  };
}

export const WebcastLinkmicBattleTaskMessageDecoder: MessageFns<WebcastLinkmicBattleTaskMessage> = {
  encode(message: WebcastLinkmicBattleTaskMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageDataDecoder.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.battleTaskMessageType !== 0) {
      writer.uint32(16).int32(message.battleTaskMessageType);
    }
    if (message.taskStart !== undefined) {
      WebcastLinkmicBattleTaskMessage_BattleTaskStartDecoder.encode(message.taskStart, writer.uint32(26).fork()).join();
    }
    if (message.taskUpdate !== undefined) {
      WebcastLinkmicBattleTaskMessage_BattleTaskUpdateDecoder.encode(message.taskUpdate, writer.uint32(34).fork()).join();
    }
    if (message.taskSettle !== undefined) {
      WebcastLinkmicBattleTaskMessage_BattleTaskSettleDecoder.encode(message.taskSettle, writer.uint32(42).fork()).join();
    }
    if (message.rewardSettle !== undefined) {
      WebcastLinkmicBattleTaskMessage_BattleRewardSettleDecoder.encode(message.rewardSettle, writer.uint32(50).fork()).join();
    }
    if (message.battleId !== "0") {
      writer.uint32(160).int64(message.battleId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkmicBattleTaskMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkmicBattleTaskMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageDataDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.battleTaskMessageType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.taskStart = WebcastLinkmicBattleTaskMessage_BattleTaskStartDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.taskUpdate = WebcastLinkmicBattleTaskMessage_BattleTaskUpdateDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.taskSettle = WebcastLinkmicBattleTaskMessage_BattleTaskSettleDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.rewardSettle = WebcastLinkmicBattleTaskMessage_BattleRewardSettleDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.battleId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkmicBattleTaskMessage_BattlePrompt(): WebcastLinkmicBattleTaskMessage_BattlePrompt {
  return { promptKey: "", promptElements: [] };
}

export const WebcastLinkmicBattleTaskMessage_BattlePromptDecoder: MessageFns<WebcastLinkmicBattleTaskMessage_BattlePrompt> = {
  encode(
    message: WebcastLinkmicBattleTaskMessage_BattlePrompt,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.promptKey !== "") {
      writer.uint32(10).string(message.promptKey);
    }
    for (const v of message.promptElements) {
      WebcastLinkmicBattleTaskMessage_BattlePrompt_BattlePromptElemDecoder.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkmicBattleTaskMessage_BattlePrompt {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkmicBattleTaskMessage_BattlePrompt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.promptKey = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.promptElements.push(
            WebcastLinkmicBattleTaskMessage_BattlePrompt_BattlePromptElemDecoder.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkmicBattleTaskMessage_BattlePrompt_BattlePromptElem(): WebcastLinkmicBattleTaskMessage_BattlePrompt_BattlePromptElem {
  return { promptFieldKey: "", promptFieldValue: "" };
}

export const WebcastLinkmicBattleTaskMessage_BattlePrompt_BattlePromptElemDecoder: MessageFns<WebcastLinkmicBattleTaskMessage_BattlePrompt_BattlePromptElem> = {
  encode(
    message: WebcastLinkmicBattleTaskMessage_BattlePrompt_BattlePromptElem,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.promptFieldKey !== "") {
      writer.uint32(10).string(message.promptFieldKey);
    }
    if (message.promptFieldValue !== "") {
      writer.uint32(18).string(message.promptFieldValue);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): WebcastLinkmicBattleTaskMessage_BattlePrompt_BattlePromptElem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkmicBattleTaskMessage_BattlePrompt_BattlePromptElem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.promptFieldKey = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.promptFieldValue = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkmicBattleTaskMessage_BattleTaskStart(): WebcastLinkmicBattleTaskMessage_BattleTaskStart {
  return { battleBonusConfig: undefined };
}

export const WebcastLinkmicBattleTaskMessage_BattleTaskStartDecoder: MessageFns<WebcastLinkmicBattleTaskMessage_BattleTaskStart> = {
  encode(
    message: WebcastLinkmicBattleTaskMessage_BattleTaskStart,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.battleBonusConfig !== undefined) {
      WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfigDecoder.encode(
        message.battleBonusConfig,
        writer.uint32(10).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkmicBattleTaskMessage_BattleTaskStart {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkmicBattleTaskMessage_BattleTaskStart();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.battleBonusConfig = WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfigDecoder.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig(): WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig {
  return {
    previewStartTime: "0",
    previewPeriodConfig: [],
    taskPeriodConfig: undefined,
    rewardPeriodConfig: undefined,
    taskGiftGuide: {},
    previewStartTimestamp: "0",
    previewClickActionSchemaUrl: "",
  };
}

export const WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfigDecoder: MessageFns<WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig> = {
  encode(
    message: WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.previewStartTime !== "0") {
      writer.uint32(8).int64(message.previewStartTime);
    }
    for (const v of message.previewPeriodConfig) {
      WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_PreviewPeriodDecoder.encode(
        v!,
        writer.uint32(18).fork(),
      ).join();
    }
    if (message.taskPeriodConfig !== undefined) {
      WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_TaskPeriodConfigDecoder.encode(
        message.taskPeriodConfig,
        writer.uint32(26).fork(),
      ).join();
    }
    if (message.rewardPeriodConfig !== undefined) {
      WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_RewardPeriodConfigDecoder.encode(
        message.rewardPeriodConfig,
        writer.uint32(34).fork(),
      ).join();
    }
    Object.entries(message.taskGiftGuide).forEach(([key, value]) => {
      WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_TaskGiftGuideEntryDecoder.encode({
        key: key as any,
        value,
      }, writer.uint32(42).fork()).join();
    });
    if (message.previewStartTimestamp !== "0") {
      writer.uint32(48).int64(message.previewStartTimestamp);
    }
    if (message.previewClickActionSchemaUrl !== "") {
      writer.uint32(58).string(message.previewClickActionSchemaUrl);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.previewStartTime = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.previewPeriodConfig.push(
            WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_PreviewPeriodDecoder.decode(
              reader,
              reader.uint32(),
            ),
          );
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.taskPeriodConfig = WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_TaskPeriodConfigDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.rewardPeriodConfig =
            WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_RewardPeriodConfigDecoder.decode(
              reader,
              reader.uint32(),
            );
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_TaskGiftGuideEntryDecoder.decode(
            reader,
            reader.uint32(),
          );
          if (entry5.value !== undefined) {
            message.taskGiftGuide[entry5.key] = entry5.value;
          }
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.previewStartTimestamp = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.previewClickActionSchemaUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_TaskGiftGuideEntry(): WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_TaskGiftGuideEntry {
  return { key: "0", value: undefined };
}

export const WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_TaskGiftGuideEntryDecoder: MessageFns<WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_TaskGiftGuideEntry> = {
  encode(
    message: WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_TaskGiftGuideEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "0") {
      writer.uint32(8).int64(message.key);
    }
    if (message.value !== undefined) {
      WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_BattleTaskGiftAmountGuideDecoder.encode(
        message.value,
        writer.uint32(18).fork(),
      ).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_TaskGiftGuideEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_TaskGiftGuideEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_BattleTaskGiftAmountGuideDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_PreviewPeriod(): WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_PreviewPeriod {
  return { duration: "0", promot: undefined, icon: undefined };
}

export const WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_PreviewPeriodDecoder: MessageFns<WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_PreviewPeriod> = {
  encode(
    message: WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_PreviewPeriod,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.duration !== "0") {
      writer.uint32(8).int64(message.duration);
    }
    if (message.promot !== undefined) {
      WebcastLinkmicBattleTaskMessage_BattlePromptDecoder.encode(message.promot, writer.uint32(18).fork()).join();
    }
    if (message.icon !== undefined) {
      ImageDecoder.encode(message.icon, writer.uint32(202).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_PreviewPeriod {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_PreviewPeriod();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.duration = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.promot = WebcastLinkmicBattleTaskMessage_BattlePromptDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.icon = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_TaskPeriodConfig(): WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_TaskPeriodConfig {
  return {
    taskStartTime: "0",
    duration: "0",
    targetStartTimestamp: "0",
    clickAction: 0,
    clickToastPrompt: undefined,
    promptType: 0,
    taskStaticPrompt: undefined,
    progressTarget: "0",
    targetType: 0,
    icon: undefined,
    clickActionSchemaUrl: "",
  };
}

export const WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_TaskPeriodConfigDecoder: MessageFns<WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_TaskPeriodConfig> = {
  encode(
    message: WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_TaskPeriodConfig,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.taskStartTime !== "0") {
      writer.uint32(8).int64(message.taskStartTime);
    }
    if (message.duration !== "0") {
      writer.uint32(16).int64(message.duration);
    }
    if (message.targetStartTimestamp !== "0") {
      writer.uint32(24).int64(message.targetStartTimestamp);
    }
    if (message.clickAction !== 0) {
      writer.uint32(88).int32(message.clickAction);
    }
    if (message.clickToastPrompt !== undefined) {
      WebcastLinkmicBattleTaskMessage_BattlePromptDecoder.encode(message.clickToastPrompt, writer.uint32(98).fork()).join();
    }
    if (message.promptType !== 0) {
      writer.uint32(168).int32(message.promptType);
    }
    if (message.taskStaticPrompt !== undefined) {
      WebcastLinkmicBattleTaskMessage_BattlePromptDecoder.encode(message.taskStaticPrompt, writer.uint32(178).fork()).join();
    }
    if (message.progressTarget !== "0") {
      writer.uint32(184).int64(message.progressTarget);
    }
    if (message.targetType !== 0) {
      writer.uint32(192).int32(message.targetType);
    }
    if (message.icon !== undefined) {
      ImageDecoder.encode(message.icon, writer.uint32(202).fork()).join();
    }
    if (message.clickActionSchemaUrl !== "") {
      writer.uint32(210).string(message.clickActionSchemaUrl);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_TaskPeriodConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_TaskPeriodConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.taskStartTime = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.duration = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.targetStartTimestamp = reader.int64().toString();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.clickAction = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.clickToastPrompt = WebcastLinkmicBattleTaskMessage_BattlePromptDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.promptType = reader.int32();
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.taskStaticPrompt = WebcastLinkmicBattleTaskMessage_BattlePromptDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 23: {
          if (tag !== 184) {
            break;
          }

          message.progressTarget = reader.int64().toString();
          continue;
        }
        case 24: {
          if (tag !== 192) {
            break;
          }

          message.targetType = reader.int32();
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.icon = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.clickActionSchemaUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_RewardPeriodConfig(): WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_RewardPeriodConfig {
  return {
    rewardStartTime: "0",
    duration: "0",
    rewardMultiple: 0,
    rewardStartTimestamp: "0",
    rewardPraparePrompt: undefined,
    rewardingPrompt: undefined,
    clickPrompt: undefined,
  };
}

export const WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_RewardPeriodConfigDecoder: MessageFns<WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_RewardPeriodConfig> = {
  encode(
    message: WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_RewardPeriodConfig,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.rewardStartTime !== "0") {
      writer.uint32(8).int64(message.rewardStartTime);
    }
    if (message.duration !== "0") {
      writer.uint32(16).int64(message.duration);
    }
    if (message.rewardMultiple !== 0) {
      writer.uint32(24).int32(message.rewardMultiple);
    }
    if (message.rewardStartTimestamp !== "0") {
      writer.uint32(32).int64(message.rewardStartTimestamp);
    }
    if (message.rewardPraparePrompt !== undefined) {
      WebcastLinkmicBattleTaskMessage_BattlePromptDecoder.encode(message.rewardPraparePrompt, writer.uint32(90).fork()).join();
    }
    if (message.rewardingPrompt !== undefined) {
      WebcastLinkmicBattleTaskMessage_BattlePromptDecoder.encode(message.rewardingPrompt, writer.uint32(98).fork()).join();
    }
    if (message.clickPrompt !== undefined) {
      WebcastLinkmicBattleTaskMessage_BattlePromptDecoder.encode(message.clickPrompt, writer.uint32(106).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_RewardPeriodConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_RewardPeriodConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.rewardStartTime = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.duration = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.rewardMultiple = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.rewardStartTimestamp = reader.int64().toString();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.rewardPraparePrompt = WebcastLinkmicBattleTaskMessage_BattlePromptDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.rewardingPrompt = WebcastLinkmicBattleTaskMessage_BattlePromptDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.clickPrompt = WebcastLinkmicBattleTaskMessage_BattlePromptDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_BattleTaskGiftAmountGuide(): WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_BattleTaskGiftAmountGuide {
  return {
    guidePrompt: undefined,
    promptType: 0,
    disappearDuration: 0,
    iconImage: undefined,
    giftImage: undefined,
    recommendGiftId: "0",
    recommendGiftCount: 0,
    guideContent: undefined,
  };
}

export const WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_BattleTaskGiftAmountGuideDecoder: MessageFns<WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_BattleTaskGiftAmountGuide> = {
  encode(
    message: WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_BattleTaskGiftAmountGuide,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.guidePrompt !== undefined) {
      WebcastLinkmicBattleTaskMessage_BattlePromptDecoder.encode(message.guidePrompt, writer.uint32(10).fork()).join();
    }
    if (message.promptType !== 0) {
      writer.uint32(16).int32(message.promptType);
    }
    if (message.disappearDuration !== 0) {
      writer.uint32(24).int32(message.disappearDuration);
    }
    if (message.iconImage !== undefined) {
      ImageDecoder.encode(message.iconImage, writer.uint32(90).fork()).join();
    }
    if (message.giftImage !== undefined) {
      ImageDecoder.encode(message.giftImage, writer.uint32(98).fork()).join();
    }
    if (message.recommendGiftId !== "0") {
      writer.uint32(168).int64(message.recommendGiftId);
    }
    if (message.recommendGiftCount !== 0) {
      writer.uint32(176).int32(message.recommendGiftCount);
    }
    if (message.guideContent !== undefined) {
      TextDecoder.encode(message.guideContent, writer.uint32(186).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_BattleTaskGiftAmountGuide {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message =
      createBaseWebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_BattleTaskGiftAmountGuide();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.guidePrompt = WebcastLinkmicBattleTaskMessage_BattlePromptDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.promptType = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.disappearDuration = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.iconImage = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.giftImage = ImageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.recommendGiftId = reader.int64().toString();
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.recommendGiftCount = reader.int32();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.guideContent = TextDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkmicBattleTaskMessage_BattleTaskUpdate(): WebcastLinkmicBattleTaskMessage_BattleTaskUpdate {
  return { taskProgress: "0", fromUserUid: "0", promptKey: "", logId: "" };
}

export const WebcastLinkmicBattleTaskMessage_BattleTaskUpdateDecoder: MessageFns<WebcastLinkmicBattleTaskMessage_BattleTaskUpdate> = {
  encode(
    message: WebcastLinkmicBattleTaskMessage_BattleTaskUpdate,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.taskProgress !== "0") {
      writer.uint32(8).int64(message.taskProgress);
    }
    if (message.fromUserUid !== "0") {
      writer.uint32(16).int64(message.fromUserUid);
    }
    if (message.promptKey !== "") {
      writer.uint32(26).string(message.promptKey);
    }
    if (message.logId !== "") {
      writer.uint32(170).string(message.logId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkmicBattleTaskMessage_BattleTaskUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkmicBattleTaskMessage_BattleTaskUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.taskProgress = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.fromUserUid = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.promptKey = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.logId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkmicBattleTaskMessage_BattleTaskSettle(): WebcastLinkmicBattleTaskMessage_BattleTaskSettle {
  return { taskResult: 0, rewardStartTime: "0", rewardStartTimestamp: "0" };
}

export const WebcastLinkmicBattleTaskMessage_BattleTaskSettleDecoder: MessageFns<WebcastLinkmicBattleTaskMessage_BattleTaskSettle> = {
  encode(
    message: WebcastLinkmicBattleTaskMessage_BattleTaskSettle,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.taskResult !== 0) {
      writer.uint32(8).int32(message.taskResult);
    }
    if (message.rewardStartTime !== "0") {
      writer.uint32(16).int64(message.rewardStartTime);
    }
    if (message.rewardStartTimestamp !== "0") {
      writer.uint32(24).int64(message.rewardStartTimestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkmicBattleTaskMessage_BattleTaskSettle {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkmicBattleTaskMessage_BattleTaskSettle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.taskResult = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.rewardStartTime = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.rewardStartTimestamp = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkmicBattleTaskMessage_BattleRewardSettle(): WebcastLinkmicBattleTaskMessage_BattleRewardSettle {
  return { rewardSettlePrompt: undefined, status: 0 };
}

export const WebcastLinkmicBattleTaskMessage_BattleRewardSettleDecoder: MessageFns<WebcastLinkmicBattleTaskMessage_BattleRewardSettle> = {
  encode(
    message: WebcastLinkmicBattleTaskMessage_BattleRewardSettle,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.rewardSettlePrompt !== undefined) {
      WebcastLinkmicBattleTaskMessage_BattlePromptDecoder.encode(message.rewardSettlePrompt, writer.uint32(10).fork()).join();
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkmicBattleTaskMessage_BattleRewardSettle {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkmicBattleTaskMessage_BattleRewardSettle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rewardSettlePrompt = WebcastLinkmicBattleTaskMessage_BattlePromptDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicFanTicketMethod(): WebcastLinkMicFanTicketMethod {
  return { common: undefined, FanTicketRoomNotice: undefined };
}

export const WebcastLinkMicFanTicketMethodDecoder: MessageFns<WebcastLinkMicFanTicketMethod> = {
  encode(message: WebcastLinkMicFanTicketMethod, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageDataDecoder.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.FanTicketRoomNotice !== undefined) {
      FanTicketRoomNoticeContentDecoder.encode(message.FanTicketRoomNotice, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicFanTicketMethod {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicFanTicketMethod();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageDataDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.FanTicketRoomNotice = FanTicketRoomNoticeContentDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicMethod(): WebcastLinkMicMethod {
  return {
    common: undefined,
    messageType: 0,
    accessKey: "",
    anchorLinkmicId: "0",
    userId: "0",
    fanTicket: "0",
    totalLinkMicFanTicket: "0",
    channelId: "0",
    layout: "0",
    vendor: "0",
    dimension: "0",
    theme: "",
    inviteUid: "0",
    reply: 0,
    duration: 0,
    matchType: 0,
    win: false,
    prompts: "",
    toUserId: "0",
    tips: "",
    startTimeMs: "0",
    confluenceType: 0,
    fromRoomId: "0",
    inviteType: 0,
    subType: "0",
    rtcExtInfo: "",
    appId: "",
    appSign: "",
    anchorLinkMicIdStr: "",
    rivalAnchorId: "0",
    rivalLinkmicId: 0,
    rivalLinkmicIdStr: "",
    shouldShowPopup: false,
    rtcJoinChannel: false,
    fanTicketType: 0,
  };
}

export const WebcastLinkMicMethodDecoder: MessageFns<WebcastLinkMicMethod> = {
  encode(message: WebcastLinkMicMethod, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageDataDecoder.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.messageType !== 0) {
      writer.uint32(16).int32(message.messageType);
    }
    if (message.accessKey !== "") {
      writer.uint32(26).string(message.accessKey);
    }
    if (message.anchorLinkmicId !== "0") {
      writer.uint32(32).int64(message.anchorLinkmicId);
    }
    if (message.userId !== "0") {
      writer.uint32(40).int64(message.userId);
    }
    if (message.fanTicket !== "0") {
      writer.uint32(48).int64(message.fanTicket);
    }
    if (message.totalLinkMicFanTicket !== "0") {
      writer.uint32(56).int64(message.totalLinkMicFanTicket);
    }
    if (message.channelId !== "0") {
      writer.uint32(64).int64(message.channelId);
    }
    if (message.layout !== "0") {
      writer.uint32(72).int64(message.layout);
    }
    if (message.vendor !== "0") {
      writer.uint32(80).int64(message.vendor);
    }
    if (message.dimension !== "0") {
      writer.uint32(88).int64(message.dimension);
    }
    if (message.theme !== "") {
      writer.uint32(98).string(message.theme);
    }
    if (message.inviteUid !== "0") {
      writer.uint32(104).int64(message.inviteUid);
    }
    if (message.reply !== 0) {
      writer.uint32(112).int32(message.reply);
    }
    if (message.duration !== 0) {
      writer.uint32(128).int32(message.duration);
    }
    if (message.matchType !== 0) {
      writer.uint32(144).int32(message.matchType);
    }
    if (message.win !== false) {
      writer.uint32(152).bool(message.win);
    }
    if (message.prompts !== "") {
      writer.uint32(162).string(message.prompts);
    }
    if (message.toUserId !== "0") {
      writer.uint32(168).int64(message.toUserId);
    }
    if (message.tips !== "") {
      writer.uint32(202).string(message.tips);
    }
    if (message.startTimeMs !== "0") {
      writer.uint32(208).int64(message.startTimeMs);
    }
    if (message.confluenceType !== 0) {
      writer.uint32(216).int32(message.confluenceType);
    }
    if (message.fromRoomId !== "0") {
      writer.uint32(224).int64(message.fromRoomId);
    }
    if (message.inviteType !== 0) {
      writer.uint32(232).int32(message.inviteType);
    }
    if (message.subType !== "0") {
      writer.uint32(240).int64(message.subType);
    }
    if (message.rtcExtInfo !== "") {
      writer.uint32(258).string(message.rtcExtInfo);
    }
    if (message.appId !== "") {
      writer.uint32(274).string(message.appId);
    }
    if (message.appSign !== "") {
      writer.uint32(282).string(message.appSign);
    }
    if (message.anchorLinkMicIdStr !== "") {
      writer.uint32(298).string(message.anchorLinkMicIdStr);
    }
    if (message.rivalAnchorId !== "0") {
      writer.uint32(304).int64(message.rivalAnchorId);
    }
    if (message.rivalLinkmicId !== 0) {
      writer.uint32(312).int32(message.rivalLinkmicId);
    }
    if (message.rivalLinkmicIdStr !== "") {
      writer.uint32(322).string(message.rivalLinkmicIdStr);
    }
    if (message.shouldShowPopup !== false) {
      writer.uint32(328).bool(message.shouldShowPopup);
    }
    if (message.rtcJoinChannel !== false) {
      writer.uint32(408).bool(message.rtcJoinChannel);
    }
    if (message.fanTicketType !== 0) {
      writer.uint32(416).int32(message.fanTicketType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicMethod {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicMethod();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageDataDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.messageType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.accessKey = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.anchorLinkmicId = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.userId = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.fanTicket = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.totalLinkMicFanTicket = reader.int64().toString();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.channelId = reader.int64().toString();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.layout = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.vendor = reader.int64().toString();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.dimension = reader.int64().toString();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.theme = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.inviteUid = reader.int64().toString();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.reply = reader.int32();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.duration = reader.int32();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.matchType = reader.int32();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.win = reader.bool();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.prompts = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.toUserId = reader.int64().toString();
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.tips = reader.string();
          continue;
        }
        case 26: {
          if (tag !== 208) {
            break;
          }

          message.startTimeMs = reader.int64().toString();
          continue;
        }
        case 27: {
          if (tag !== 216) {
            break;
          }

          message.confluenceType = reader.int32();
          continue;
        }
        case 28: {
          if (tag !== 224) {
            break;
          }

          message.fromRoomId = reader.int64().toString();
          continue;
        }
        case 29: {
          if (tag !== 232) {
            break;
          }

          message.inviteType = reader.int32();
          continue;
        }
        case 30: {
          if (tag !== 240) {
            break;
          }

          message.subType = reader.int64().toString();
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.rtcExtInfo = reader.string();
          continue;
        }
        case 34: {
          if (tag !== 274) {
            break;
          }

          message.appId = reader.string();
          continue;
        }
        case 35: {
          if (tag !== 282) {
            break;
          }

          message.appSign = reader.string();
          continue;
        }
        case 37: {
          if (tag !== 298) {
            break;
          }

          message.anchorLinkMicIdStr = reader.string();
          continue;
        }
        case 38: {
          if (tag !== 304) {
            break;
          }

          message.rivalAnchorId = reader.int64().toString();
          continue;
        }
        case 39: {
          if (tag !== 312) {
            break;
          }

          message.rivalLinkmicId = reader.int32();
          continue;
        }
        case 40: {
          if (tag !== 322) {
            break;
          }

          message.rivalLinkmicIdStr = reader.string();
          continue;
        }
        case 41: {
          if (tag !== 328) {
            break;
          }

          message.shouldShowPopup = reader.bool();
          continue;
        }
        case 51: {
          if (tag !== 408) {
            break;
          }

          message.rtcJoinChannel = reader.bool();
          continue;
        }
        case 52: {
          if (tag !== 416) {
            break;
          }

          message.fanTicketType = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastUnauthorizedMemberMessage(): WebcastUnauthorizedMemberMessage {
  return {
    common: undefined,
    action: 0,
    nickNamePrefix: undefined,
    nickName: "",
    enterText: undefined,
    publicAreaCommon: undefined,
  };
}

export const WebcastUnauthorizedMemberMessageDecoder: MessageFns<WebcastUnauthorizedMemberMessage> = {
  encode(message: WebcastUnauthorizedMemberMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageDataDecoder.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.action !== 0) {
      writer.uint32(16).int32(message.action);
    }
    if (message.nickNamePrefix !== undefined) {
      TextDecoder.encode(message.nickNamePrefix, writer.uint32(26).fork()).join();
    }
    if (message.nickName !== "") {
      writer.uint32(34).string(message.nickName);
    }
    if (message.enterText !== undefined) {
      TextDecoder.encode(message.enterText, writer.uint32(42).fork()).join();
    }
    if (message.publicAreaCommon !== undefined) {
      PublicAreaMessageCommonDecoder.encode(message.publicAreaCommon, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastUnauthorizedMemberMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastUnauthorizedMemberMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageDataDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.action = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nickNamePrefix = TextDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.nickName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.enterText = TextDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.publicAreaCommon = PublicAreaMessageCommonDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastMsgDetectMessage(): WebcastMsgDetectMessage {
  return {
    common: undefined,
    detectType: 0,
    triggerCondition: undefined,
    timeInfo: undefined,
    triggerBy: 0,
    fromRegion: "",
  };
}

export const WebcastMsgDetectMessageDecoder: MessageFns<WebcastMsgDetectMessage> = {
  encode(message: WebcastMsgDetectMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageDataDecoder.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.detectType !== 0) {
      writer.uint32(16).int32(message.detectType);
    }
    if (message.triggerCondition !== undefined) {
      WebcastMsgDetectMessage_TriggerConditionDecoder.encode(message.triggerCondition, writer.uint32(26).fork()).join();
    }
    if (message.timeInfo !== undefined) {
      WebcastMsgDetectMessage_TimeInfoDecoder.encode(message.timeInfo, writer.uint32(34).fork()).join();
    }
    if (message.triggerBy !== 0) {
      writer.uint32(40).int32(message.triggerBy);
    }
    if (message.fromRegion !== "") {
      writer.uint32(50).string(message.fromRegion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastMsgDetectMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastMsgDetectMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageDataDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.detectType = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.triggerCondition = WebcastMsgDetectMessage_TriggerConditionDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timeInfo = WebcastMsgDetectMessage_TimeInfoDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.triggerBy = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.fromRegion = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastMsgDetectMessage_TimeInfo(): WebcastMsgDetectMessage_TimeInfo {
  return { clientStartMs: "0", apiRecvTimeMs: "0", apiSendToGoimMs: "0" };
}

export const WebcastMsgDetectMessage_TimeInfoDecoder: MessageFns<WebcastMsgDetectMessage_TimeInfo> = {
  encode(message: WebcastMsgDetectMessage_TimeInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientStartMs !== "0") {
      writer.uint32(8).int64(message.clientStartMs);
    }
    if (message.apiRecvTimeMs !== "0") {
      writer.uint32(16).int64(message.apiRecvTimeMs);
    }
    if (message.apiSendToGoimMs !== "0") {
      writer.uint32(24).int64(message.apiSendToGoimMs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastMsgDetectMessage_TimeInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastMsgDetectMessage_TimeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.clientStartMs = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.apiRecvTimeMs = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.apiSendToGoimMs = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastMsgDetectMessage_TriggerCondition(): WebcastMsgDetectMessage_TriggerCondition {
  return {
    uplinkDetectHttp: false,
    uplinkDetectWebSocket: false,
    detectP2PMsg: false,
    detectRoomMsg: false,
    httpOptimize: false,
  };
}

export const WebcastMsgDetectMessage_TriggerConditionDecoder: MessageFns<WebcastMsgDetectMessage_TriggerCondition> = {
  encode(message: WebcastMsgDetectMessage_TriggerCondition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uplinkDetectHttp !== false) {
      writer.uint32(8).bool(message.uplinkDetectHttp);
    }
    if (message.uplinkDetectWebSocket !== false) {
      writer.uint32(16).bool(message.uplinkDetectWebSocket);
    }
    if (message.detectP2PMsg !== false) {
      writer.uint32(24).bool(message.detectP2PMsg);
    }
    if (message.detectRoomMsg !== false) {
      writer.uint32(32).bool(message.detectRoomMsg);
    }
    if (message.httpOptimize !== false) {
      writer.uint32(40).bool(message.httpOptimize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastMsgDetectMessage_TriggerCondition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastMsgDetectMessage_TriggerCondition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uplinkDetectHttp = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.uplinkDetectWebSocket = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.detectP2PMsg = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.detectRoomMsg = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.httpOptimize = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastOecLiveShoppingMessage(): WebcastOecLiveShoppingMessage {
  return { common: undefined, data1: 0, shopData: undefined, shopTimings: undefined, details: undefined };
}

export const WebcastOecLiveShoppingMessageDecoder: MessageFns<WebcastOecLiveShoppingMessage> = {
  encode(message: WebcastOecLiveShoppingMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageDataDecoder.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.data1 !== 0) {
      writer.uint32(16).uint32(message.data1);
    }
    if (message.shopData !== undefined) {
      WebcastOecLiveShoppingMessage_LiveShoppingDataDecoder.encode(message.shopData, writer.uint32(34).fork()).join();
    }
    if (message.shopTimings !== undefined) {
      TimeStampContainerDecoder.encode(message.shopTimings, writer.uint32(42).fork()).join();
    }
    if (message.details !== undefined) {
      WebcastOecLiveShoppingMessage_LiveShoppingDetailsDecoder.encode(message.details, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastOecLiveShoppingMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastOecLiveShoppingMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageDataDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.data1 = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.shopData = WebcastOecLiveShoppingMessage_LiveShoppingDataDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.shopTimings = TimeStampContainerDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.details = WebcastOecLiveShoppingMessage_LiveShoppingDetailsDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastOecLiveShoppingMessage_LiveShoppingData(): WebcastOecLiveShoppingMessage_LiveShoppingData {
  return {
    title: "",
    priceString: "",
    imageUrl: "",
    shopUrl: "",
    data1: "0",
    shopName: "",
    data2: "0",
    shopUrl2: "",
    data3: "0",
    data4: "0",
  };
}

export const WebcastOecLiveShoppingMessage_LiveShoppingDataDecoder: MessageFns<WebcastOecLiveShoppingMessage_LiveShoppingData> = {
  encode(
    message: WebcastOecLiveShoppingMessage_LiveShoppingData,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.priceString !== "") {
      writer.uint32(18).string(message.priceString);
    }
    if (message.imageUrl !== "") {
      writer.uint32(26).string(message.imageUrl);
    }
    if (message.shopUrl !== "") {
      writer.uint32(34).string(message.shopUrl);
    }
    if (message.data1 !== "0") {
      writer.uint32(48).uint64(message.data1);
    }
    if (message.shopName !== "") {
      writer.uint32(58).string(message.shopName);
    }
    if (message.data2 !== "0") {
      writer.uint32(64).uint64(message.data2);
    }
    if (message.shopUrl2 !== "") {
      writer.uint32(74).string(message.shopUrl2);
    }
    if (message.data3 !== "0") {
      writer.uint32(80).uint64(message.data3);
    }
    if (message.data4 !== "0") {
      writer.uint32(88).uint64(message.data4);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastOecLiveShoppingMessage_LiveShoppingData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastOecLiveShoppingMessage_LiveShoppingData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.priceString = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.imageUrl = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.shopUrl = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.data1 = reader.uint64().toString();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.shopName = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.data2 = reader.uint64().toString();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.shopUrl2 = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.data3 = reader.uint64().toString();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.data4 = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastOecLiveShoppingMessage_LiveShoppingDetails(): WebcastOecLiveShoppingMessage_LiveShoppingDetails {
  return { id1: "", data1: "", data2: 0, timestamp: "0", data: undefined };
}

export const WebcastOecLiveShoppingMessage_LiveShoppingDetailsDecoder: MessageFns<WebcastOecLiveShoppingMessage_LiveShoppingDetails> = {
  encode(
    message: WebcastOecLiveShoppingMessage_LiveShoppingDetails,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id1 !== "") {
      writer.uint32(10).string(message.id1);
    }
    if (message.data1 !== "") {
      writer.uint32(26).string(message.data1);
    }
    if (message.data2 !== 0) {
      writer.uint32(32).uint32(message.data2);
    }
    if (message.timestamp !== "0") {
      writer.uint32(40).uint64(message.timestamp);
    }
    if (message.data !== undefined) {
      ValueLabelDecoder.encode(message.data, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastOecLiveShoppingMessage_LiveShoppingDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastOecLiveShoppingMessage_LiveShoppingDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id1 = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data1 = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.data2 = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.timestamp = reader.uint64().toString();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.data = ValueLabelDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastRoomPinMessage(): WebcastRoomPinMessage {
  return {
    common: undefined,
    chatMessage: undefined,
    socialMessage: undefined,
    giftMessage: undefined,
    memberMessage: undefined,
    likeMessage: undefined,
    method: "",
    pinTime: "0",
    operator: undefined,
    action: 0,
    displayDuration: "0",
    pinId: "0",
    ecStreamerKey: "",
  };
}

export const WebcastRoomPinMessageDecoder: MessageFns<WebcastRoomPinMessage> = {
  encode(message: WebcastRoomPinMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageDataDecoder.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.chatMessage !== undefined) {
      WebcastChatMessageDecoder.encode(message.chatMessage, writer.uint32(18).fork()).join();
    }
    if (message.socialMessage !== undefined) {
      WebcastSocialMessageDecoder.encode(message.socialMessage, writer.uint32(26).fork()).join();
    }
    if (message.giftMessage !== undefined) {
      WebcastGiftMessageDecoder.encode(message.giftMessage, writer.uint32(34).fork()).join();
    }
    if (message.memberMessage !== undefined) {
      WebcastMemberMessageDecoder.encode(message.memberMessage, writer.uint32(42).fork()).join();
    }
    if (message.likeMessage !== undefined) {
      WebcastLikeMessageDecoder.encode(message.likeMessage, writer.uint32(50).fork()).join();
    }
    if (message.method !== "") {
      writer.uint32(242).string(message.method);
    }
    if (message.pinTime !== "0") {
      writer.uint32(248).int64(message.pinTime);
    }
    if (message.operator !== undefined) {
      UserDecoder.encode(message.operator, writer.uint32(258).fork()).join();
    }
    if (message.action !== 0) {
      writer.uint32(264).int32(message.action);
    }
    if (message.displayDuration !== "0") {
      writer.uint32(272).int64(message.displayDuration);
    }
    if (message.pinId !== "0") {
      writer.uint32(280).int64(message.pinId);
    }
    if (message.ecStreamerKey !== "") {
      writer.uint32(290).string(message.ecStreamerKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastRoomPinMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastRoomPinMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageDataDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chatMessage = WebcastChatMessageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.socialMessage = WebcastSocialMessageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.giftMessage = WebcastGiftMessageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.memberMessage = WebcastMemberMessageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.likeMessage = WebcastLikeMessageDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.method = reader.string();
          continue;
        }
        case 31: {
          if (tag !== 248) {
            break;
          }

          message.pinTime = reader.int64().toString();
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.operator = UserDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 33: {
          if (tag !== 264) {
            break;
          }

          message.action = reader.int32();
          continue;
        }
        case 34: {
          if (tag !== 272) {
            break;
          }

          message.displayDuration = reader.int64().toString();
          continue;
        }
        case 35: {
          if (tag !== 280) {
            break;
          }

          message.pinId = reader.int64().toString();
          continue;
        }
        case 36: {
          if (tag !== 290) {
            break;
          }

          message.ecStreamerKey = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMessage(): WebcastLinkMessage {
  return {
    common: undefined,
    MessageType: 0,
    LinkerId: "0",
    Scene: 0,
    InviteContent: undefined,
    ReplyContent: undefined,
    CreateContent: undefined,
    CloseContent: undefined,
    EnterContent: undefined,
    LeaveContent: undefined,
    CancelContent: undefined,
    KickOutContent: undefined,
    LinkedListChangeContent: undefined,
    UpdateUserContent: undefined,
    WaitingListChangeContent: undefined,
    MuteContent: undefined,
    RandomMatchContent: undefined,
    UpdateUserSettingContent: undefined,
    MicIdxUpdateContent: undefined,
    ListChangeContent: undefined,
    CohostListChangeContent: undefined,
    MediaChangeContent: undefined,
    AcceptNoticeContent: undefined,
    SysKickOutContent: undefined,
    UserToastContent: undefined,
    extra: "",
    expireTimestamp: "0",
    transferExtra: "",
  };
}

export const WebcastLinkMessageDecoder: MessageFns<WebcastLinkMessage> = {
  encode(message: WebcastLinkMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageDataDecoder.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.MessageType !== 0) {
      writer.uint32(16).int32(message.MessageType);
    }
    if (message.LinkerId !== "0") {
      writer.uint32(24).int64(message.LinkerId);
    }
    if (message.Scene !== 0) {
      writer.uint32(32).int32(message.Scene);
    }
    if (message.InviteContent !== undefined) {
      LinkerInviteContentDecoder.encode(message.InviteContent, writer.uint32(42).fork()).join();
    }
    if (message.ReplyContent !== undefined) {
      LinkerReplyContentDecoder.encode(message.ReplyContent, writer.uint32(50).fork()).join();
    }
    if (message.CreateContent !== undefined) {
      LinkerCreateContentDecoder.encode(message.CreateContent, writer.uint32(58).fork()).join();
    }
    if (message.CloseContent !== undefined) {
      LinkerCloseContentDecoder.encode(message.CloseContent, writer.uint32(66).fork()).join();
    }
    if (message.EnterContent !== undefined) {
      LinkerEnterContentDecoder.encode(message.EnterContent, writer.uint32(74).fork()).join();
    }
    if (message.LeaveContent !== undefined) {
      LinkerLeaveContentDecoder.encode(message.LeaveContent, writer.uint32(82).fork()).join();
    }
    if (message.CancelContent !== undefined) {
      LinkerCancelContentDecoder.encode(message.CancelContent, writer.uint32(90).fork()).join();
    }
    if (message.KickOutContent !== undefined) {
      LinkerKickOutContentDecoder.encode(message.KickOutContent, writer.uint32(98).fork()).join();
    }
    if (message.LinkedListChangeContent !== undefined) {
      LinkerLinkedListChangeContentDecoder.encode(message.LinkedListChangeContent, writer.uint32(106).fork()).join();
    }
    if (message.UpdateUserContent !== undefined) {
      LinkerUpdateUserContentDecoder.encode(message.UpdateUserContent, writer.uint32(114).fork()).join();
    }
    if (message.WaitingListChangeContent !== undefined) {
      LinkerWaitingListChangeContentDecoder.encode(message.WaitingListChangeContent, writer.uint32(122).fork()).join();
    }
    if (message.MuteContent !== undefined) {
      LinkerMuteContentDecoder.encode(message.MuteContent, writer.uint32(130).fork()).join();
    }
    if (message.RandomMatchContent !== undefined) {
      LinkerRandomMatchContentDecoder.encode(message.RandomMatchContent, writer.uint32(138).fork()).join();
    }
    if (message.UpdateUserSettingContent !== undefined) {
      LinkerUpdateUserSettingContentDecoder.encode(message.UpdateUserSettingContent, writer.uint32(146).fork()).join();
    }
    if (message.MicIdxUpdateContent !== undefined) {
      LinkerMicIdxUpdateContentDecoder.encode(message.MicIdxUpdateContent, writer.uint32(154).fork()).join();
    }
    if (message.ListChangeContent !== undefined) {
      LinkerListChangeContentDecoder.encode(message.ListChangeContent, writer.uint32(162).fork()).join();
    }
    if (message.CohostListChangeContent !== undefined) {
      CohostListChangeContentDecoder.encode(message.CohostListChangeContent, writer.uint32(170).fork()).join();
    }
    if (message.MediaChangeContent !== undefined) {
      LinkerMediaChangeContentDecoder.encode(message.MediaChangeContent, writer.uint32(178).fork()).join();
    }
    if (message.AcceptNoticeContent !== undefined) {
      LinkerAcceptNoticeContentDecoder.encode(message.AcceptNoticeContent, writer.uint32(186).fork()).join();
    }
    if (message.SysKickOutContent !== undefined) {
      LinkerSysKickOutContentDecoder.encode(message.SysKickOutContent, writer.uint32(810).fork()).join();
    }
    if (message.UserToastContent !== undefined) {
      LinkmicUserToastContentDecoder.encode(message.UserToastContent, writer.uint32(818).fork()).join();
    }
    if (message.extra !== "") {
      writer.uint32(1602).string(message.extra);
    }
    if (message.expireTimestamp !== "0") {
      writer.uint32(1608).int64(message.expireTimestamp);
    }
    if (message.transferExtra !== "") {
      writer.uint32(1618).string(message.transferExtra);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageDataDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.MessageType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.LinkerId = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.Scene = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.InviteContent = LinkerInviteContentDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.ReplyContent = LinkerReplyContentDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.CreateContent = LinkerCreateContentDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.CloseContent = LinkerCloseContentDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.EnterContent = LinkerEnterContentDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.LeaveContent = LinkerLeaveContentDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.CancelContent = LinkerCancelContentDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.KickOutContent = LinkerKickOutContentDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.LinkedListChangeContent = LinkerLinkedListChangeContentDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.UpdateUserContent = LinkerUpdateUserContentDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.WaitingListChangeContent = LinkerWaitingListChangeContentDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.MuteContent = LinkerMuteContentDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.RandomMatchContent = LinkerRandomMatchContentDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.UpdateUserSettingContent = LinkerUpdateUserSettingContentDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.MicIdxUpdateContent = LinkerMicIdxUpdateContentDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.ListChangeContent = LinkerListChangeContentDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.CohostListChangeContent = CohostListChangeContentDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.MediaChangeContent = LinkerMediaChangeContentDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.AcceptNoticeContent = LinkerAcceptNoticeContentDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 101: {
          if (tag !== 810) {
            break;
          }

          message.SysKickOutContent = LinkerSysKickOutContentDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 102: {
          if (tag !== 818) {
            break;
          }

          message.UserToastContent = LinkmicUserToastContentDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 200: {
          if (tag !== 1602) {
            break;
          }

          message.extra = reader.string();
          continue;
        }
        case 201: {
          if (tag !== 1608) {
            break;
          }

          message.expireTimestamp = reader.int64().toString();
          continue;
        }
        case 202: {
          if (tag !== 1618) {
            break;
          }

          message.transferExtra = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkLayerMessage(): WebcastLinkLayerMessage {
  return {
    common: undefined,
    messageType: 0,
    channelId: "0",
    scene: 0,
    source: "",
    centerizedIdc: "",
    rtcRoomId: "0",
    createChannelContent: undefined,
    listChangeContent: undefined,
    inviteContent: undefined,
    applyContent: undefined,
    permitApplyContent: undefined,
    replyInviteContent: undefined,
    kickOutContent: undefined,
    cancelApplyContent: undefined,
    cancelInviteContent: undefined,
    leaveContent: undefined,
    finishContent: undefined,
    joinDirectContent: undefined,
    joinGroupContent: undefined,
    permitGroupContent: undefined,
    cancelGroupContent: undefined,
    leaveGroupContent: undefined,
    p2pGroupChangeContent: undefined,
    groupChangeContent: undefined,
    businessContent: undefined,
  };
}

export const WebcastLinkLayerMessageDecoder: MessageFns<WebcastLinkLayerMessage> = {
  encode(message: WebcastLinkLayerMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageDataDecoder.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.messageType !== 0) {
      writer.uint32(16).int32(message.messageType);
    }
    if (message.channelId !== "0") {
      writer.uint32(24).int64(message.channelId);
    }
    if (message.scene !== 0) {
      writer.uint32(32).int32(message.scene);
    }
    if (message.source !== "") {
      writer.uint32(42).string(message.source);
    }
    if (message.centerizedIdc !== "") {
      writer.uint32(50).string(message.centerizedIdc);
    }
    if (message.rtcRoomId !== "0") {
      writer.uint32(56).int64(message.rtcRoomId);
    }
    if (message.createChannelContent !== undefined) {
      CreateChannelContentDecoder.encode(message.createChannelContent, writer.uint32(802).fork()).join();
    }
    if (message.listChangeContent !== undefined) {
      ListChangeContentDecoder.encode(message.listChangeContent, writer.uint32(818).fork()).join();
    }
    if (message.inviteContent !== undefined) {
      InviteContentDecoder.encode(message.inviteContent, writer.uint32(826).fork()).join();
    }
    if (message.applyContent !== undefined) {
      ApplyContentDecoder.encode(message.applyContent, writer.uint32(834).fork()).join();
    }
    if (message.permitApplyContent !== undefined) {
      PermitApplyContentDecoder.encode(message.permitApplyContent, writer.uint32(842).fork()).join();
    }
    if (message.replyInviteContent !== undefined) {
      ReplyInviteContentDecoder.encode(message.replyInviteContent, writer.uint32(850).fork()).join();
    }
    if (message.kickOutContent !== undefined) {
      KickOutContentDecoder.encode(message.kickOutContent, writer.uint32(858).fork()).join();
    }
    if (message.cancelApplyContent !== undefined) {
      CancelApplyContentDecoder.encode(message.cancelApplyContent, writer.uint32(866).fork()).join();
    }
    if (message.cancelInviteContent !== undefined) {
      CancelInviteContentDecoder.encode(message.cancelInviteContent, writer.uint32(874).fork()).join();
    }
    if (message.leaveContent !== undefined) {
      LeaveContentDecoder.encode(message.leaveContent, writer.uint32(882).fork()).join();
    }
    if (message.finishContent !== undefined) {
      FinishChannelContentDecoder.encode(message.finishContent, writer.uint32(890).fork()).join();
    }
    if (message.joinDirectContent !== undefined) {
      JoinDirectContentDecoder.encode(message.joinDirectContent, writer.uint32(898).fork()).join();
    }
    if (message.joinGroupContent !== undefined) {
      JoinGroupContentDecoder.encode(message.joinGroupContent, writer.uint32(906).fork()).join();
    }
    if (message.permitGroupContent !== undefined) {
      PermitJoinGroupContentDecoder.encode(message.permitGroupContent, writer.uint32(914).fork()).join();
    }
    if (message.cancelGroupContent !== undefined) {
      CancelJoinGroupContentDecoder.encode(message.cancelGroupContent, writer.uint32(922).fork()).join();
    }
    if (message.leaveGroupContent !== undefined) {
      LeaveJoinGroupContentDecoder.encode(message.leaveGroupContent, writer.uint32(930).fork()).join();
    }
    if (message.p2pGroupChangeContent !== undefined) {
      P2PGroupChangeContentDecoder.encode(message.p2pGroupChangeContent, writer.uint32(938).fork()).join();
    }
    if (message.groupChangeContent !== undefined) {
      GroupChangeContentDecoder.encode(message.groupChangeContent, writer.uint32(946).fork()).join();
    }
    if (message.businessContent !== undefined) {
      BusinessContentDecoder.encode(message.businessContent, writer.uint32(1602).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkLayerMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkLayerMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageDataDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.messageType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.channelId = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.scene = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.source = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.centerizedIdc = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.rtcRoomId = reader.int64().toString();
          continue;
        }
        case 100: {
          if (tag !== 802) {
            break;
          }

          message.createChannelContent = CreateChannelContentDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 102: {
          if (tag !== 818) {
            break;
          }

          message.listChangeContent = ListChangeContentDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 103: {
          if (tag !== 826) {
            break;
          }

          message.inviteContent = InviteContentDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 104: {
          if (tag !== 834) {
            break;
          }

          message.applyContent = ApplyContentDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 105: {
          if (tag !== 842) {
            break;
          }

          message.permitApplyContent = PermitApplyContentDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 106: {
          if (tag !== 850) {
            break;
          }

          message.replyInviteContent = ReplyInviteContentDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 107: {
          if (tag !== 858) {
            break;
          }

          message.kickOutContent = KickOutContentDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 108: {
          if (tag !== 866) {
            break;
          }

          message.cancelApplyContent = CancelApplyContentDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 109: {
          if (tag !== 874) {
            break;
          }

          message.cancelInviteContent = CancelInviteContentDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 110: {
          if (tag !== 882) {
            break;
          }

          message.leaveContent = LeaveContentDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 111: {
          if (tag !== 890) {
            break;
          }

          message.finishContent = FinishChannelContentDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 112: {
          if (tag !== 898) {
            break;
          }

          message.joinDirectContent = JoinDirectContentDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 113: {
          if (tag !== 906) {
            break;
          }

          message.joinGroupContent = JoinGroupContentDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 114: {
          if (tag !== 914) {
            break;
          }

          message.permitGroupContent = PermitJoinGroupContentDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 115: {
          if (tag !== 922) {
            break;
          }

          message.cancelGroupContent = CancelJoinGroupContentDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 116: {
          if (tag !== 930) {
            break;
          }

          message.leaveGroupContent = LeaveJoinGroupContentDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 117: {
          if (tag !== 938) {
            break;
          }

          message.p2pGroupChangeContent = P2PGroupChangeContentDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 118: {
          if (tag !== 946) {
            break;
          }

          message.groupChangeContent = GroupChangeContentDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 200: {
          if (tag !== 1602) {
            break;
          }

          message.businessContent = BusinessContentDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRoomVerifyMessage(): RoomVerifyMessage {
  return { common: undefined, action: 0, content: "", noticeType: "0", closeRoom: false };
}

export const RoomVerifyMessageDecoder: MessageFns<RoomVerifyMessage> = {
  encode(message: RoomVerifyMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageDataDecoder.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.action !== 0) {
      writer.uint32(16).int32(message.action);
    }
    if (message.content !== "") {
      writer.uint32(26).string(message.content);
    }
    if (message.noticeType !== "0") {
      writer.uint32(32).int64(message.noticeType);
    }
    if (message.closeRoom !== false) {
      writer.uint32(40).bool(message.closeRoom);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoomVerifyMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoomVerifyMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageDataDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.action = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.content = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.noticeType = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.closeRoom = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastBarrageMessageOld(): WebcastBarrageMessageOld {
  return { event: undefined, msgType: 0, content: undefined };
}

export const WebcastBarrageMessageOldDecoder: MessageFns<WebcastBarrageMessageOld> = {
  encode(message: WebcastBarrageMessageOld, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.event !== undefined) {
      CommonMessageDataDecoder.encode(message.event, writer.uint32(10).fork()).join();
    }
    if (message.msgType !== 0) {
      writer.uint32(24).int32(message.msgType);
    }
    if (message.content !== undefined) {
      WebcastBarrageMessageOld_TextDecoder.encode(message.content, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastBarrageMessageOld {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastBarrageMessageOld();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.event = CommonMessageDataDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.msgType = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.content = WebcastBarrageMessageOld_TextDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastBarrageMessageOld_Text(): WebcastBarrageMessageOld_Text {
  return { key: "", defaultPattern: "", pieces: [] };
}

export const WebcastBarrageMessageOld_TextDecoder: MessageFns<WebcastBarrageMessageOld_Text> = {
  encode(message: WebcastBarrageMessageOld_Text, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.defaultPattern !== "") {
      writer.uint32(18).string(message.defaultPattern);
    }
    for (const v of message.pieces) {
      WebcastBarrageMessageOld_TextPieceDecoder.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastBarrageMessageOld_Text {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastBarrageMessageOld_Text();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.defaultPattern = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.pieces.push(WebcastBarrageMessageOld_TextPieceDecoder.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastBarrageMessageOld_TextPiece(): WebcastBarrageMessageOld_TextPiece {
  return { type: 0, stringValue: "", userValue: undefined };
}

export const WebcastBarrageMessageOld_TextPieceDecoder: MessageFns<WebcastBarrageMessageOld_TextPiece> = {
  encode(message: WebcastBarrageMessageOld_TextPiece, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.stringValue !== "") {
      writer.uint32(90).string(message.stringValue);
    }
    if (message.userValue !== undefined) {
      WebcastBarrageMessageOld_TextPieceUserDecoder.encode(message.userValue, writer.uint32(170).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastBarrageMessageOld_TextPiece {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastBarrageMessageOld_TextPiece();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.stringValue = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.userValue = WebcastBarrageMessageOld_TextPieceUserDecoder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastBarrageMessageOld_TextPieceUser(): WebcastBarrageMessageOld_TextPieceUser {
  return { user: undefined, withColon: false };
}

export const WebcastBarrageMessageOld_TextPieceUserDecoder: MessageFns<WebcastBarrageMessageOld_TextPieceUser> = {
  encode(message: WebcastBarrageMessageOld_TextPieceUser, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      UserDecoder.encode(message.user, writer.uint32(10).fork()).join();
    }
    if (message.withColon !== false) {
      writer.uint32(16).bool(message.withColon);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastBarrageMessageOld_TextPieceUser {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastBarrageMessageOld_TextPieceUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = UserDecoder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.withColon = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastImEnterRoomMessage(): WebcastImEnterRoomMessage {
  return {
    roomId: "0",
    roomTag: "",
    liveRegion: "",
    liveId: "0",
    identity: "",
    cursor: "",
    accountType: "0",
    enterUniqueId: "0",
    filterWelcomeMsg: "",
    isAnchorContinueKeepMsg: false,
  };
}

export const WebcastImEnterRoomMessageDecoder: MessageFns<WebcastImEnterRoomMessage> = {
  encode(message: WebcastImEnterRoomMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.roomId !== "0") {
      writer.uint32(8).int64(message.roomId);
    }
    if (message.roomTag !== "") {
      writer.uint32(18).string(message.roomTag);
    }
    if (message.liveRegion !== "") {
      writer.uint32(26).string(message.liveRegion);
    }
    if (message.liveId !== "0") {
      writer.uint32(32).int64(message.liveId);
    }
    if (message.identity !== "") {
      writer.uint32(42).string(message.identity);
    }
    if (message.cursor !== "") {
      writer.uint32(50).string(message.cursor);
    }
    if (message.accountType !== "0") {
      writer.uint32(56).int64(message.accountType);
    }
    if (message.enterUniqueId !== "0") {
      writer.uint32(64).int64(message.enterUniqueId);
    }
    if (message.filterWelcomeMsg !== "") {
      writer.uint32(74).string(message.filterWelcomeMsg);
    }
    if (message.isAnchorContinueKeepMsg !== false) {
      writer.uint32(80).bool(message.isAnchorContinueKeepMsg);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastImEnterRoomMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastImEnterRoomMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.roomId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.roomTag = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.liveRegion = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.liveId = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.identity = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.cursor = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.accountType = reader.int64().toString();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.enterUniqueId = reader.int64().toString();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.filterWelcomeMsg = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.isAnchorContinueKeepMsg = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
}
